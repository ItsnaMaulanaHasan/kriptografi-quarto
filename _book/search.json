[
  {
    "objectID": "2_monoalphabetic_random_key.html",
    "href": "2_monoalphabetic_random_key.html",
    "title": "2. Monoalphabetic Random Key",
    "section": "",
    "text": "Analogi Transposisi Kolom\nBayangkan Kita memiliki rak buku dengan beberapa kolom dan setiap kolom berisi tumpukan buku.\nDengan kata lain, transposisi kolom mengubah urutan kolom tanpa mengubah isi kolom. Dalam kriptografi, ini dilakukan untuk mengacak data agar lebih sulit ditebak oleh pihak yang tidak berwenang.",
    "crumbs": [
      "Kriptografi Klasik",
      "2. Monoalphabetic Random Key"
    ]
  },
  {
    "objectID": "2_monoalphabetic_random_key.html#implementasi-pada-python",
    "href": "2_monoalphabetic_random_key.html#implementasi-pada-python",
    "title": "2. Monoalphabetic Random Key",
    "section": "Implementasi Pada Python",
    "text": "Implementasi Pada Python\nMasukkan plaintext\nplainText = input(\"Plaintext : \")\nMasukkan kunci\nkey = input(\"masukkan kunci : \")\nMembersihkan teks dari spasi ganda\ncleanPlainTeks = plainTeks.replace(\" \", \"\")\nprint(cleanPlainTeks)\nDeklarasi urutan huruf dalam alfabet\nascii = {\n'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8, 'i': 9, 'j': 10, 'k': 11, \n'l': 12, 'm': 13, 'n': 14, 'o': 15, 'p': 16, 'q': 17, 'r': 18, 's': 19, 't': 20, 'u': 21, \n'v': 22, 'w': 23, 'x': 24, 'y': 25, 'z': 26\n}\n\nProses Enkripsi\nInisialisasi list untuk menyimpan urutan numerik dari setiap huruf alfabet\nkolom = 0\nangka_urutan = []\nMengonversi setiap huruf dalam kata kunci menjadi urutan numeriknya sesuai dengan posisi dalam alfabet\nfor huruf in key:\n    if huruf.isalpha():\n        angka_urutan.append(ascii[huruf.lower()])\n        kolom = kolom+1\n        cleanKey = angka_urutan\n\nprint(f\"Urutan kunci dari kata '{key}' adalah {angka_urutan}\")\nFor More Detail :\n\nfor huruf in key : Loop ini digunakan untuk memeriksa setiap huruf dalam variabel key, yang diharapkan merupakan kata kunci yang diberikan oleh pengguna\nif huruf.isalpha() : Kondisi ini memastikan bahwa hanya karakter alfabet yang akan diproses. Karakter non-alfabet akan dilewati\n`huruf.lower(): Mengubah huruf menjadi huruf kecil untuk konsistensi, sehingga tidak ada perbedaan antara huruf besar dan kecil\nascii[huruf.lower()] : Mengambil nilai urutan numerik dari huruf. Di sini diasumsikan ada sebuah kamus (dictionary) bernama ascii yang memetakan setiap huruf ke urutan numeriknya\nangka_urutan.append(...) : Menambahkan urutan numerik dari huruf ke dalam list angka_urutan\nkolom = kolom + 1 : Menghitung jumlah kolom dengan menambah nilai kolom setiap kali huruf diproses\ncleanKey = angka_urutan : Menyimpan hasil akhir urutan numerik ke dalam variabel cleanKey\n\nMembuat sebuah matriks kosong untuk menyimpan teks yang telah diolah dalam bentuk matriks\nmatrix = []\nMenghitung panjang dari teks yang telah dibersihkan dan disimpan dalam variabel cleanPlainTeks\npanjang = len(cleanPlainTeks)\nMencari tahu berapa kali kolom dapat digunakan untuk memuat seluruh teks, dengan membagi panjang teks dengan jumlah kolom\ntemp = panjang/kolom\nMembulatkan hasil pembagian sebelumnya ke bilangan bulat terdekat\nbulat = round(temp)\nMenghitung jumlah baris untuk memuat teks dalam matriks\nif temp - bulat == 0:\n    baris = bulat\nelse:\n    if temp - bulat &lt; 0:\n        baris = bulat\n    else:\n        baris = bulat + 1\nprint(baris)\nFor More Detail :\n\ntemp : hasil pembagian panjang teks dengan jumlah kolom\nbulat: hasil pembagian yang dibulatkan ke bilangan bulat terdekat. Jika temp adalah bilangan bulat (tidak ada sisa), jumlah baris adalah bulat. Jika ada sisa, jumlah baris adalah bulat + 1\n\nMengisi matriks dengan karakter dari teks yang telah dibersihkan (cleanPlainTeks)\nfor i in range(baris):\n    row = []\n    for j in range(kolom):\n        if i * kolom + j &lt; len(cleanPlainTeks):\n            elemen = cleanPlainTeks[i * kolom + j]\n        else:\n            elemen = \" \"\n        row.append(elemen)\n    matrix.append(row)\nFor More Detail :\n\nfor i in range(baris) : Loop untuk setiap baris dalam matriks\nrow = [] : Inisialisasi list kosong untuk setiap baris\nif i * kolom + j &lt; len(cleanPlainTeks) : Memeriksa apakah indeks saat ini berada dalam rentang panjang teks yang dibersihkan.\nelemen = cleanPlainTeks[i * kolom + j] : Jika indeks berada dalam rentang, maka ambil karakter dari cleanPlainTeks berdasarkan indeks yang dihitung.\nelse : Jika indeks melebihi panjang teks, isi elemen dengan spasi.\nrow.append(elemen) : Menambahkan elemen ke dalam baris.\nmatrix.append(row) : Menambahkan baris yang telah diisi ke dalam matriks.`\n\nMencetak matriks\nprint(\"Matriks yang Anda buat:\")\nfor row in matrix:\n    print(row)\nMentransposisikan matriks yang telah dibuat dan kemudian mencetak matriks yang telah ditransposisikan\ntransposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\nfor row in transposed_matrix:\n    print(row)\nFor More Detail :\n\nfor i in range(len(matrix[0])) : Iterasi melalui indeks kolom matriks asli\nrow[i] for row in matrix : Untuk setiap indeks kolom i, ambil elemen i dari setiap baris dalam matriks asli dan akan menghasilkan kolom baru dari elemen-elemen tersebut, membentuk baris baru di matriks yang ditransposisikan\n\nMembuat list kosong dengan panjang yang sama dengan cleanKey untuk menyimpan urutan indeks\norder = [None] * len(cleanKey)\nMengurutkan elemen-elemen dalam cleanKey berdasarkan nilai terkecil hingga terbesar\ni = 0\nwhile len(cleanKey) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, cleanKey))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = cleanKey.index(nilai_terkecil)\n\n        order[marker] = i\n        cleanKey[marker] = None \n        i = i + 1\n    else:\n        break\nprint(order)\nFor More Detail :\n\ni = 0 : Inisialisasi counter i\nwhile len(cleanKey) &gt; 0 : Loop hingga cleanKey kosong (semua elemen None)\nnon_none_values = list(filter(lambda x: x is not None, cleanKey)) : Membuat list yang hanya berisi elemen-elemen cleanKey yang bukan None\nif non_none_values : Mengecek apakah list non_none_values tidak kosong nilai_terkecil = min(non_none_values) : Mencari nilai terkecil dari non_none_values\nmarker = cleanKey.index(nilai_terkecil) : Mendapatkan indeks dari nilai terkecil dalam cleanKey Menyimpan Urutan dan Menghapus Nilai Terkecil:\norder[marker] = i : Menyimpan urutan i pada indeks marker di list order\ncleanKey[marker] = None : Menghapus nilai terkecil dari cleanKey dengan mengubahnya menjadi None\ni = i + 1 : Increment counter i.\n\nMengubah urutan kolom matriks transposed_matrix berdasarkan urutan yang telah diatur dalam order, dan kemudian mencetak matriks yang sudah diubah urutan kolomnya\nnew_matrix = []\nwhile len(order) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, order))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = order.index(nilai_terkecil)\n       \n        new_matrix.append(transposed_matrix[marker])\n        order[marker] = None\n    else:\n        break\n\nfor row in new_matrix:\n    print(row)\nFor More Detail :\n\nnew_matrix = [] : Membuat list kosong new_matrix untuk menampung baris-baris matriks yang baru diurutkan Looping untuk Mengubah Urutan Kolom:\nwhile len(order) &gt; 0 : Melakukan looping selama masih ada elemen yang tersisa dalam order\nnon_none_values = list(filter(lambda x: x is not None, order)) : Membuat list non_none_values yang hanya berisi nilai-nilai yang bukan None dari order\nif non_none_values : Memeriksa apakah non_none_values tidak kosong\nnilai_terkecil = min(non_none_values) : Menemukan nilai terkecil dari non_none_values\nmarker = order.index(nilai_terkecil) : Mencari indeks dari nilai_terkecil dalam order\nnew_matrix.append(transposed_matrix[marker]) : Menambahkan baris dari transposed_matrix yang sesuai dengan marker ke new_matrix\norder[marker] = None : Menghapus nilai yang telah diproses dengan mengubahnya menjadi None\nelse: break : Menghentikan loop jika non_none_values kosong, yang berarti semua nilai dalam order telah diproses\n\nMengonversi matriks new_matrix menjadi string tunggal dengan menggabungkan nilai-nilainya secara berurutan dan menghapus spasi ekstra di akhir string\nresult_string = \"\"\n\nfor row in new_matrix:\n    for value in row:\n        result_string += str(value)\n\nresult_string = result_string.strip()\n\nprint(result_string)\nFor More Detail :\n\nresult_string = \"\" : Inisialisasi string kosong result_string yang akan digunakan untuk menyimpan hasil akhir\nfor row in new_matrix: : Melakukan iterasi melalui setiap baris dalam new_matrix\nfor value in row: : Melakukan iterasi melalui setiap nilai dalam baris row\nresult_string += str(value) : Mengonversi nilai value menjadi string (jika belum string) dan menambahkannya ke result_string\nresult_string = result_string.strip() : Menghapus spasi ekstra di awal dan akhir string menggunakan metode strip()\n\nHasil Ciphertext : ENTKFINOKKM TIAIRA\n\n\nProses Dekripsi\ncipherTeks = input(\"masukkan kata : \")\nkey = input(\"masukkan kunci : \")\ncleanCipherTeks = cipherTeks.replace(\" \", \" \")\nprint(cleanCipherTeks)\nkolom = 0\nangka_urutan = []\nfor huruf in key:\n    if huruf.isalpha():\n        angka_urutan.append(ascii[huruf.lower()])\n        kolom = kolom+1\n        cleanKey = angka_urutan\n\nprint(f\"Urutan kunci dari kata '{key}' adalah: {angka_urutan}\")\nmatrix = []\npanjang = len(cleanCipherTeks)\ntemp = panjang/kolom\nbaris = round(temp)\nprint(baris)\nfor i in range(baris):\n    row = []\n    for j in range(kolom):\n        if i * kolom + j &lt; len(cleanCipherTeks):\n            elemen = cleanCipherTeks[i + baris * j]\n        else:\n            elemen = \"a\"\n        row.append(elemen)\n    matrix.append(row)\nprint(\"Matriks yang Anda buat:\")\nfor row in matrix:\n    print(row)\ntransposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\nfor row in transposed_matrix:\n    print(row)\norder = [None] * len(cleanKey)\ni = 0\nwhile len(cleanKey) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, cleanKey))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = cleanKey.index(nilai_terkecil)\n        order[marker] = i\n        cleanKey[marker] = None  \n        i = i + 1\n    else:\n        break\nprint(order)\ntransposed_matrix = [transposed_matrix[i] for i in order]\n\nfor row in transposed_matrix:\n    print(row)\nmatriks = [[row[i] for row in transposed_matrix] for i in range(len(transposed_matrix[0]))]\nfor row in matriks:\n    print(row)\nresult_string = \"\"\n\nfor row in matriks:\n    for value in row:\n        result_string += str(value)\n\nresult_string = result_string.strip()\n\nprint(result_string)\nHasil Dekripsi : TEKNIKINFORMATIKA\nPerbedaan Proses :\n\nEnkripsi: Teks asli diubah menjadi matriks berdasarkan kolom kunci, kemudian kolom-kolom diurutkan berdasarkan kunci. Pada enkripsi, transposed_matrix adalah matriks transposisi dari matrix awal\nDekripsi: Teks sandi diubah menjadi matriks berdasarkan kolom kunci, kemudian baris-baris diurutkan berdasarkan kunci untuk mengembalikan teks asli. Pada dekripsi, transposed_matrix diurutkan berdasarkan order untuk mengembalikan teks asli",
    "crumbs": [
      "Kriptografi Klasik",
      "2. Monoalphabetic Random Key"
    ]
  },
  {
    "objectID": "4_playfair.html",
    "href": "4_playfair.html",
    "title": "4. Playfair",
    "section": "",
    "text": "Analogi Transposisi Kolom\nBayangkan Kita memiliki rak buku dengan beberapa kolom dan setiap kolom berisi tumpukan buku.\nDengan kata lain, transposisi kolom mengubah urutan kolom tanpa mengubah isi kolom. Dalam kriptografi, ini dilakukan untuk mengacak data agar lebih sulit ditebak oleh pihak yang tidak berwenang.",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Playfair"
    ]
  },
  {
    "objectID": "4_playfair.html#pengenalan-responsive-web-design",
    "href": "4_playfair.html#pengenalan-responsive-web-design",
    "title": "4. Playfair",
    "section": "",
    "text": "Responsive Web\n\n\n\n\n&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n\n\n\n\n&lt;img src=\"images.jpg\" style=\"width:100%;\"&gt;\n\n\n&lt;h1 style=\"font-size:10vw\"&gt;Hello World&lt;/h1&gt;",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Playfair"
    ]
  },
  {
    "objectID": "4_playfair.html#responsive-web-design-framework-bootstrap",
    "href": "4_playfair.html#responsive-web-design-framework-bootstrap",
    "title": "4. Playfair",
    "section": "Responsive Web Design Framework (Bootstrap)",
    "text": "Responsive Web Design Framework (Bootstrap)\nBootstrap merupakan HTML, CSS dan Javascript framework paling popular untuk mengambangkan responsive web design yang mengutamakan tampilan mobile (mobile first) Bootstrap dapat diunduh secara gratis pada laman https://getbootstrap.com/. Sampai saat modul ini dibuat versi terakhir adalah Bootstrap v5.3.\n\nMengapa menggunakan Bootstrap?\nBanyak keuntungan dan kemudahan yang diberikan Bootstrap diantaranya adalah: \nBerikut adalah beberapa penjelasan mengenai Bootstrap: \n\nResponsif: Salah satu fitur utama Bootstrap adalah kemampuannya untuk menghasilkan tampilan yang responsif secara otomatis. Dengan menggunakan class CSS yang telah disediakan oleh Bootstrap, elemen-elemen halaman web dapat menyesuaikan diri dengan baik pada berbagai perangkat dan ukuran layar, mulai dari desktop hingga perangkat mobile.\nGrid System: Bootstrap menyediakan sistem grid yang fleksibel untuk membagi layout halaman web menjadi kolom-kolom yang responsif. Grid system ini memungkinkan pengaturan layout yang mudah dan dapat diatur untuk menciptakan tampilan yang rapi dan terstruktur pada berbagai perangkat.\nKomponen Siap Pakai: Bootstrap menyediakan beragam komponen UI siap pakai seperti tombol, navigasi, formulir, jumbotron, kartu, jendela modal, dan banyak lagi. Komponen ini telah dirancang dengan baik dan dapat langsung digunakan dalam proyek tanpa perlu memikirkan desain atau gaya dasar, menghemat waktu dan usaha pengembangan.\nGaya dan Tema: Bootstrap memiliki gaya dan tema default yang estetis dan modern. Selain itu, Bootstrap juga menyediakan beragam tema kustom yang dapat diterapkan dengan mudah untuk memberikan tampilan yang unik dan sesuai dengan kebutuhan proyek Anda. Anda juga dapat menyesuaikan gaya dan tema Bootstrap sesuai dengan preferensi Anda sendiri.\nKompatibilitas Browser: Bootstrap dirancang untuk mendukung sebagian besar browser modern. Ini berarti tampilan dan fungsionalitas situs web yang dibangun dengan menggunakan Bootstrap akan konsisten dan berfungsi dengan baik di berbagai browser yang umum digunakan.\nDokumentasi dan Komunitas: Bootstrap memiliki dokumentasi yang sangat baik, lengkap dengan contoh-contoh kode dan penjelasan yang rinci. Selain itu, karena popularitasnya, Bootstrap memiliki komunitas pengembang yang besar dan aktif, yang dapat memberikan dukungan dan sumber daya yang berguna untuk menjawab pertanyaan, memecahkan masalah, dan berbagi pengalaman.\n\n\n\n\nHTML5\nPenambahan doctype dilakukan untuk menetapkan dokumen HTML sebagai HTML versi 5 (HTML5), agar dapat menggunakan elemen-elemen HTML5 dan properti CSS Bootstrap. Sebagai contohnya pada script berikut. \n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\n&lt;/html&gt;\n\nJika menggunakan Text Editor Visual Studio Code, ketika mengetikan html di awal kode maka akan muncul snippets yang memunculkan beberapa pilihan template kode \n\n\n\nSnippets\n\n\n\n\nGrid System\nPada Bootstrap menerapkan grid system dengan 12 (dua belas) kolom pada setiap halaman. Jika kita tidak menginginkan layout menggunakan ke-12 kolom, kita bisa mengelompokkan kolom bersama untuk membuat kolom yang lebih lebar. Sebagai contoh gambaran dari grid system dengan 12 kolom ditampilkan seperti pada gambar di bawah ini. \n\n\n\nContoh Grid System Bootstrap\n\n\n Sistem grid pada bootstrap dapat menyesuaikan terhadap enam keadaan atau ukuran diantaranya adalah : \n\nEkstra kecil atau extra small (xs)\nKecil atau small (sm)\nSedang atau medium (md)\nBesar atau large (lg)\nEkstra besar atau extra large (xl)\nEkstra ekstra besar atau extra extra large (xxl) \n\n\n\n\nTabel Breakpoint Grid\n\n\n\n\nFungsi Bootsrtap yang umum digunakan\n\nGrid  Seperti yang telah dijelaskan pada Grid System, bahwa pada bootstrap dapat mengelompokkan layout menjadi 12 kolom, dimana kita dapat menggunakan grid ini dengan kelas row yang didalamnya terdapat kelas col, seperti berikut:\n&lt;div class=\"row\"&gt;\n    &lt;div class=\"col\"&gt;&lt;/div&gt;\n    ...\n&lt;/div&gt;&lt;!-- row--&gt;\n Dalam kelas col ini dapat dituliskan dengan value seperti col-4, yang artinya objek yang diberikan kelas tersebut pada row atau baris akan mengisi sebanyak 4 kolom. Dalam 1 row tersebut dapat berisi dengan akumulai 12 kolom.  Selain iitu juga bisa dikombinasikan dengan class breakpoint. Pada seperti yang dijelaskan pada tabel penjelasan grid system bahwa kolom akan mengikuti ukuran breakppoint dari device yang dimasukkan. Misalkan col-md-4, maka ketika ukuran dari device yang digunakan lebih besar dari atau sama dengan 768px maka tampilan kolom akan mendatar memenuhi row, namun akan berubah tampilannya jika ukuran devicenya berkurang 1 pixel saja (kurang dari 768px).\nWarna  Terdapat beberapa template kelas warna yang disediakan oleh Bootstrap diantaranya \n\nPrimary: (Biru tua)\nSecondary: (Abu-abu)\nSuccess: (Hijau)\nDanger: (Merah)\nWarning: (Kuning)\nInfo: (Biru cerah)\nLight: (Putih atau hampir putih)\nDark: (Hitam atau hampir hitam) \n\nPemilihan warna juga merupakan hal yang sangat penting dan perlu diperhatikan.Pemilihan warna akan sangat berpengaruh pada tampilan atau UI sehingga akan mempercantik tampilan dan menarik bagi user. Selain itu dengan warna yang sesuai akan membantu menyampaikan fungsi dari fitur, misalnya merah menandakan suatu yang penting yang memerlukan perhatian lebih, hal tersebut akan memudahkan konsumen dalam menggunakan aplikasi atau disebut user experience\nTypografi  Dalam cara penulisan pada bootstrap memberikan kemudahan dalam mengatur tampilan teks, melalui beberapa class, seperti \n\nHeading, selain menggunakan tag &lt;h1&gt;,&lt;h2&gt;,..,&lt;h6&gt; pada bootstrap juga terdapat kelas heading contohnya:\n&lt;p class=\"h1\"&gt;Heading 1&lt;p&gt;\nDisplay, dengan manambahkan class display pada teks akan memberikan tampilan teks yang besar namun dengan style font yang tipis, misalnya: \n&lt;p class=\"display-1\"&gt;Display 1&lt;/p&gt;\nFont Size, class font size atau yang ditulis fs memberikan styling berupa ukuran dari teks dimana semakin besar nilai fs akan semakin kecil font yang ditampilkan: \n&lt;p class=\"fs-1\"&gt;ini teks&lt;/p&gt;\nFont Weight, melalui font weight dapat memberikan pengaturan terhadap tebal tipis dari font atau teks, dengan parameter bolder, bold, light, lighter, dan normal, berikut contoh penggunaannya: \n&lt;p class=\"fw-bold\"&gt;Ini tebal&lt;/p&gt;\nFont Style, dengan font style kita dapat merubah style dari font atau teks bold dan italic tanpa menggunakan tag html &lt;b&gt; dan &lt;i&gt;, atau sebagai berikut: \n&lt;p class=\"fst-italic\"&gt;ini font style&lt;/p&gt;\n&lt;p class=\"fst-normal\"&gt;ini font style&lt;/p&gt;\n\nSpacing & Sizing \nPengaturan Spasi dan ukuran pada Bootstrap dapat menggunakan padding dan margin, Padding merupakan bagian yang membatasi konten dengan border, sedangkan margin merupakkan bagian yang membatasi antara border dengan bagian luar dari konten. Pengaturan margin dan padding dapat dilakukan dengan mudah hanya dengan menambahkan class m untuk margin dan p untuk padding yang diikuti dengan parameter t (top), b (bottom), s (start), e (end), x (menambahkan pada kedua sis horizontal), y (menambahkan pada kedua sisi vertikal), serta diikuti oleh besar margin atau padding yang diinginkan dengan nilai mulai dari 1 hingga 5, atau seperti berikut:\n ```html\n &lt;!-- Heading --&gt;\n &lt;div class=\"item mt-5 mb-3\"&gt;item1&lt;/div&gt;\n &lt;div class=\"item ms-2 me-3\"&gt;item2&lt;/div&gt;\n &lt;div class=\"item my-5\"&gt;item3&lt;/div&gt;\n &lt;div class=\"item mx-3\"&gt;item4&lt;/div&gt;\n &lt;div class=\"item m-3\"&gt;item4&lt;/div&gt;\n\n &lt;!-- Padding --&gt;\n &lt;div class=\"item pt-5 pb-3\"&gt;item1&lt;/div&gt;\n &lt;div class=\"item ps-2 pe-3\"&gt;item2&lt;/div&gt;\n &lt;div class=\"item py-5\"&gt;item3&lt;/div&gt;\n &lt;div class=\"item px-3\"&gt;item4&lt;/div&gt;\n &lt;div class=\"item p-3\"&gt;item4&lt;/div&gt;\n ```\n\n\n\n\nMargin-Padding-Border\n\n\n\n\n\nKomponen yang umum digunakan\n\nNavbar Navbar pada bootstrap sudah memiliki kemampuan untuk responsif ketika ukuran dari perangkat yang digunakan terlalu kecil untuk menampilkan konten atau menu didalamnya akan otomatis menjadi humberger menu, berikut salah satu contoh dokumentasi navbar yang umum digunakan.\n\n\n\n\nNavbar\n\n\n\nTable Pada class yang disediakan bootstrap terdapat beberapa pilihan tampilan table dan modifikasi yang diberikan, dengan memasukkan tag table ke dalam div yang diberikan kelas dari table yang diinginkan misalnya seperti berikut :\n\n\n\n\nTable\n\n\n\nButton Tombol merupakan bagian terpenting dalam suatu tampilan website yang dapat mengirimkan input dari pengguna ke server. Dalam bootstrap terdapat beberapa variasi yang diberikan untuk penggunaan tombol atau button misalnya warna, bentuk, style, rounded dan masih banyak lagi yang bisa didalami melalui dokumentasi yang ada pada halaman bootstrap\n\n\n\n\nButton\n\n\n\nCard Pada website blog atau e-commerce biasanya menampilkan artikel-artikel mereka pada card dapat menampilkan gambar, serta deskripsi atau tombol untuk melihat lebih banyak mengenai informasi dari blog tersebut. berikut adalah contoh penggunaan card:\n\n\n\n\nCard\n\n\n\n\n\n\n\n\n\n\nResponsive design menggunakan Bootstrap\n\n\n\nBerikut penjelasan mengenai penggunaan bootstrap dan elemen-elemen yang banyak digunakan!",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Playfair"
    ]
  },
  {
    "objectID": "4_playfair.html#implementasi-pada-python",
    "href": "4_playfair.html#implementasi-pada-python",
    "title": "4. Playfair",
    "section": "Implementasi Pada Python",
    "text": "Implementasi Pada Python\nMasukkan plaintext\nplainText = input(\"Plaintext : \")\nMasukkan kunci\nkey = input(\"masukkan kunci : \")\nMembersihkan teks dari spasi ganda\ncleanPlainTeks = plainTeks.replace(\" \", \"\")\nprint(cleanPlainTeks)\nDeklarasi urutan huruf dalam alfabet\nascii = {\n'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8, 'i': 9, 'j': 10, 'k': 11, \n'l': 12, 'm': 13, 'n': 14, 'o': 15, 'p': 16, 'q': 17, 'r': 18, 's': 19, 't': 20, 'u': 21, \n'v': 22, 'w': 23, 'x': 24, 'y': 25, 'z': 26\n}\n\nProses Enkripsi\nInisialisasi list untuk menyimpan urutan numerik dari setiap huruf alfabet\nkolom = 0\nangka_urutan = []\nMengonversi setiap huruf dalam kata kunci menjadi urutan numeriknya sesuai dengan posisi dalam alfabet\nfor huruf in key:\n    if huruf.isalpha():\n        angka_urutan.append(ascii[huruf.lower()])\n        kolom = kolom+1\n        cleanKey = angka_urutan\n\nprint(f\"Urutan kunci dari kata '{key}' adalah {angka_urutan}\")\nFor More Detail :\n\nfor huruf in key : Loop ini digunakan untuk memeriksa setiap huruf dalam variabel key, yang diharapkan merupakan kata kunci yang diberikan oleh pengguna\nif huruf.isalpha() : Kondisi ini memastikan bahwa hanya karakter alfabet yang akan diproses. Karakter non-alfabet akan dilewati\n`huruf.lower(): Mengubah huruf menjadi huruf kecil untuk konsistensi, sehingga tidak ada perbedaan antara huruf besar dan kecil\nascii[huruf.lower()] : Mengambil nilai urutan numerik dari huruf. Di sini diasumsikan ada sebuah kamus (dictionary) bernama ascii yang memetakan setiap huruf ke urutan numeriknya\nangka_urutan.append(...) : Menambahkan urutan numerik dari huruf ke dalam list angka_urutan\nkolom = kolom + 1 : Menghitung jumlah kolom dengan menambah nilai kolom setiap kali huruf diproses\ncleanKey = angka_urutan : Menyimpan hasil akhir urutan numerik ke dalam variabel cleanKey\n\nMembuat sebuah matriks kosong untuk menyimpan teks yang telah diolah dalam bentuk matriks\nmatrix = []\nMenghitung panjang dari teks yang telah dibersihkan dan disimpan dalam variabel cleanPlainTeks\npanjang = len(cleanPlainTeks)\nMencari tahu berapa kali kolom dapat digunakan untuk memuat seluruh teks, dengan membagi panjang teks dengan jumlah kolom\ntemp = panjang/kolom\nMembulatkan hasil pembagian sebelumnya ke bilangan bulat terdekat\nbulat = round(temp)\nMenghitung jumlah baris untuk memuat teks dalam matriks\nif temp - bulat == 0:\n    baris = bulat\nelse:\n    if temp - bulat &lt; 0:\n        baris = bulat\n    else:\n        baris = bulat + 1\nprint(baris)\nFor More Detail :\n\ntemp : hasil pembagian panjang teks dengan jumlah kolom\nbulat: hasil pembagian yang dibulatkan ke bilangan bulat terdekat. Jika temp adalah bilangan bulat (tidak ada sisa), jumlah baris adalah bulat. Jika ada sisa, jumlah baris adalah bulat + 1\n\nMengisi matriks dengan karakter dari teks yang telah dibersihkan (cleanPlainTeks)\nfor i in range(baris):\n    row = []\n    for j in range(kolom):\n        if i * kolom + j &lt; len(cleanPlainTeks):\n            elemen = cleanPlainTeks[i * kolom + j]\n        else:\n            elemen = \" \"\n        row.append(elemen)\n    matrix.append(row)\nFor More Detail :\n\nfor i in range(baris) : Loop untuk setiap baris dalam matriks\nrow = [] : Inisialisasi list kosong untuk setiap baris\nif i * kolom + j &lt; len(cleanPlainTeks) : Memeriksa apakah indeks saat ini berada dalam rentang panjang teks yang dibersihkan.\nelemen = cleanPlainTeks[i * kolom + j] : Jika indeks berada dalam rentang, maka ambil karakter dari cleanPlainTeks berdasarkan indeks yang dihitung.\nelse : Jika indeks melebihi panjang teks, isi elemen dengan spasi.\nrow.append(elemen) : Menambahkan elemen ke dalam baris.\nmatrix.append(row) : Menambahkan baris yang telah diisi ke dalam matriks.`\n\nMencetak matriks\nprint(\"Matriks yang Anda buat:\")\nfor row in matrix:\n    print(row)\nMentransposisikan matriks yang telah dibuat dan kemudian mencetak matriks yang telah ditransposisikan\ntransposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\nfor row in transposed_matrix:\n    print(row)\nFor More Detail :\n\nfor i in range(len(matrix[0])) : Iterasi melalui indeks kolom matriks asli\nrow[i] for row in matrix : Untuk setiap indeks kolom i, ambil elemen i dari setiap baris dalam matriks asli dan akan menghasilkan kolom baru dari elemen-elemen tersebut, membentuk baris baru di matriks yang ditransposisikan\n\nMembuat list kosong dengan panjang yang sama dengan cleanKey untuk menyimpan urutan indeks\norder = [None] * len(cleanKey)\nMengurutkan elemen-elemen dalam cleanKey berdasarkan nilai terkecil hingga terbesar\ni = 0\nwhile len(cleanKey) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, cleanKey))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = cleanKey.index(nilai_terkecil)\n\n        order[marker] = i\n        cleanKey[marker] = None \n        i = i + 1\n    else:\n        break\nprint(order)\nFor More Detail :\n\ni = 0 : Inisialisasi counter i\nwhile len(cleanKey) &gt; 0 : Loop hingga cleanKey kosong (semua elemen None)\nnon_none_values = list(filter(lambda x: x is not None, cleanKey)) : Membuat list yang hanya berisi elemen-elemen cleanKey yang bukan None\nif non_none_values : Mengecek apakah list non_none_values tidak kosong nilai_terkecil = min(non_none_values) : Mencari nilai terkecil dari non_none_values\nmarker = cleanKey.index(nilai_terkecil) : Mendapatkan indeks dari nilai terkecil dalam cleanKey Menyimpan Urutan dan Menghapus Nilai Terkecil:\norder[marker] = i : Menyimpan urutan i pada indeks marker di list order\ncleanKey[marker] = None : Menghapus nilai terkecil dari cleanKey dengan mengubahnya menjadi None\ni = i + 1 : Increment counter i.\n\nMengubah urutan kolom matriks transposed_matrix berdasarkan urutan yang telah diatur dalam order, dan kemudian mencetak matriks yang sudah diubah urutan kolomnya\nnew_matrix = []\nwhile len(order) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, order))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = order.index(nilai_terkecil)\n       \n        new_matrix.append(transposed_matrix[marker])\n        order[marker] = None\n    else:\n        break\n\nfor row in new_matrix:\n    print(row)\nFor More Detail :\n\nnew_matrix = [] : Membuat list kosong new_matrix untuk menampung baris-baris matriks yang baru diurutkan Looping untuk Mengubah Urutan Kolom:\nwhile len(order) &gt; 0 : Melakukan looping selama masih ada elemen yang tersisa dalam order\nnon_none_values = list(filter(lambda x: x is not None, order)) : Membuat list non_none_values yang hanya berisi nilai-nilai yang bukan None dari order\nif non_none_values : Memeriksa apakah non_none_values tidak kosong\nnilai_terkecil = min(non_none_values) : Menemukan nilai terkecil dari non_none_values\nmarker = order.index(nilai_terkecil) : Mencari indeks dari nilai_terkecil dalam order\nnew_matrix.append(transposed_matrix[marker]) : Menambahkan baris dari transposed_matrix yang sesuai dengan marker ke new_matrix\norder[marker] = None : Menghapus nilai yang telah diproses dengan mengubahnya menjadi None\nelse: break : Menghentikan loop jika non_none_values kosong, yang berarti semua nilai dalam order telah diproses\n\nMengonversi matriks new_matrix menjadi string tunggal dengan menggabungkan nilai-nilainya secara berurutan dan menghapus spasi ekstra di akhir string\nresult_string = \"\"\n\nfor row in new_matrix:\n    for value in row:\n        result_string += str(value)\n\nresult_string = result_string.strip()\n\nprint(result_string)\nFor More Detail :\n\nresult_string = \"\" : Inisialisasi string kosong result_string yang akan digunakan untuk menyimpan hasil akhir\nfor row in new_matrix: : Melakukan iterasi melalui setiap baris dalam new_matrix\nfor value in row: : Melakukan iterasi melalui setiap nilai dalam baris row\nresult_string += str(value) : Mengonversi nilai value menjadi string (jika belum string) dan menambahkannya ke result_string\nresult_string = result_string.strip() : Menghapus spasi ekstra di awal dan akhir string menggunakan metode strip()\n\nHasil Ciphertext : ENTKFINOKKM TIAIRA\n\n\nProses Dekripsi\ncipherTeks = input(\"masukkan kata : \")\nkey = input(\"masukkan kunci : \")\ncleanCipherTeks = cipherTeks.replace(\" \", \" \")\nprint(cleanCipherTeks)\nkolom = 0\nangka_urutan = []\nfor huruf in key:\n    if huruf.isalpha():\n        angka_urutan.append(ascii[huruf.lower()])\n        kolom = kolom+1\n        cleanKey = angka_urutan\n\nprint(f\"Urutan kunci dari kata '{key}' adalah: {angka_urutan}\")\nmatrix = []\npanjang = len(cleanCipherTeks)\ntemp = panjang/kolom\nbaris = round(temp)\nprint(baris)\nfor i in range(baris):\n    row = []\n    for j in range(kolom):\n        if i * kolom + j &lt; len(cleanCipherTeks):\n            elemen = cleanCipherTeks[i + baris * j]\n        else:\n            elemen = \"a\"\n        row.append(elemen)\n    matrix.append(row)\nprint(\"Matriks yang Anda buat:\")\nfor row in matrix:\n    print(row)\ntransposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\nfor row in transposed_matrix:\n    print(row)\norder = [None] * len(cleanKey)\ni = 0\nwhile len(cleanKey) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, cleanKey))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = cleanKey.index(nilai_terkecil)\n        order[marker] = i\n        cleanKey[marker] = None  \n        i = i + 1\n    else:\n        break\nprint(order)\ntransposed_matrix = [transposed_matrix[i] for i in order]\n\nfor row in transposed_matrix:\n    print(row)\nmatriks = [[row[i] for row in transposed_matrix] for i in range(len(transposed_matrix[0]))]\nfor row in matriks:\n    print(row)\nresult_string = \"\"\n\nfor row in matriks:\n    for value in row:\n        result_string += str(value)\n\nresult_string = result_string.strip()\n\nprint(result_string)\nHasil Dekripsi : TEKNIKINFORMATIKA\nPerbedaan Proses :\n\nEnkripsi: Teks asli diubah menjadi matriks berdasarkan kolom kunci, kemudian kolom-kolom diurutkan berdasarkan kunci. Pada enkripsi, transposed_matrix adalah matriks transposisi dari matrix awal\nDekripsi: Teks sandi diubah menjadi matriks berdasarkan kolom kunci, kemudian baris-baris diurutkan berdasarkan kunci untuk mengembalikan teks asli. Pada dekripsi, transposed_matrix diurutkan berdasarkan order untuk mengembalikan teks asli",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Playfair"
    ]
  },
  {
    "objectID": "1_caesar.html",
    "href": "1_caesar.html",
    "title": "1. Caesar",
    "section": "",
    "text": "Apa itu Pemrograman Web?\nPemrograman web adalah proses menciptakan dan mengembangkan aplikasi web menggunakan bahasa pemrograman, teknologi, dan standar web.\nAplikasi web dapat diakses melalui browser web dan memungkinkan pengguna untuk berinteraksi dengan konten dan layanan yang disediakan.",
    "crumbs": [
      "Kriptografi Klasik",
      "1. Caesar"
    ]
  },
  {
    "objectID": "1_caesar.html#lingkungan-pengembangan-web",
    "href": "1_caesar.html#lingkungan-pengembangan-web",
    "title": "1. Caesar",
    "section": "Lingkungan Pengembangan Web",
    "text": "Lingkungan Pengembangan Web\n\nEditor kode\n\n\n\nVisual Studio Code\n\n\nGunakan editor teks atau lingkungan pengembangan terintegrasi (IDE) seperti Visual Studio Code, Sublime Text, atau Atom untuk menulis kode web. \n\n\nBrowser\n\nBerbagai browser seperti Chrome, Firefox, atau Safari digunakan untuk menguji dan melihat hasil dari halaman web yang dikembangkan. \n\n\nServer lokal\nAnda dapat menginstal server web lokal seperti Apache, Nginx, atau XAMPP untuk menguji halaman web secara lokal sebelum diunggah ke server publik.\n\n\nURL (Uniform Resource Locator)\nAlamat yang digunakan untuk mengakses halaman web. URL terdiri dari protokol (misalnya http:// atau https://), nama domain, dan path halaman.\n\n\n\nHTTP (Hypertext Transfer Protocol)\nProtokol komunikasi yang digunakan untuk mentransfer data antara klien dan server. Permintaan klien dan respons server terjadi melalui metode HTTP seperti GET, POST, PUT, dan DELETE.\n\n\n\nMarkup Languages\nMarkup languages adalah bahasa yang digunakan untuk membuat struktur dan tampilan konten dalam halaman web.\n\nHTML (HyperText Markup Language) adalah markup language yang paling umum digunakan untuk membangun struktur halaman web. XML (eXtensible Markup Language) digunakan untuk menyimpan dan mengirim data secara terstruktur.\nStruktur Dasar HTML\nMerupakan bahasa markup paling popular, disusul eXtensible Markup Language (XML). XML adalah bahasa yang digunakan untuk membuat bahasa markup lain yaitu Wireless Markup Language (WML).Bahasa markup bukan bahasa pemrograman. Oleh karena itu, penyebutan bahasa pemrograman HTML adalah kurang tepat.\nFormat Dasar HTML\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Untitled Document&lt;/title&gt;\n&lt;meta http-equiv=\"Content-Type\" content=\"text/html;\ncharset=iso-8859-1\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n{ Tempat untuk coding }\n&lt;/body&gt;\n&lt;/html&gt;\n&lt; HTML &gt;\nDokumen HTML harus diawali dengan tag &lt; html &gt; dan diakhiri dengan &lt; /html &gt;memberi tahu kepada browser bahwa yang berada dalam kedua tag tersebut adalah dokumen HTML.\n&lt; HEAD &gt; Bagian header dalam dokumen HTML. Biasanya berisi judul halaman web. Bentuk secara umum:\n&lt;head&gt;\n&lt;title&gt;Judul ini akan ditampilkan pada bagian atas\nbrowser\n&lt;/title&gt;\n&lt;/head&gt;\n&lt; BODY &gt;\nBagian isi dari dokumen HTML yang dapat disisipkan teks, gambar, video maupun link. Sesuatu yang ditulis di dalam bodyakan ditampilkan pada halaman web.\nHTML Tags\nInstruksi/perintah dalam HTML disebut tag. Tag pada HTML tidak bersifat case sensitive.\n&lt;element atribut=value&gt;\nKeterangan:\n\nelement = nama tag\natribut = atribut\nvalue = nilai dari atribut Contoh:\n\n&lt;font color=red&gt;\n\nFONT merupakan element,\nCOLOR merupakan atribut,\nRED adalah value\n\n\n\n\n\n\n\nContoh HTML\n\n\n\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;\nHalaman Latihan 1\n&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;\nIni adalah latihan pemrograman web pertamaku.\n&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nCSS (Cascading Style Sheets) digunakan untuk mengatur tampilan dan gaya elemen-elemen dalam halaman web.\n\n\n\nArsitektur Klien dan Server\n\n\n\nArsitektur Klien dan Server\n\n\nPada pemrograman web, arsitektur klien dan server digunakan. Klien (misalnya browser web) mengirimkan permintaan ke server, dan server merespons dengan mengirimkan halaman web yang diminta.\nKlien menginterpretasikan halaman web menggunakan HTML, CSS, dan JavaScript, sementara server mengurus pemrosesan data dan logika di balik halaman.\n\n\n\nDatabase\n\n\n\nDatabase MySQL\n\n\nDBMS atau Database Management System digunakan untuk menyimpan dan mengelola data dalam aplikasi web. Beberapa sistem database yang umum digunakan termasuk MySQL, PostgreSQL, MongoDB, dan Oracle. Pemahaman tentang database meliputi pembuatan tabel dan relasi antar tabel, manipulasi data dengan menggunakan bahasa query seperti SQL, dan pengoptimalan kinerja database\n\n\n\nFramework\n\n\n\n\n\n\n\n\n\nLaravel\n\n\n\n\n\n\n\nBootstrap\n\n\n\n\n\nFramework adalah kerangka kerja perangkat lunak yang menyediakan struktur, komponen, dan alat bantu untuk membangun aplikasi web dengan lebih cepat dan efisien. Framework menyediakan aturan dan konvensi yang konsisten, menyederhanakan tugas umum, jika seperti routing, validasi data, interaksi dengan database, dan lainnya. Dalam pemrograman web khsusnya dengan menggunakan bahasa pemrograman php yang populer termasuk Laravel dan CodeIgniter. Dalam pemrograman web,\n\n\n\nWeb Servers\n\n\n\nApache Server\n\n\nWeb server adalah perangkat lunak yang mengelola permintaan dari browser dan mengirimkan halaman web ke pengguna melalui protokol HTTP. Beberapa server web yang umum digunakan adalah Apache, Nginx, dan IIS (Internet Information Services). Pemahaman tentang konfigurasi server web, manajemen domain, dan penanganan permintaan HTTP penting dalam pengembangan web.\n\n\n\nVersion Control\nVersion control adalah metode untuk melacak perubahan kode sumber selama pengembangan aplikasi. Git adalah sistem version control yang populer yang memungkinkan pengembang untuk bekerja secara kolaboratif, membuat cabang (branch), menggabungkan perubahan (merge), dan melakukan pemulihan (revert) jika terjadi kesalahan. Version control membantu dalam manajemen kode, pengendalian versi, dan kolaborasi tim.\n\n\n\nResposive Web Design\nResponsive web design adalah pendekatan desain web yang memastikan tampilan dan pengalaman pengguna yang optimal di berbagai perangkat dan ukuran layar. Ini melibatkan penggunaan teknik seperti media queries, flexible grids, dan CSS frameworks (seperti Bootstrap atau Foundation) untuk mengatur tata letak dan tampilan halaman web secara responsif.\n\n\n\nTesting and Debugging\nTesting dan debugging adalah proses penting dalam pengembangan web untuk memastikan aplikasi berfungsi dengan baik dan bebas dari kesalahan. Testing adalah proses verifikasi dan validasi untuk memastikan bahwa aplikasi web berfungsi sesuai dengan yang diharapkan dan memenuhi persyaratan bisnis yang telah ditetapkan. Tujuan dari testing adalah untuk menemukan bug atau kesalahan dalam aplikasi sebelum dirilis ke pengguna akhir. Debugging adalah proses untuk menemukan, mendiagnosis, dan memperbaiki bug atau kesalahan dalam kode aplikasi web.\n\n\n\nAPI (Application Programming Interface)\nAPI adalah antarmuka yang memungkinkan aplikasi web berkomunikasi dan berbagi data dengan aplikasi atau layanan lain. RESTful API adalah pendekatan populer untuk mengembangkan API yang menggunakan protokol HTTP dan standar seperti JSON atau XML untuk bertukar data.",
    "crumbs": [
      "Kriptografi Klasik",
      "1. Caesar"
    ]
  },
  {
    "objectID": "1_caesar.html#php-hypertext-preprocessor",
    "href": "1_caesar.html#php-hypertext-preprocessor",
    "title": "1. Caesar",
    "section": "PHP (Hypertext Preprocessor)",
    "text": "PHP (Hypertext Preprocessor)\nPHP adalah bahasa pemrograman server-side yang populer untuk pengembangan web. PHP digunakan untuk memproses permintaan dari klien, mengakses basis data, dan menghasilkan respons yang dikirimkan kembali ke klien.\n\nMemulai PHP\nSetiap memulai kode php selalu diawali dengan &lt;?php dan ditutup dengan ?&gt; \n&lt;?php\n    $kata = \"Hello World!\"\n    echo \"$kata\"; // Output: Hello World!\n?&gt;\nMenggunakan echo untuk print\nDalam variabel php menggunakan tanda $ ($variable) untuk inisialisasi variabel\n\n\nPHP - Kondisional\nKondisional dalam bahasa pemrograman adalah proses yang berfungsi untuk menentukan blok instruksi akan dieksekusi atau tidak, tergantung pada kondisinya sendiri seperti nilainya sudah benar (True) atau belum (False). Ada beberapa jenis percabangan yaitu if-else, switch case dll.\n$angka = -5;\nif($angka &lt; 0){\n    echo 'Angka negatif';\n} else {\n    echo'Angka positif ';\n};\n//Output : Angka Negatif\n$input = 3;\nswitch($input){\n    case \"1\":\n    echo\"Inputan adalah satu\";\n    break;\n    case \"2\":\n    echo\"Inputan adalah dua\";\n    break;\n    case \"3\":\n    echo\"Inputan adalah tiga\";\n    break;\n    default:\n    echo\"Tidak ada input yang cocok dengan pilihan anda.\";\n    }\n    /* Output: Inputan adalah tiga\n    Jika nilai dari variable `$input` bukan sama dengan `case`,\n    maka akan menampilkan pesan “Tidak ada input yang cocok\n    */\n\n\n\nPHP – isset dan empty\nFungsi isset digunakan untuk memeriksa apakah suatu variabel telah diatur atau tidak. Sintaks fungsi ini sebagai berikut:\n$nama = \"Bengkel Koding\";\nif(isset($nama)){\n    print(\"Nama telah diatur\");\n} else {\n    print(\"Nama belum diatur\")\n}\n// output : Nama telah diatur\n\nFungsi empty digunakan untuk memeriksa apakah suatu variabel kosong atau tidak. Sintaks fungsi ini sebagai berikut:\n$nama = \"\";\nif(empty($nama)) {\n    print(\"nama kosong\");\n} else {\n    print(\"nama tidak kosong\");\n}\n// output : Nama kosong\n\n\n\nPHP - Looping\nPerulangan pada php terdapat beberapa fungsi yang dapat digunakan, diantaranya adalah for, while, do while, dan foreach\n\nLooping For\nLooping For adalah salah satu looping statement pada bahasa pemrograman php, yang memiliki sintaks seperti for (expression1; expression2; expression3) {} dimana expression 1 merupakan awal dari pengulangan, expression 2 menentukan kondisi yang harus terpenuhi agar perintah d iterasi lebih lanjut, sedangkan expresion 3 mengubah nilai variable dalam setiap iterasinya.\nContoh Penggunaannya:\nfor ($i=0;$i&lt;=5;$i++){\necho \"$i \";\n}\n// Output: 0 1 2 3 4 5\nDalam contoh diatas, nilai x mulai dari angka 0 dan terus ditambah sampai batas yaitu &lt;=5. Setelah itu akan di eksekusi dengan cara mencetak isi value dari x ke layar.\n\n\nWhile\nLooping while juga ada didalam bahasa pemograman PHP, sintaksnya sama tapi bedanya hanya bisa melakukan looping selama kondisinya benar/true.\nContohnya:\n$x = 0; //awal variabel $x\nwhile($x &lt;= 5){\necho \"$x \";\n$x++;\n}\n// Output : 0 1 2 3 4 5\n\n\nDo While\nPerulangan do-while adalah perintah yang digunakan untuk mengulang suatu proses terhadap nilai kondisional (expression) saat awal loop dilanjutkan dengan evaluasi ulang pada akhir setiap iterasi.\nSintaks nya adalah sebagai berikut:\n$i = 1;\ndo{\n    echo $i;\n    $i++;\n} while ($i &lt;= 5);\n// Output : 0 1 2 3 4 5\n\n\nForeach\nForeach merupakan perintah yang digunakan untuk mengiterasi set data array dalam bahasa pemrograman php. Sintaks nya seperti ini:\n$buah = array(\"Apel\", \"Jeruk\", \"Mangga\", \"Pisang\");\nforeach ($buah as $item) :\n    echo $item . \"\\n\";\nendforeach;\n/* output : \napel\njeruk\nmangga\npisang\n*/\nSelain menggnakan endforeach bisa juga menggunakan kurung kurawal {}\n$buah = array(\"Apel\", \"Jeruk\", \"Mangga\", \"Pisang\");\nforeach ($buah as $item) {\n    echo $item . \"\\n\";\n}\n/* output : \napel\njeruk\nmangga\npisang\n*/\n\n\n\nInclude - Require\nFungsi-fungsi ini digunakan untuk menyisipkan (include) atau memasukkan (require) file PHP eksternal ke dalam file PHP yang sedang aktif. Berguna untuk mengorganisir kode secara modular.",
    "crumbs": [
      "Kriptografi Klasik",
      "1. Caesar"
    ]
  }
]