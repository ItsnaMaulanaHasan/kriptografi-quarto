[
  {
    "objectID": "2_monoalphabetic_random_key.html",
    "href": "2_monoalphabetic_random_key.html",
    "title": "2. Monoalphabetic Random Key",
    "section": "",
    "text": "Analogi Transposisi Kolom\nBayangkan Kita memiliki rak buku dengan beberapa kolom dan setiap kolom berisi tumpukan buku.\nDengan kata lain, transposisi kolom mengubah urutan kolom tanpa mengubah isi kolom. Dalam kriptografi, ini dilakukan untuk mengacak data agar lebih sulit ditebak oleh pihak yang tidak berwenang.",
    "crumbs": [
      "Kriptografi Klasik",
      "2. Monoalphabetic Random Key"
    ]
  },
  {
    "objectID": "2_monoalphabetic_random_key.html#implementasi-pada-python",
    "href": "2_monoalphabetic_random_key.html#implementasi-pada-python",
    "title": "2. Monoalphabetic Random Key",
    "section": "Implementasi Pada Python",
    "text": "Implementasi Pada Python\nMasukkan plaintext\nplainText = input(\"Plaintext : \")\nMasukkan kunci\nkey = input(\"masukkan kunci : \")\nMembersihkan teks dari spasi ganda\ncleanPlainTeks = plainTeks.replace(\" \", \"\")\nprint(cleanPlainTeks)\nDeklarasi urutan huruf dalam alfabet\nascii = {\n'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8, 'i': 9, 'j': 10, 'k': 11, \n'l': 12, 'm': 13, 'n': 14, 'o': 15, 'p': 16, 'q': 17, 'r': 18, 's': 19, 't': 20, 'u': 21, \n'v': 22, 'w': 23, 'x': 24, 'y': 25, 'z': 26\n}\n\nProses Enkripsi\nInisialisasi list untuk menyimpan urutan numerik dari setiap huruf alfabet\nkolom = 0\nangka_urutan = []\nMengonversi setiap huruf dalam kata kunci menjadi urutan numeriknya sesuai dengan posisi dalam alfabet\nfor huruf in key:\n    if huruf.isalpha():\n        angka_urutan.append(ascii[huruf.lower()])\n        kolom = kolom+1\n        cleanKey = angka_urutan\n\nprint(f\"Urutan kunci dari kata '{key}' adalah {angka_urutan}\")\nFor More Detail :\n\nfor huruf in key : Loop ini digunakan untuk memeriksa setiap huruf dalam variabel key, yang diharapkan merupakan kata kunci yang diberikan oleh pengguna\nif huruf.isalpha() : Kondisi ini memastikan bahwa hanya karakter alfabet yang akan diproses. Karakter non-alfabet akan dilewati\n`huruf.lower(): Mengubah huruf menjadi huruf kecil untuk konsistensi, sehingga tidak ada perbedaan antara huruf besar dan kecil\nascii[huruf.lower()] : Mengambil nilai urutan numerik dari huruf. Di sini diasumsikan ada sebuah kamus (dictionary) bernama ascii yang memetakan setiap huruf ke urutan numeriknya\nangka_urutan.append(...) : Menambahkan urutan numerik dari huruf ke dalam list angka_urutan\nkolom = kolom + 1 : Menghitung jumlah kolom dengan menambah nilai kolom setiap kali huruf diproses\ncleanKey = angka_urutan : Menyimpan hasil akhir urutan numerik ke dalam variabel cleanKey\n\nMembuat sebuah matriks kosong untuk menyimpan teks yang telah diolah dalam bentuk matriks\nmatrix = []\nMenghitung panjang dari teks yang telah dibersihkan dan disimpan dalam variabel cleanPlainTeks\npanjang = len(cleanPlainTeks)\nMencari tahu berapa kali kolom dapat digunakan untuk memuat seluruh teks, dengan membagi panjang teks dengan jumlah kolom\ntemp = panjang/kolom\nMembulatkan hasil pembagian sebelumnya ke bilangan bulat terdekat\nbulat = round(temp)\nMenghitung jumlah baris untuk memuat teks dalam matriks\nif temp - bulat == 0:\n    baris = bulat\nelse:\n    if temp - bulat &lt; 0:\n        baris = bulat\n    else:\n        baris = bulat + 1\nprint(baris)\nFor More Detail :\n\ntemp : hasil pembagian panjang teks dengan jumlah kolom\nbulat: hasil pembagian yang dibulatkan ke bilangan bulat terdekat. Jika temp adalah bilangan bulat (tidak ada sisa), jumlah baris adalah bulat. Jika ada sisa, jumlah baris adalah bulat + 1\n\nMengisi matriks dengan karakter dari teks yang telah dibersihkan (cleanPlainTeks)\nfor i in range(baris):\n    row = []\n    for j in range(kolom):\n        if i * kolom + j &lt; len(cleanPlainTeks):\n            elemen = cleanPlainTeks[i * kolom + j]\n        else:\n            elemen = \" \"\n        row.append(elemen)\n    matrix.append(row)\nFor More Detail :\n\nfor i in range(baris) : Loop untuk setiap baris dalam matriks\nrow = [] : Inisialisasi list kosong untuk setiap baris\nif i * kolom + j &lt; len(cleanPlainTeks) : Memeriksa apakah indeks saat ini berada dalam rentang panjang teks yang dibersihkan.\nelemen = cleanPlainTeks[i * kolom + j] : Jika indeks berada dalam rentang, maka ambil karakter dari cleanPlainTeks berdasarkan indeks yang dihitung.\nelse : Jika indeks melebihi panjang teks, isi elemen dengan spasi.\nrow.append(elemen) : Menambahkan elemen ke dalam baris.\nmatrix.append(row) : Menambahkan baris yang telah diisi ke dalam matriks.`\n\nMencetak matriks\nprint(\"Matriks yang Anda buat:\")\nfor row in matrix:\n    print(row)\nMentransposisikan matriks yang telah dibuat dan kemudian mencetak matriks yang telah ditransposisikan\ntransposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\nfor row in transposed_matrix:\n    print(row)\nFor More Detail :\n\nfor i in range(len(matrix[0])) : Iterasi melalui indeks kolom matriks asli\nrow[i] for row in matrix : Untuk setiap indeks kolom i, ambil elemen i dari setiap baris dalam matriks asli dan akan menghasilkan kolom baru dari elemen-elemen tersebut, membentuk baris baru di matriks yang ditransposisikan\n\nMembuat list kosong dengan panjang yang sama dengan cleanKey untuk menyimpan urutan indeks\norder = [None] * len(cleanKey)\nMengurutkan elemen-elemen dalam cleanKey berdasarkan nilai terkecil hingga terbesar\ni = 0\nwhile len(cleanKey) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, cleanKey))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = cleanKey.index(nilai_terkecil)\n\n        order[marker] = i\n        cleanKey[marker] = None \n        i = i + 1\n    else:\n        break\nprint(order)\nFor More Detail :\n\ni = 0 : Inisialisasi counter i\nwhile len(cleanKey) &gt; 0 : Loop hingga cleanKey kosong (semua elemen None)\nnon_none_values = list(filter(lambda x: x is not None, cleanKey)) : Membuat list yang hanya berisi elemen-elemen cleanKey yang bukan None\nif non_none_values : Mengecek apakah list non_none_values tidak kosong nilai_terkecil = min(non_none_values) : Mencari nilai terkecil dari non_none_values\nmarker = cleanKey.index(nilai_terkecil) : Mendapatkan indeks dari nilai terkecil dalam cleanKey Menyimpan Urutan dan Menghapus Nilai Terkecil:\norder[marker] = i : Menyimpan urutan i pada indeks marker di list order\ncleanKey[marker] = None : Menghapus nilai terkecil dari cleanKey dengan mengubahnya menjadi None\ni = i + 1 : Increment counter i.\n\nMengubah urutan kolom matriks transposed_matrix berdasarkan urutan yang telah diatur dalam order, dan kemudian mencetak matriks yang sudah diubah urutan kolomnya\nnew_matrix = []\nwhile len(order) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, order))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = order.index(nilai_terkecil)\n       \n        new_matrix.append(transposed_matrix[marker])\n        order[marker] = None\n    else:\n        break\n\nfor row in new_matrix:\n    print(row)\nFor More Detail :\n\nnew_matrix = [] : Membuat list kosong new_matrix untuk menampung baris-baris matriks yang baru diurutkan Looping untuk Mengubah Urutan Kolom:\nwhile len(order) &gt; 0 : Melakukan looping selama masih ada elemen yang tersisa dalam order\nnon_none_values = list(filter(lambda x: x is not None, order)) : Membuat list non_none_values yang hanya berisi nilai-nilai yang bukan None dari order\nif non_none_values : Memeriksa apakah non_none_values tidak kosong\nnilai_terkecil = min(non_none_values) : Menemukan nilai terkecil dari non_none_values\nmarker = order.index(nilai_terkecil) : Mencari indeks dari nilai_terkecil dalam order\nnew_matrix.append(transposed_matrix[marker]) : Menambahkan baris dari transposed_matrix yang sesuai dengan marker ke new_matrix\norder[marker] = None : Menghapus nilai yang telah diproses dengan mengubahnya menjadi None\nelse: break : Menghentikan loop jika non_none_values kosong, yang berarti semua nilai dalam order telah diproses\n\nMengonversi matriks new_matrix menjadi string tunggal dengan menggabungkan nilai-nilainya secara berurutan dan menghapus spasi ekstra di akhir string\nresult_string = \"\"\n\nfor row in new_matrix:\n    for value in row:\n        result_string += str(value)\n\nresult_string = result_string.strip()\n\nprint(result_string)\nFor More Detail :\n\nresult_string = \"\" : Inisialisasi string kosong result_string yang akan digunakan untuk menyimpan hasil akhir\nfor row in new_matrix: : Melakukan iterasi melalui setiap baris dalam new_matrix\nfor value in row: : Melakukan iterasi melalui setiap nilai dalam baris row\nresult_string += str(value) : Mengonversi nilai value menjadi string (jika belum string) dan menambahkannya ke result_string\nresult_string = result_string.strip() : Menghapus spasi ekstra di awal dan akhir string menggunakan metode strip()\n\nHasil Ciphertext : ENTKFINOKKM TIAIRA\n\n\nProses Dekripsi\ncipherTeks = input(\"masukkan kata : \")\nkey = input(\"masukkan kunci : \")\ncleanCipherTeks = cipherTeks.replace(\" \", \" \")\nprint(cleanCipherTeks)\nkolom = 0\nangka_urutan = []\nfor huruf in key:\n    if huruf.isalpha():\n        angka_urutan.append(ascii[huruf.lower()])\n        kolom = kolom+1\n        cleanKey = angka_urutan\n\nprint(f\"Urutan kunci dari kata '{key}' adalah: {angka_urutan}\")\nmatrix = []\npanjang = len(cleanCipherTeks)\ntemp = panjang/kolom\nbaris = round(temp)\nprint(baris)\nfor i in range(baris):\n    row = []\n    for j in range(kolom):\n        if i * kolom + j &lt; len(cleanCipherTeks):\n            elemen = cleanCipherTeks[i + baris * j]\n        else:\n            elemen = \"a\"\n        row.append(elemen)\n    matrix.append(row)\nprint(\"Matriks yang Anda buat:\")\nfor row in matrix:\n    print(row)\ntransposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\nfor row in transposed_matrix:\n    print(row)\norder = [None] * len(cleanKey)\ni = 0\nwhile len(cleanKey) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, cleanKey))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = cleanKey.index(nilai_terkecil)\n        order[marker] = i\n        cleanKey[marker] = None  \n        i = i + 1\n    else:\n        break\nprint(order)\ntransposed_matrix = [transposed_matrix[i] for i in order]\n\nfor row in transposed_matrix:\n    print(row)\nmatriks = [[row[i] for row in transposed_matrix] for i in range(len(transposed_matrix[0]))]\nfor row in matriks:\n    print(row)\nresult_string = \"\"\n\nfor row in matriks:\n    for value in row:\n        result_string += str(value)\n\nresult_string = result_string.strip()\n\nprint(result_string)\nHasil Dekripsi : TEKNIKINFORMATIKA\nPerbedaan Proses :\n\nEnkripsi: Teks asli diubah menjadi matriks berdasarkan kolom kunci, kemudian kolom-kolom diurutkan berdasarkan kunci. Pada enkripsi, transposed_matrix adalah matriks transposisi dari matrix awal\nDekripsi: Teks sandi diubah menjadi matriks berdasarkan kolom kunci, kemudian baris-baris diurutkan berdasarkan kunci untuk mengembalikan teks asli. Pada dekripsi, transposed_matrix diurutkan berdasarkan order untuk mengembalikan teks asli",
    "crumbs": [
      "Kriptografi Klasik",
      "2. Monoalphabetic Random Key"
    ]
  },
  {
    "objectID": "4_playfair.html",
    "href": "4_playfair.html",
    "title": "4. Playfair",
    "section": "",
    "text": "Analogi Transposisi Kolom\nBayangkan Kita memiliki rak buku dengan beberapa kolom dan setiap kolom berisi tumpukan buku.\nDengan kata lain, transposisi kolom mengubah urutan kolom tanpa mengubah isi kolom. Dalam kriptografi, ini dilakukan untuk mengacak data agar lebih sulit ditebak oleh pihak yang tidak berwenang.",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Playfair"
    ]
  },
  {
    "objectID": "4_playfair.html#pengenalan-responsive-web-design",
    "href": "4_playfair.html#pengenalan-responsive-web-design",
    "title": "4. Playfair",
    "section": "",
    "text": "Responsive Web\n\n\n\n\n&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n\n\n\n\n&lt;img src=\"images.jpg\" style=\"width:100%;\"&gt;\n\n\n&lt;h1 style=\"font-size:10vw\"&gt;Hello World&lt;/h1&gt;",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Playfair"
    ]
  },
  {
    "objectID": "4_playfair.html#responsive-web-design-framework-bootstrap",
    "href": "4_playfair.html#responsive-web-design-framework-bootstrap",
    "title": "4. Playfair",
    "section": "Responsive Web Design Framework (Bootstrap)",
    "text": "Responsive Web Design Framework (Bootstrap)\nBootstrap merupakan HTML, CSS dan Javascript framework paling popular untuk mengambangkan responsive web design yang mengutamakan tampilan mobile (mobile first) Bootstrap dapat diunduh secara gratis pada laman https://getbootstrap.com/. Sampai saat modul ini dibuat versi terakhir adalah Bootstrap v5.3.\n\nMengapa menggunakan Bootstrap?\nBanyak keuntungan dan kemudahan yang diberikan Bootstrap diantaranya adalah: \nBerikut adalah beberapa penjelasan mengenai Bootstrap: \n\nResponsif: Salah satu fitur utama Bootstrap adalah kemampuannya untuk menghasilkan tampilan yang responsif secara otomatis. Dengan menggunakan class CSS yang telah disediakan oleh Bootstrap, elemen-elemen halaman web dapat menyesuaikan diri dengan baik pada berbagai perangkat dan ukuran layar, mulai dari desktop hingga perangkat mobile.\nGrid System: Bootstrap menyediakan sistem grid yang fleksibel untuk membagi layout halaman web menjadi kolom-kolom yang responsif. Grid system ini memungkinkan pengaturan layout yang mudah dan dapat diatur untuk menciptakan tampilan yang rapi dan terstruktur pada berbagai perangkat.\nKomponen Siap Pakai: Bootstrap menyediakan beragam komponen UI siap pakai seperti tombol, navigasi, formulir, jumbotron, kartu, jendela modal, dan banyak lagi. Komponen ini telah dirancang dengan baik dan dapat langsung digunakan dalam proyek tanpa perlu memikirkan desain atau gaya dasar, menghemat waktu dan usaha pengembangan.\nGaya dan Tema: Bootstrap memiliki gaya dan tema default yang estetis dan modern. Selain itu, Bootstrap juga menyediakan beragam tema kustom yang dapat diterapkan dengan mudah untuk memberikan tampilan yang unik dan sesuai dengan kebutuhan proyek Anda. Anda juga dapat menyesuaikan gaya dan tema Bootstrap sesuai dengan preferensi Anda sendiri.\nKompatibilitas Browser: Bootstrap dirancang untuk mendukung sebagian besar browser modern. Ini berarti tampilan dan fungsionalitas situs web yang dibangun dengan menggunakan Bootstrap akan konsisten dan berfungsi dengan baik di berbagai browser yang umum digunakan.\nDokumentasi dan Komunitas: Bootstrap memiliki dokumentasi yang sangat baik, lengkap dengan contoh-contoh kode dan penjelasan yang rinci. Selain itu, karena popularitasnya, Bootstrap memiliki komunitas pengembang yang besar dan aktif, yang dapat memberikan dukungan dan sumber daya yang berguna untuk menjawab pertanyaan, memecahkan masalah, dan berbagi pengalaman.\n\n\n\n\nHTML5\nPenambahan doctype dilakukan untuk menetapkan dokumen HTML sebagai HTML versi 5 (HTML5), agar dapat menggunakan elemen-elemen HTML5 dan properti CSS Bootstrap. Sebagai contohnya pada script berikut. \n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\n&lt;/html&gt;\n\nJika menggunakan Text Editor Visual Studio Code, ketika mengetikan html di awal kode maka akan muncul snippets yang memunculkan beberapa pilihan template kode \n\n\n\nSnippets\n\n\n\n\nGrid System\nPada Bootstrap menerapkan grid system dengan 12 (dua belas) kolom pada setiap halaman. Jika kita tidak menginginkan layout menggunakan ke-12 kolom, kita bisa mengelompokkan kolom bersama untuk membuat kolom yang lebih lebar. Sebagai contoh gambaran dari grid system dengan 12 kolom ditampilkan seperti pada gambar di bawah ini. \n\n\n\nContoh Grid System Bootstrap\n\n\n Sistem grid pada bootstrap dapat menyesuaikan terhadap enam keadaan atau ukuran diantaranya adalah : \n\nEkstra kecil atau extra small (xs)\nKecil atau small (sm)\nSedang atau medium (md)\nBesar atau large (lg)\nEkstra besar atau extra large (xl)\nEkstra ekstra besar atau extra extra large (xxl) \n\n\n\n\nTabel Breakpoint Grid\n\n\n\n\nFungsi Bootsrtap yang umum digunakan\n\nGrid  Seperti yang telah dijelaskan pada Grid System, bahwa pada bootstrap dapat mengelompokkan layout menjadi 12 kolom, dimana kita dapat menggunakan grid ini dengan kelas row yang didalamnya terdapat kelas col, seperti berikut:\n&lt;div class=\"row\"&gt;\n    &lt;div class=\"col\"&gt;&lt;/div&gt;\n    ...\n&lt;/div&gt;&lt;!-- row--&gt;\n Dalam kelas col ini dapat dituliskan dengan value seperti col-4, yang artinya objek yang diberikan kelas tersebut pada row atau baris akan mengisi sebanyak 4 kolom. Dalam 1 row tersebut dapat berisi dengan akumulai 12 kolom.  Selain iitu juga bisa dikombinasikan dengan class breakpoint. Pada seperti yang dijelaskan pada tabel penjelasan grid system bahwa kolom akan mengikuti ukuran breakppoint dari device yang dimasukkan. Misalkan col-md-4, maka ketika ukuran dari device yang digunakan lebih besar dari atau sama dengan 768px maka tampilan kolom akan mendatar memenuhi row, namun akan berubah tampilannya jika ukuran devicenya berkurang 1 pixel saja (kurang dari 768px).\nWarna  Terdapat beberapa template kelas warna yang disediakan oleh Bootstrap diantaranya \n\nPrimary: (Biru tua)\nSecondary: (Abu-abu)\nSuccess: (Hijau)\nDanger: (Merah)\nWarning: (Kuning)\nInfo: (Biru cerah)\nLight: (Putih atau hampir putih)\nDark: (Hitam atau hampir hitam) \n\nPemilihan warna juga merupakan hal yang sangat penting dan perlu diperhatikan.Pemilihan warna akan sangat berpengaruh pada tampilan atau UI sehingga akan mempercantik tampilan dan menarik bagi user. Selain itu dengan warna yang sesuai akan membantu menyampaikan fungsi dari fitur, misalnya merah menandakan suatu yang penting yang memerlukan perhatian lebih, hal tersebut akan memudahkan konsumen dalam menggunakan aplikasi atau disebut user experience\nTypografi  Dalam cara penulisan pada bootstrap memberikan kemudahan dalam mengatur tampilan teks, melalui beberapa class, seperti \n\nHeading, selain menggunakan tag &lt;h1&gt;,&lt;h2&gt;,..,&lt;h6&gt; pada bootstrap juga terdapat kelas heading contohnya:\n&lt;p class=\"h1\"&gt;Heading 1&lt;p&gt;\nDisplay, dengan manambahkan class display pada teks akan memberikan tampilan teks yang besar namun dengan style font yang tipis, misalnya: \n&lt;p class=\"display-1\"&gt;Display 1&lt;/p&gt;\nFont Size, class font size atau yang ditulis fs memberikan styling berupa ukuran dari teks dimana semakin besar nilai fs akan semakin kecil font yang ditampilkan: \n&lt;p class=\"fs-1\"&gt;ini teks&lt;/p&gt;\nFont Weight, melalui font weight dapat memberikan pengaturan terhadap tebal tipis dari font atau teks, dengan parameter bolder, bold, light, lighter, dan normal, berikut contoh penggunaannya: \n&lt;p class=\"fw-bold\"&gt;Ini tebal&lt;/p&gt;\nFont Style, dengan font style kita dapat merubah style dari font atau teks bold dan italic tanpa menggunakan tag html &lt;b&gt; dan &lt;i&gt;, atau sebagai berikut: \n&lt;p class=\"fst-italic\"&gt;ini font style&lt;/p&gt;\n&lt;p class=\"fst-normal\"&gt;ini font style&lt;/p&gt;\n\nSpacing & Sizing \nPengaturan Spasi dan ukuran pada Bootstrap dapat menggunakan padding dan margin, Padding merupakan bagian yang membatasi konten dengan border, sedangkan margin merupakkan bagian yang membatasi antara border dengan bagian luar dari konten. Pengaturan margin dan padding dapat dilakukan dengan mudah hanya dengan menambahkan class m untuk margin dan p untuk padding yang diikuti dengan parameter t (top), b (bottom), s (start), e (end), x (menambahkan pada kedua sis horizontal), y (menambahkan pada kedua sisi vertikal), serta diikuti oleh besar margin atau padding yang diinginkan dengan nilai mulai dari 1 hingga 5, atau seperti berikut:\n ```html\n &lt;!-- Heading --&gt;\n &lt;div class=\"item mt-5 mb-3\"&gt;item1&lt;/div&gt;\n &lt;div class=\"item ms-2 me-3\"&gt;item2&lt;/div&gt;\n &lt;div class=\"item my-5\"&gt;item3&lt;/div&gt;\n &lt;div class=\"item mx-3\"&gt;item4&lt;/div&gt;\n &lt;div class=\"item m-3\"&gt;item4&lt;/div&gt;\n\n &lt;!-- Padding --&gt;\n &lt;div class=\"item pt-5 pb-3\"&gt;item1&lt;/div&gt;\n &lt;div class=\"item ps-2 pe-3\"&gt;item2&lt;/div&gt;\n &lt;div class=\"item py-5\"&gt;item3&lt;/div&gt;\n &lt;div class=\"item px-3\"&gt;item4&lt;/div&gt;\n &lt;div class=\"item p-3\"&gt;item4&lt;/div&gt;\n ```\n\n\n\n\nMargin-Padding-Border\n\n\n\n\n\nKomponen yang umum digunakan\n\nNavbar Navbar pada bootstrap sudah memiliki kemampuan untuk responsif ketika ukuran dari perangkat yang digunakan terlalu kecil untuk menampilkan konten atau menu didalamnya akan otomatis menjadi humberger menu, berikut salah satu contoh dokumentasi navbar yang umum digunakan.\n\n\n\n\nNavbar\n\n\n\nTable Pada class yang disediakan bootstrap terdapat beberapa pilihan tampilan table dan modifikasi yang diberikan, dengan memasukkan tag table ke dalam div yang diberikan kelas dari table yang diinginkan misalnya seperti berikut :\n\n\n\n\nTable\n\n\n\nButton Tombol merupakan bagian terpenting dalam suatu tampilan website yang dapat mengirimkan input dari pengguna ke server. Dalam bootstrap terdapat beberapa variasi yang diberikan untuk penggunaan tombol atau button misalnya warna, bentuk, style, rounded dan masih banyak lagi yang bisa didalami melalui dokumentasi yang ada pada halaman bootstrap\n\n\n\n\nButton\n\n\n\nCard Pada website blog atau e-commerce biasanya menampilkan artikel-artikel mereka pada card dapat menampilkan gambar, serta deskripsi atau tombol untuk melihat lebih banyak mengenai informasi dari blog tersebut. berikut adalah contoh penggunaan card:\n\n\n\n\nCard\n\n\n\n\n\n\n\n\n\n\nResponsive design menggunakan Bootstrap\n\n\n\nBerikut penjelasan mengenai penggunaan bootstrap dan elemen-elemen yang banyak digunakan!",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Playfair"
    ]
  },
  {
    "objectID": "4_playfair.html#implementasi-pada-python",
    "href": "4_playfair.html#implementasi-pada-python",
    "title": "4. Playfair",
    "section": "Implementasi Pada Python",
    "text": "Implementasi Pada Python\nMasukkan plaintext\nplainText = input(\"Plaintext : \")\nMasukkan kunci\nkey = input(\"masukkan kunci : \")\nMembersihkan teks dari spasi ganda\ncleanPlainTeks = plainTeks.replace(\" \", \"\")\nprint(cleanPlainTeks)\nDeklarasi urutan huruf dalam alfabet\nascii = {\n'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8, 'i': 9, 'j': 10, 'k': 11, \n'l': 12, 'm': 13, 'n': 14, 'o': 15, 'p': 16, 'q': 17, 'r': 18, 's': 19, 't': 20, 'u': 21, \n'v': 22, 'w': 23, 'x': 24, 'y': 25, 'z': 26\n}\n\nProses Enkripsi\nInisialisasi list untuk menyimpan urutan numerik dari setiap huruf alfabet\nkolom = 0\nangka_urutan = []\nMengonversi setiap huruf dalam kata kunci menjadi urutan numeriknya sesuai dengan posisi dalam alfabet\nfor huruf in key:\n    if huruf.isalpha():\n        angka_urutan.append(ascii[huruf.lower()])\n        kolom = kolom+1\n        cleanKey = angka_urutan\n\nprint(f\"Urutan kunci dari kata '{key}' adalah {angka_urutan}\")\nFor More Detail :\n\nfor huruf in key : Loop ini digunakan untuk memeriksa setiap huruf dalam variabel key, yang diharapkan merupakan kata kunci yang diberikan oleh pengguna\nif huruf.isalpha() : Kondisi ini memastikan bahwa hanya karakter alfabet yang akan diproses. Karakter non-alfabet akan dilewati\n`huruf.lower(): Mengubah huruf menjadi huruf kecil untuk konsistensi, sehingga tidak ada perbedaan antara huruf besar dan kecil\nascii[huruf.lower()] : Mengambil nilai urutan numerik dari huruf. Di sini diasumsikan ada sebuah kamus (dictionary) bernama ascii yang memetakan setiap huruf ke urutan numeriknya\nangka_urutan.append(...) : Menambahkan urutan numerik dari huruf ke dalam list angka_urutan\nkolom = kolom + 1 : Menghitung jumlah kolom dengan menambah nilai kolom setiap kali huruf diproses\ncleanKey = angka_urutan : Menyimpan hasil akhir urutan numerik ke dalam variabel cleanKey\n\nMembuat sebuah matriks kosong untuk menyimpan teks yang telah diolah dalam bentuk matriks\nmatrix = []\nMenghitung panjang dari teks yang telah dibersihkan dan disimpan dalam variabel cleanPlainTeks\npanjang = len(cleanPlainTeks)\nMencari tahu berapa kali kolom dapat digunakan untuk memuat seluruh teks, dengan membagi panjang teks dengan jumlah kolom\ntemp = panjang/kolom\nMembulatkan hasil pembagian sebelumnya ke bilangan bulat terdekat\nbulat = round(temp)\nMenghitung jumlah baris untuk memuat teks dalam matriks\nif temp - bulat == 0:\n    baris = bulat\nelse:\n    if temp - bulat &lt; 0:\n        baris = bulat\n    else:\n        baris = bulat + 1\nprint(baris)\nFor More Detail :\n\ntemp : hasil pembagian panjang teks dengan jumlah kolom\nbulat: hasil pembagian yang dibulatkan ke bilangan bulat terdekat. Jika temp adalah bilangan bulat (tidak ada sisa), jumlah baris adalah bulat. Jika ada sisa, jumlah baris adalah bulat + 1\n\nMengisi matriks dengan karakter dari teks yang telah dibersihkan (cleanPlainTeks)\nfor i in range(baris):\n    row = []\n    for j in range(kolom):\n        if i * kolom + j &lt; len(cleanPlainTeks):\n            elemen = cleanPlainTeks[i * kolom + j]\n        else:\n            elemen = \" \"\n        row.append(elemen)\n    matrix.append(row)\nFor More Detail :\n\nfor i in range(baris) : Loop untuk setiap baris dalam matriks\nrow = [] : Inisialisasi list kosong untuk setiap baris\nif i * kolom + j &lt; len(cleanPlainTeks) : Memeriksa apakah indeks saat ini berada dalam rentang panjang teks yang dibersihkan.\nelemen = cleanPlainTeks[i * kolom + j] : Jika indeks berada dalam rentang, maka ambil karakter dari cleanPlainTeks berdasarkan indeks yang dihitung.\nelse : Jika indeks melebihi panjang teks, isi elemen dengan spasi.\nrow.append(elemen) : Menambahkan elemen ke dalam baris.\nmatrix.append(row) : Menambahkan baris yang telah diisi ke dalam matriks.`\n\nMencetak matriks\nprint(\"Matriks yang Anda buat:\")\nfor row in matrix:\n    print(row)\nMentransposisikan matriks yang telah dibuat dan kemudian mencetak matriks yang telah ditransposisikan\ntransposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\nfor row in transposed_matrix:\n    print(row)\nFor More Detail :\n\nfor i in range(len(matrix[0])) : Iterasi melalui indeks kolom matriks asli\nrow[i] for row in matrix : Untuk setiap indeks kolom i, ambil elemen i dari setiap baris dalam matriks asli dan akan menghasilkan kolom baru dari elemen-elemen tersebut, membentuk baris baru di matriks yang ditransposisikan\n\nMembuat list kosong dengan panjang yang sama dengan cleanKey untuk menyimpan urutan indeks\norder = [None] * len(cleanKey)\nMengurutkan elemen-elemen dalam cleanKey berdasarkan nilai terkecil hingga terbesar\ni = 0\nwhile len(cleanKey) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, cleanKey))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = cleanKey.index(nilai_terkecil)\n\n        order[marker] = i\n        cleanKey[marker] = None \n        i = i + 1\n    else:\n        break\nprint(order)\nFor More Detail :\n\ni = 0 : Inisialisasi counter i\nwhile len(cleanKey) &gt; 0 : Loop hingga cleanKey kosong (semua elemen None)\nnon_none_values = list(filter(lambda x: x is not None, cleanKey)) : Membuat list yang hanya berisi elemen-elemen cleanKey yang bukan None\nif non_none_values : Mengecek apakah list non_none_values tidak kosong nilai_terkecil = min(non_none_values) : Mencari nilai terkecil dari non_none_values\nmarker = cleanKey.index(nilai_terkecil) : Mendapatkan indeks dari nilai terkecil dalam cleanKey Menyimpan Urutan dan Menghapus Nilai Terkecil:\norder[marker] = i : Menyimpan urutan i pada indeks marker di list order\ncleanKey[marker] = None : Menghapus nilai terkecil dari cleanKey dengan mengubahnya menjadi None\ni = i + 1 : Increment counter i.\n\nMengubah urutan kolom matriks transposed_matrix berdasarkan urutan yang telah diatur dalam order, dan kemudian mencetak matriks yang sudah diubah urutan kolomnya\nnew_matrix = []\nwhile len(order) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, order))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = order.index(nilai_terkecil)\n       \n        new_matrix.append(transposed_matrix[marker])\n        order[marker] = None\n    else:\n        break\n\nfor row in new_matrix:\n    print(row)\nFor More Detail :\n\nnew_matrix = [] : Membuat list kosong new_matrix untuk menampung baris-baris matriks yang baru diurutkan Looping untuk Mengubah Urutan Kolom:\nwhile len(order) &gt; 0 : Melakukan looping selama masih ada elemen yang tersisa dalam order\nnon_none_values = list(filter(lambda x: x is not None, order)) : Membuat list non_none_values yang hanya berisi nilai-nilai yang bukan None dari order\nif non_none_values : Memeriksa apakah non_none_values tidak kosong\nnilai_terkecil = min(non_none_values) : Menemukan nilai terkecil dari non_none_values\nmarker = order.index(nilai_terkecil) : Mencari indeks dari nilai_terkecil dalam order\nnew_matrix.append(transposed_matrix[marker]) : Menambahkan baris dari transposed_matrix yang sesuai dengan marker ke new_matrix\norder[marker] = None : Menghapus nilai yang telah diproses dengan mengubahnya menjadi None\nelse: break : Menghentikan loop jika non_none_values kosong, yang berarti semua nilai dalam order telah diproses\n\nMengonversi matriks new_matrix menjadi string tunggal dengan menggabungkan nilai-nilainya secara berurutan dan menghapus spasi ekstra di akhir string\nresult_string = \"\"\n\nfor row in new_matrix:\n    for value in row:\n        result_string += str(value)\n\nresult_string = result_string.strip()\n\nprint(result_string)\nFor More Detail :\n\nresult_string = \"\" : Inisialisasi string kosong result_string yang akan digunakan untuk menyimpan hasil akhir\nfor row in new_matrix: : Melakukan iterasi melalui setiap baris dalam new_matrix\nfor value in row: : Melakukan iterasi melalui setiap nilai dalam baris row\nresult_string += str(value) : Mengonversi nilai value menjadi string (jika belum string) dan menambahkannya ke result_string\nresult_string = result_string.strip() : Menghapus spasi ekstra di awal dan akhir string menggunakan metode strip()\n\nHasil Ciphertext : ENTKFINOKKM TIAIRA\n\n\nProses Dekripsi\ncipherTeks = input(\"masukkan kata : \")\nkey = input(\"masukkan kunci : \")\ncleanCipherTeks = cipherTeks.replace(\" \", \" \")\nprint(cleanCipherTeks)\nkolom = 0\nangka_urutan = []\nfor huruf in key:\n    if huruf.isalpha():\n        angka_urutan.append(ascii[huruf.lower()])\n        kolom = kolom+1\n        cleanKey = angka_urutan\n\nprint(f\"Urutan kunci dari kata '{key}' adalah: {angka_urutan}\")\nmatrix = []\npanjang = len(cleanCipherTeks)\ntemp = panjang/kolom\nbaris = round(temp)\nprint(baris)\nfor i in range(baris):\n    row = []\n    for j in range(kolom):\n        if i * kolom + j &lt; len(cleanCipherTeks):\n            elemen = cleanCipherTeks[i + baris * j]\n        else:\n            elemen = \"a\"\n        row.append(elemen)\n    matrix.append(row)\nprint(\"Matriks yang Anda buat:\")\nfor row in matrix:\n    print(row)\ntransposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\nfor row in transposed_matrix:\n    print(row)\norder = [None] * len(cleanKey)\ni = 0\nwhile len(cleanKey) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, cleanKey))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = cleanKey.index(nilai_terkecil)\n        order[marker] = i\n        cleanKey[marker] = None  \n        i = i + 1\n    else:\n        break\nprint(order)\ntransposed_matrix = [transposed_matrix[i] for i in order]\n\nfor row in transposed_matrix:\n    print(row)\nmatriks = [[row[i] for row in transposed_matrix] for i in range(len(transposed_matrix[0]))]\nfor row in matriks:\n    print(row)\nresult_string = \"\"\n\nfor row in matriks:\n    for value in row:\n        result_string += str(value)\n\nresult_string = result_string.strip()\n\nprint(result_string)\nHasil Dekripsi : TEKNIKINFORMATIKA\nPerbedaan Proses :\n\nEnkripsi: Teks asli diubah menjadi matriks berdasarkan kolom kunci, kemudian kolom-kolom diurutkan berdasarkan kunci. Pada enkripsi, transposed_matrix adalah matriks transposisi dari matrix awal\nDekripsi: Teks sandi diubah menjadi matriks berdasarkan kolom kunci, kemudian baris-baris diurutkan berdasarkan kunci untuk mengembalikan teks asli. Pada dekripsi, transposed_matrix diurutkan berdasarkan order untuk mengembalikan teks asli",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Playfair"
    ]
  }
]