[
  {
    "objectID": "2_monoalphabetic_random_key.html",
    "href": "2_monoalphabetic_random_key.html",
    "title": "2. Monoalphabetic Random Key",
    "section": "",
    "text": "Analogi Transposisi Kolom\nBayangkan Kita memiliki rak buku dengan beberapa kolom dan setiap kolom berisi tumpukan buku.\nDengan kata lain, transposisi kolom mengubah urutan kolom tanpa mengubah isi kolom. Dalam kriptografi, ini dilakukan untuk mengacak data agar lebih sulit ditebak oleh pihak yang tidak berwenang.",
    "crumbs": [
      "Kriptografi Klasik",
      "2. Monoalphabetic Random Key"
    ]
  },
  {
    "objectID": "2_monoalphabetic_random_key.html#implementasi-pada-python",
    "href": "2_monoalphabetic_random_key.html#implementasi-pada-python",
    "title": "2. Monoalphabetic Random Key",
    "section": "Implementasi Pada Python",
    "text": "Implementasi Pada Python\nMasukkan plaintext\nplainText = input(\"Plaintext : \")\nMasukkan kunci\nkey = input(\"masukkan kunci : \")\nMembersihkan teks dari spasi ganda\ncleanPlainTeks = plainTeks.replace(\" \", \"\")\nprint(cleanPlainTeks)\nDeklarasi urutan huruf dalam alfabet\nascii = {\n'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8, 'i': 9, 'j': 10, 'k': 11, \n'l': 12, 'm': 13, 'n': 14, 'o': 15, 'p': 16, 'q': 17, 'r': 18, 's': 19, 't': 20, 'u': 21, \n'v': 22, 'w': 23, 'x': 24, 'y': 25, 'z': 26\n}\n\nProses Enkripsi\nInisialisasi list untuk menyimpan urutan numerik dari setiap huruf alfabet\nkolom = 0\nangka_urutan = []\nMengonversi setiap huruf dalam kata kunci menjadi urutan numeriknya sesuai dengan posisi dalam alfabet\nfor huruf in key:\n    if huruf.isalpha():\n        angka_urutan.append(ascii[huruf.lower()])\n        kolom = kolom+1\n        cleanKey = angka_urutan\n\nprint(f\"Urutan kunci dari kata '{key}' adalah {angka_urutan}\")\nFor More Detail :\n\nfor huruf in key : Loop ini digunakan untuk memeriksa setiap huruf dalam variabel key, yang diharapkan merupakan kata kunci yang diberikan oleh pengguna\nif huruf.isalpha() : Kondisi ini memastikan bahwa hanya karakter alfabet yang akan diproses. Karakter non-alfabet akan dilewati\n`huruf.lower(): Mengubah huruf menjadi huruf kecil untuk konsistensi, sehingga tidak ada perbedaan antara huruf besar dan kecil\nascii[huruf.lower()] : Mengambil nilai urutan numerik dari huruf. Di sini diasumsikan ada sebuah kamus (dictionary) bernama ascii yang memetakan setiap huruf ke urutan numeriknya\nangka_urutan.append(...) : Menambahkan urutan numerik dari huruf ke dalam list angka_urutan\nkolom = kolom + 1 : Menghitung jumlah kolom dengan menambah nilai kolom setiap kali huruf diproses\ncleanKey = angka_urutan : Menyimpan hasil akhir urutan numerik ke dalam variabel cleanKey\n\nMembuat sebuah matriks kosong untuk menyimpan teks yang telah diolah dalam bentuk matriks\nmatrix = []\nMenghitung panjang dari teks yang telah dibersihkan dan disimpan dalam variabel cleanPlainTeks\npanjang = len(cleanPlainTeks)\nMencari tahu berapa kali kolom dapat digunakan untuk memuat seluruh teks, dengan membagi panjang teks dengan jumlah kolom\ntemp = panjang/kolom\nMembulatkan hasil pembagian sebelumnya ke bilangan bulat terdekat\nbulat = round(temp)\nMenghitung jumlah baris untuk memuat teks dalam matriks\nif temp - bulat == 0:\n    baris = bulat\nelse:\n    if temp - bulat &lt; 0:\n        baris = bulat\n    else:\n        baris = bulat + 1\nprint(baris)\nFor More Detail :\n\ntemp : hasil pembagian panjang teks dengan jumlah kolom\nbulat: hasil pembagian yang dibulatkan ke bilangan bulat terdekat. Jika temp adalah bilangan bulat (tidak ada sisa), jumlah baris adalah bulat. Jika ada sisa, jumlah baris adalah bulat + 1\n\nMengisi matriks dengan karakter dari teks yang telah dibersihkan (cleanPlainTeks)\nfor i in range(baris):\n    row = []\n    for j in range(kolom):\n        if i * kolom + j &lt; len(cleanPlainTeks):\n            elemen = cleanPlainTeks[i * kolom + j]\n        else:\n            elemen = \" \"\n        row.append(elemen)\n    matrix.append(row)\nFor More Detail :\n\nfor i in range(baris) : Loop untuk setiap baris dalam matriks\nrow = [] : Inisialisasi list kosong untuk setiap baris\nif i * kolom + j &lt; len(cleanPlainTeks) : Memeriksa apakah indeks saat ini berada dalam rentang panjang teks yang dibersihkan.\nelemen = cleanPlainTeks[i * kolom + j] : Jika indeks berada dalam rentang, maka ambil karakter dari cleanPlainTeks berdasarkan indeks yang dihitung.\nelse : Jika indeks melebihi panjang teks, isi elemen dengan spasi.\nrow.append(elemen) : Menambahkan elemen ke dalam baris.\nmatrix.append(row) : Menambahkan baris yang telah diisi ke dalam matriks.`\n\nMencetak matriks\nprint(\"Matriks yang Anda buat:\")\nfor row in matrix:\n    print(row)\nMentransposisikan matriks yang telah dibuat dan kemudian mencetak matriks yang telah ditransposisikan\ntransposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\nfor row in transposed_matrix:\n    print(row)\nFor More Detail :\n\nfor i in range(len(matrix[0])) : Iterasi melalui indeks kolom matriks asli\nrow[i] for row in matrix : Untuk setiap indeks kolom i, ambil elemen i dari setiap baris dalam matriks asli dan akan menghasilkan kolom baru dari elemen-elemen tersebut, membentuk baris baru di matriks yang ditransposisikan\n\nMembuat list kosong dengan panjang yang sama dengan cleanKey untuk menyimpan urutan indeks\norder = [None] * len(cleanKey)\nMengurutkan elemen-elemen dalam cleanKey berdasarkan nilai terkecil hingga terbesar\ni = 0\nwhile len(cleanKey) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, cleanKey))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = cleanKey.index(nilai_terkecil)\n\n        order[marker] = i\n        cleanKey[marker] = None \n        i = i + 1\n    else:\n        break\nprint(order)\nFor More Detail :\n\ni = 0 : Inisialisasi counter i\nwhile len(cleanKey) &gt; 0 : Loop hingga cleanKey kosong (semua elemen None)\nnon_none_values = list(filter(lambda x: x is not None, cleanKey)) : Membuat list yang hanya berisi elemen-elemen cleanKey yang bukan None\nif non_none_values : Mengecek apakah list non_none_values tidak kosong nilai_terkecil = min(non_none_values) : Mencari nilai terkecil dari non_none_values\nmarker = cleanKey.index(nilai_terkecil) : Mendapatkan indeks dari nilai terkecil dalam cleanKey Menyimpan Urutan dan Menghapus Nilai Terkecil:\norder[marker] = i : Menyimpan urutan i pada indeks marker di list order\ncleanKey[marker] = None : Menghapus nilai terkecil dari cleanKey dengan mengubahnya menjadi None\ni = i + 1 : Increment counter i.\n\nMengubah urutan kolom matriks transposed_matrix berdasarkan urutan yang telah diatur dalam order, dan kemudian mencetak matriks yang sudah diubah urutan kolomnya\nnew_matrix = []\nwhile len(order) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, order))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = order.index(nilai_terkecil)\n       \n        new_matrix.append(transposed_matrix[marker])\n        order[marker] = None\n    else:\n        break\n\nfor row in new_matrix:\n    print(row)\nFor More Detail :\n\nnew_matrix = [] : Membuat list kosong new_matrix untuk menampung baris-baris matriks yang baru diurutkan Looping untuk Mengubah Urutan Kolom:\nwhile len(order) &gt; 0 : Melakukan looping selama masih ada elemen yang tersisa dalam order\nnon_none_values = list(filter(lambda x: x is not None, order)) : Membuat list non_none_values yang hanya berisi nilai-nilai yang bukan None dari order\nif non_none_values : Memeriksa apakah non_none_values tidak kosong\nnilai_terkecil = min(non_none_values) : Menemukan nilai terkecil dari non_none_values\nmarker = order.index(nilai_terkecil) : Mencari indeks dari nilai_terkecil dalam order\nnew_matrix.append(transposed_matrix[marker]) : Menambahkan baris dari transposed_matrix yang sesuai dengan marker ke new_matrix\norder[marker] = None : Menghapus nilai yang telah diproses dengan mengubahnya menjadi None\nelse: break : Menghentikan loop jika non_none_values kosong, yang berarti semua nilai dalam order telah diproses\n\nMengonversi matriks new_matrix menjadi string tunggal dengan menggabungkan nilai-nilainya secara berurutan dan menghapus spasi ekstra di akhir string\nresult_string = \"\"\n\nfor row in new_matrix:\n    for value in row:\n        result_string += str(value)\n\nresult_string = result_string.strip()\n\nprint(result_string)\nFor More Detail :\n\nresult_string = \"\" : Inisialisasi string kosong result_string yang akan digunakan untuk menyimpan hasil akhir\nfor row in new_matrix: : Melakukan iterasi melalui setiap baris dalam new_matrix\nfor value in row: : Melakukan iterasi melalui setiap nilai dalam baris row\nresult_string += str(value) : Mengonversi nilai value menjadi string (jika belum string) dan menambahkannya ke result_string\nresult_string = result_string.strip() : Menghapus spasi ekstra di awal dan akhir string menggunakan metode strip()\n\nHasil Ciphertext : ENTKFINOKKM TIAIRA\n\n\nProses Dekripsi\ncipherTeks = input(\"masukkan kata : \")\nkey = input(\"masukkan kunci : \")\ncleanCipherTeks = cipherTeks.replace(\" \", \" \")\nprint(cleanCipherTeks)\nkolom = 0\nangka_urutan = []\nfor huruf in key:\n    if huruf.isalpha():\n        angka_urutan.append(ascii[huruf.lower()])\n        kolom = kolom+1\n        cleanKey = angka_urutan\n\nprint(f\"Urutan kunci dari kata '{key}' adalah: {angka_urutan}\")\nmatrix = []\npanjang = len(cleanCipherTeks)\ntemp = panjang/kolom\nbaris = round(temp)\nprint(baris)\nfor i in range(baris):\n    row = []\n    for j in range(kolom):\n        if i * kolom + j &lt; len(cleanCipherTeks):\n            elemen = cleanCipherTeks[i + baris * j]\n        else:\n            elemen = \"a\"\n        row.append(elemen)\n    matrix.append(row)\nprint(\"Matriks yang Anda buat:\")\nfor row in matrix:\n    print(row)\ntransposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\nfor row in transposed_matrix:\n    print(row)\norder = [None] * len(cleanKey)\ni = 0\nwhile len(cleanKey) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, cleanKey))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = cleanKey.index(nilai_terkecil)\n        order[marker] = i\n        cleanKey[marker] = None  \n        i = i + 1\n    else:\n        break\nprint(order)\ntransposed_matrix = [transposed_matrix[i] for i in order]\n\nfor row in transposed_matrix:\n    print(row)\nmatriks = [[row[i] for row in transposed_matrix] for i in range(len(transposed_matrix[0]))]\nfor row in matriks:\n    print(row)\nresult_string = \"\"\n\nfor row in matriks:\n    for value in row:\n        result_string += str(value)\n\nresult_string = result_string.strip()\n\nprint(result_string)\nHasil Dekripsi : TEKNIKINFORMATIKA\nPerbedaan Proses :\n\nEnkripsi: Teks asli diubah menjadi matriks berdasarkan kolom kunci, kemudian kolom-kolom diurutkan berdasarkan kunci. Pada enkripsi, transposed_matrix adalah matriks transposisi dari matrix awal\nDekripsi: Teks sandi diubah menjadi matriks berdasarkan kolom kunci, kemudian baris-baris diurutkan berdasarkan kunci untuk mengembalikan teks asli. Pada dekripsi, transposed_matrix diurutkan berdasarkan order untuk mengembalikan teks asli",
    "crumbs": [
      "Kriptografi Klasik",
      "2. Monoalphabetic Random Key"
    ]
  },
  {
    "objectID": "4_playfair.html",
    "href": "4_playfair.html",
    "title": "4. Playfair",
    "section": "",
    "text": "Analogi Transposisi Kolom\nBayangkan Kita memiliki rak buku dengan beberapa kolom dan setiap kolom berisi tumpukan buku.\nDengan kata lain, transposisi kolom mengubah urutan kolom tanpa mengubah isi kolom. Dalam kriptografi, ini dilakukan untuk mengacak data agar lebih sulit ditebak oleh pihak yang tidak berwenang.",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Playfair"
    ]
  },
  {
    "objectID": "4_playfair.html#pengenalan-responsive-web-design",
    "href": "4_playfair.html#pengenalan-responsive-web-design",
    "title": "4. Playfair",
    "section": "",
    "text": "Responsive Web\n\n\n\n\n&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n\n\n\n\n&lt;img src=\"images.jpg\" style=\"width:100%;\"&gt;\n\n\n&lt;h1 style=\"font-size:10vw\"&gt;Hello World&lt;/h1&gt;",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Playfair"
    ]
  },
  {
    "objectID": "4_playfair.html#responsive-web-design-framework-bootstrap",
    "href": "4_playfair.html#responsive-web-design-framework-bootstrap",
    "title": "4. Playfair",
    "section": "Responsive Web Design Framework (Bootstrap)",
    "text": "Responsive Web Design Framework (Bootstrap)\nBootstrap merupakan HTML, CSS dan Javascript framework paling popular untuk mengambangkan responsive web design yang mengutamakan tampilan mobile (mobile first) Bootstrap dapat diunduh secara gratis pada laman https://getbootstrap.com/. Sampai saat modul ini dibuat versi terakhir adalah Bootstrap v5.3.\n\nMengapa menggunakan Bootstrap?\nBanyak keuntungan dan kemudahan yang diberikan Bootstrap diantaranya adalah: \nBerikut adalah beberapa penjelasan mengenai Bootstrap: \n\nResponsif: Salah satu fitur utama Bootstrap adalah kemampuannya untuk menghasilkan tampilan yang responsif secara otomatis. Dengan menggunakan class CSS yang telah disediakan oleh Bootstrap, elemen-elemen halaman web dapat menyesuaikan diri dengan baik pada berbagai perangkat dan ukuran layar, mulai dari desktop hingga perangkat mobile.\nGrid System: Bootstrap menyediakan sistem grid yang fleksibel untuk membagi layout halaman web menjadi kolom-kolom yang responsif. Grid system ini memungkinkan pengaturan layout yang mudah dan dapat diatur untuk menciptakan tampilan yang rapi dan terstruktur pada berbagai perangkat.\nKomponen Siap Pakai: Bootstrap menyediakan beragam komponen UI siap pakai seperti tombol, navigasi, formulir, jumbotron, kartu, jendela modal, dan banyak lagi. Komponen ini telah dirancang dengan baik dan dapat langsung digunakan dalam proyek tanpa perlu memikirkan desain atau gaya dasar, menghemat waktu dan usaha pengembangan.\nGaya dan Tema: Bootstrap memiliki gaya dan tema default yang estetis dan modern. Selain itu, Bootstrap juga menyediakan beragam tema kustom yang dapat diterapkan dengan mudah untuk memberikan tampilan yang unik dan sesuai dengan kebutuhan proyek Anda. Anda juga dapat menyesuaikan gaya dan tema Bootstrap sesuai dengan preferensi Anda sendiri.\nKompatibilitas Browser: Bootstrap dirancang untuk mendukung sebagian besar browser modern. Ini berarti tampilan dan fungsionalitas situs web yang dibangun dengan menggunakan Bootstrap akan konsisten dan berfungsi dengan baik di berbagai browser yang umum digunakan.\nDokumentasi dan Komunitas: Bootstrap memiliki dokumentasi yang sangat baik, lengkap dengan contoh-contoh kode dan penjelasan yang rinci. Selain itu, karena popularitasnya, Bootstrap memiliki komunitas pengembang yang besar dan aktif, yang dapat memberikan dukungan dan sumber daya yang berguna untuk menjawab pertanyaan, memecahkan masalah, dan berbagi pengalaman.\n\n\n\n\nHTML5\nPenambahan doctype dilakukan untuk menetapkan dokumen HTML sebagai HTML versi 5 (HTML5), agar dapat menggunakan elemen-elemen HTML5 dan properti CSS Bootstrap. Sebagai contohnya pada script berikut. \n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\n&lt;/html&gt;\n\nJika menggunakan Text Editor Visual Studio Code, ketika mengetikan html di awal kode maka akan muncul snippets yang memunculkan beberapa pilihan template kode \n\n\n\nSnippets\n\n\n\n\nGrid System\nPada Bootstrap menerapkan grid system dengan 12 (dua belas) kolom pada setiap halaman. Jika kita tidak menginginkan layout menggunakan ke-12 kolom, kita bisa mengelompokkan kolom bersama untuk membuat kolom yang lebih lebar. Sebagai contoh gambaran dari grid system dengan 12 kolom ditampilkan seperti pada gambar di bawah ini. \n\n\n\nContoh Grid System Bootstrap\n\n\n Sistem grid pada bootstrap dapat menyesuaikan terhadap enam keadaan atau ukuran diantaranya adalah : \n\nEkstra kecil atau extra small (xs)\nKecil atau small (sm)\nSedang atau medium (md)\nBesar atau large (lg)\nEkstra besar atau extra large (xl)\nEkstra ekstra besar atau extra extra large (xxl) \n\n\n\n\nTabel Breakpoint Grid\n\n\n\n\nFungsi Bootsrtap yang umum digunakan\n\nGrid  Seperti yang telah dijelaskan pada Grid System, bahwa pada bootstrap dapat mengelompokkan layout menjadi 12 kolom, dimana kita dapat menggunakan grid ini dengan kelas row yang didalamnya terdapat kelas col, seperti berikut:\n&lt;div class=\"row\"&gt;\n    &lt;div class=\"col\"&gt;&lt;/div&gt;\n    ...\n&lt;/div&gt;&lt;!-- row--&gt;\n Dalam kelas col ini dapat dituliskan dengan value seperti col-4, yang artinya objek yang diberikan kelas tersebut pada row atau baris akan mengisi sebanyak 4 kolom. Dalam 1 row tersebut dapat berisi dengan akumulai 12 kolom.  Selain iitu juga bisa dikombinasikan dengan class breakpoint. Pada seperti yang dijelaskan pada tabel penjelasan grid system bahwa kolom akan mengikuti ukuran breakppoint dari device yang dimasukkan. Misalkan col-md-4, maka ketika ukuran dari device yang digunakan lebih besar dari atau sama dengan 768px maka tampilan kolom akan mendatar memenuhi row, namun akan berubah tampilannya jika ukuran devicenya berkurang 1 pixel saja (kurang dari 768px).\nWarna  Terdapat beberapa template kelas warna yang disediakan oleh Bootstrap diantaranya \n\nPrimary: (Biru tua)\nSecondary: (Abu-abu)\nSuccess: (Hijau)\nDanger: (Merah)\nWarning: (Kuning)\nInfo: (Biru cerah)\nLight: (Putih atau hampir putih)\nDark: (Hitam atau hampir hitam) \n\nPemilihan warna juga merupakan hal yang sangat penting dan perlu diperhatikan.Pemilihan warna akan sangat berpengaruh pada tampilan atau UI sehingga akan mempercantik tampilan dan menarik bagi user. Selain itu dengan warna yang sesuai akan membantu menyampaikan fungsi dari fitur, misalnya merah menandakan suatu yang penting yang memerlukan perhatian lebih, hal tersebut akan memudahkan konsumen dalam menggunakan aplikasi atau disebut user experience\nTypografi  Dalam cara penulisan pada bootstrap memberikan kemudahan dalam mengatur tampilan teks, melalui beberapa class, seperti \n\nHeading, selain menggunakan tag &lt;h1&gt;,&lt;h2&gt;,..,&lt;h6&gt; pada bootstrap juga terdapat kelas heading contohnya:\n&lt;p class=\"h1\"&gt;Heading 1&lt;p&gt;\nDisplay, dengan manambahkan class display pada teks akan memberikan tampilan teks yang besar namun dengan style font yang tipis, misalnya: \n&lt;p class=\"display-1\"&gt;Display 1&lt;/p&gt;\nFont Size, class font size atau yang ditulis fs memberikan styling berupa ukuran dari teks dimana semakin besar nilai fs akan semakin kecil font yang ditampilkan: \n&lt;p class=\"fs-1\"&gt;ini teks&lt;/p&gt;\nFont Weight, melalui font weight dapat memberikan pengaturan terhadap tebal tipis dari font atau teks, dengan parameter bolder, bold, light, lighter, dan normal, berikut contoh penggunaannya: \n&lt;p class=\"fw-bold\"&gt;Ini tebal&lt;/p&gt;\nFont Style, dengan font style kita dapat merubah style dari font atau teks bold dan italic tanpa menggunakan tag html &lt;b&gt; dan &lt;i&gt;, atau sebagai berikut: \n&lt;p class=\"fst-italic\"&gt;ini font style&lt;/p&gt;\n&lt;p class=\"fst-normal\"&gt;ini font style&lt;/p&gt;\n\nSpacing & Sizing \nPengaturan Spasi dan ukuran pada Bootstrap dapat menggunakan padding dan margin, Padding merupakan bagian yang membatasi konten dengan border, sedangkan margin merupakkan bagian yang membatasi antara border dengan bagian luar dari konten. Pengaturan margin dan padding dapat dilakukan dengan mudah hanya dengan menambahkan class m untuk margin dan p untuk padding yang diikuti dengan parameter t (top), b (bottom), s (start), e (end), x (menambahkan pada kedua sis horizontal), y (menambahkan pada kedua sisi vertikal), serta diikuti oleh besar margin atau padding yang diinginkan dengan nilai mulai dari 1 hingga 5, atau seperti berikut:\n ```html\n &lt;!-- Heading --&gt;\n &lt;div class=\"item mt-5 mb-3\"&gt;item1&lt;/div&gt;\n &lt;div class=\"item ms-2 me-3\"&gt;item2&lt;/div&gt;\n &lt;div class=\"item my-5\"&gt;item3&lt;/div&gt;\n &lt;div class=\"item mx-3\"&gt;item4&lt;/div&gt;\n &lt;div class=\"item m-3\"&gt;item4&lt;/div&gt;\n\n &lt;!-- Padding --&gt;\n &lt;div class=\"item pt-5 pb-3\"&gt;item1&lt;/div&gt;\n &lt;div class=\"item ps-2 pe-3\"&gt;item2&lt;/div&gt;\n &lt;div class=\"item py-5\"&gt;item3&lt;/div&gt;\n &lt;div class=\"item px-3\"&gt;item4&lt;/div&gt;\n &lt;div class=\"item p-3\"&gt;item4&lt;/div&gt;\n ```\n\n\n\n\nMargin-Padding-Border\n\n\n\n\n\nKomponen yang umum digunakan\n\nNavbar Navbar pada bootstrap sudah memiliki kemampuan untuk responsif ketika ukuran dari perangkat yang digunakan terlalu kecil untuk menampilkan konten atau menu didalamnya akan otomatis menjadi humberger menu, berikut salah satu contoh dokumentasi navbar yang umum digunakan.\n\n\n\n\nNavbar\n\n\n\nTable Pada class yang disediakan bootstrap terdapat beberapa pilihan tampilan table dan modifikasi yang diberikan, dengan memasukkan tag table ke dalam div yang diberikan kelas dari table yang diinginkan misalnya seperti berikut :\n\n\n\n\nTable\n\n\n\nButton Tombol merupakan bagian terpenting dalam suatu tampilan website yang dapat mengirimkan input dari pengguna ke server. Dalam bootstrap terdapat beberapa variasi yang diberikan untuk penggunaan tombol atau button misalnya warna, bentuk, style, rounded dan masih banyak lagi yang bisa didalami melalui dokumentasi yang ada pada halaman bootstrap\n\n\n\n\nButton\n\n\n\nCard Pada website blog atau e-commerce biasanya menampilkan artikel-artikel mereka pada card dapat menampilkan gambar, serta deskripsi atau tombol untuk melihat lebih banyak mengenai informasi dari blog tersebut. berikut adalah contoh penggunaan card:\n\n\n\n\nCard\n\n\n\n\n\n\n\n\n\n\nResponsive design menggunakan Bootstrap\n\n\n\nBerikut penjelasan mengenai penggunaan bootstrap dan elemen-elemen yang banyak digunakan!",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Playfair"
    ]
  },
  {
    "objectID": "4_playfair.html#implementasi-pada-python",
    "href": "4_playfair.html#implementasi-pada-python",
    "title": "4. Playfair",
    "section": "Implementasi Pada Python",
    "text": "Implementasi Pada Python\nMasukkan plaintext\nplainText = input(\"Plaintext : \")\nMasukkan kunci\nkey = input(\"masukkan kunci : \")\nMembersihkan teks dari spasi ganda\ncleanPlainTeks = plainTeks.replace(\" \", \"\")\nprint(cleanPlainTeks)\nDeklarasi urutan huruf dalam alfabet\nascii = {\n'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8, 'i': 9, 'j': 10, 'k': 11, \n'l': 12, 'm': 13, 'n': 14, 'o': 15, 'p': 16, 'q': 17, 'r': 18, 's': 19, 't': 20, 'u': 21, \n'v': 22, 'w': 23, 'x': 24, 'y': 25, 'z': 26\n}\n\nProses Enkripsi\nInisialisasi list untuk menyimpan urutan numerik dari setiap huruf alfabet\nkolom = 0\nangka_urutan = []\nMengonversi setiap huruf dalam kata kunci menjadi urutan numeriknya sesuai dengan posisi dalam alfabet\nfor huruf in key:\n    if huruf.isalpha():\n        angka_urutan.append(ascii[huruf.lower()])\n        kolom = kolom+1\n        cleanKey = angka_urutan\n\nprint(f\"Urutan kunci dari kata '{key}' adalah {angka_urutan}\")\nFor More Detail :\n\nfor huruf in key : Loop ini digunakan untuk memeriksa setiap huruf dalam variabel key, yang diharapkan merupakan kata kunci yang diberikan oleh pengguna\nif huruf.isalpha() : Kondisi ini memastikan bahwa hanya karakter alfabet yang akan diproses. Karakter non-alfabet akan dilewati\n`huruf.lower(): Mengubah huruf menjadi huruf kecil untuk konsistensi, sehingga tidak ada perbedaan antara huruf besar dan kecil\nascii[huruf.lower()] : Mengambil nilai urutan numerik dari huruf. Di sini diasumsikan ada sebuah kamus (dictionary) bernama ascii yang memetakan setiap huruf ke urutan numeriknya\nangka_urutan.append(...) : Menambahkan urutan numerik dari huruf ke dalam list angka_urutan\nkolom = kolom + 1 : Menghitung jumlah kolom dengan menambah nilai kolom setiap kali huruf diproses\ncleanKey = angka_urutan : Menyimpan hasil akhir urutan numerik ke dalam variabel cleanKey\n\nMembuat sebuah matriks kosong untuk menyimpan teks yang telah diolah dalam bentuk matriks\nmatrix = []\nMenghitung panjang dari teks yang telah dibersihkan dan disimpan dalam variabel cleanPlainTeks\npanjang = len(cleanPlainTeks)\nMencari tahu berapa kali kolom dapat digunakan untuk memuat seluruh teks, dengan membagi panjang teks dengan jumlah kolom\ntemp = panjang/kolom\nMembulatkan hasil pembagian sebelumnya ke bilangan bulat terdekat\nbulat = round(temp)\nMenghitung jumlah baris untuk memuat teks dalam matriks\nif temp - bulat == 0:\n    baris = bulat\nelse:\n    if temp - bulat &lt; 0:\n        baris = bulat\n    else:\n        baris = bulat + 1\nprint(baris)\nFor More Detail :\n\ntemp : hasil pembagian panjang teks dengan jumlah kolom\nbulat: hasil pembagian yang dibulatkan ke bilangan bulat terdekat. Jika temp adalah bilangan bulat (tidak ada sisa), jumlah baris adalah bulat. Jika ada sisa, jumlah baris adalah bulat + 1\n\nMengisi matriks dengan karakter dari teks yang telah dibersihkan (cleanPlainTeks)\nfor i in range(baris):\n    row = []\n    for j in range(kolom):\n        if i * kolom + j &lt; len(cleanPlainTeks):\n            elemen = cleanPlainTeks[i * kolom + j]\n        else:\n            elemen = \" \"\n        row.append(elemen)\n    matrix.append(row)\nFor More Detail :\n\nfor i in range(baris) : Loop untuk setiap baris dalam matriks\nrow = [] : Inisialisasi list kosong untuk setiap baris\nif i * kolom + j &lt; len(cleanPlainTeks) : Memeriksa apakah indeks saat ini berada dalam rentang panjang teks yang dibersihkan.\nelemen = cleanPlainTeks[i * kolom + j] : Jika indeks berada dalam rentang, maka ambil karakter dari cleanPlainTeks berdasarkan indeks yang dihitung.\nelse : Jika indeks melebihi panjang teks, isi elemen dengan spasi.\nrow.append(elemen) : Menambahkan elemen ke dalam baris.\nmatrix.append(row) : Menambahkan baris yang telah diisi ke dalam matriks.`\n\nMencetak matriks\nprint(\"Matriks yang Anda buat:\")\nfor row in matrix:\n    print(row)\nMentransposisikan matriks yang telah dibuat dan kemudian mencetak matriks yang telah ditransposisikan\ntransposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\nfor row in transposed_matrix:\n    print(row)\nFor More Detail :\n\nfor i in range(len(matrix[0])) : Iterasi melalui indeks kolom matriks asli\nrow[i] for row in matrix : Untuk setiap indeks kolom i, ambil elemen i dari setiap baris dalam matriks asli dan akan menghasilkan kolom baru dari elemen-elemen tersebut, membentuk baris baru di matriks yang ditransposisikan\n\nMembuat list kosong dengan panjang yang sama dengan cleanKey untuk menyimpan urutan indeks\norder = [None] * len(cleanKey)\nMengurutkan elemen-elemen dalam cleanKey berdasarkan nilai terkecil hingga terbesar\ni = 0\nwhile len(cleanKey) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, cleanKey))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = cleanKey.index(nilai_terkecil)\n\n        order[marker] = i\n        cleanKey[marker] = None \n        i = i + 1\n    else:\n        break\nprint(order)\nFor More Detail :\n\ni = 0 : Inisialisasi counter i\nwhile len(cleanKey) &gt; 0 : Loop hingga cleanKey kosong (semua elemen None)\nnon_none_values = list(filter(lambda x: x is not None, cleanKey)) : Membuat list yang hanya berisi elemen-elemen cleanKey yang bukan None\nif non_none_values : Mengecek apakah list non_none_values tidak kosong nilai_terkecil = min(non_none_values) : Mencari nilai terkecil dari non_none_values\nmarker = cleanKey.index(nilai_terkecil) : Mendapatkan indeks dari nilai terkecil dalam cleanKey Menyimpan Urutan dan Menghapus Nilai Terkecil:\norder[marker] = i : Menyimpan urutan i pada indeks marker di list order\ncleanKey[marker] = None : Menghapus nilai terkecil dari cleanKey dengan mengubahnya menjadi None\ni = i + 1 : Increment counter i.\n\nMengubah urutan kolom matriks transposed_matrix berdasarkan urutan yang telah diatur dalam order, dan kemudian mencetak matriks yang sudah diubah urutan kolomnya\nnew_matrix = []\nwhile len(order) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, order))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = order.index(nilai_terkecil)\n       \n        new_matrix.append(transposed_matrix[marker])\n        order[marker] = None\n    else:\n        break\n\nfor row in new_matrix:\n    print(row)\nFor More Detail :\n\nnew_matrix = [] : Membuat list kosong new_matrix untuk menampung baris-baris matriks yang baru diurutkan Looping untuk Mengubah Urutan Kolom:\nwhile len(order) &gt; 0 : Melakukan looping selama masih ada elemen yang tersisa dalam order\nnon_none_values = list(filter(lambda x: x is not None, order)) : Membuat list non_none_values yang hanya berisi nilai-nilai yang bukan None dari order\nif non_none_values : Memeriksa apakah non_none_values tidak kosong\nnilai_terkecil = min(non_none_values) : Menemukan nilai terkecil dari non_none_values\nmarker = order.index(nilai_terkecil) : Mencari indeks dari nilai_terkecil dalam order\nnew_matrix.append(transposed_matrix[marker]) : Menambahkan baris dari transposed_matrix yang sesuai dengan marker ke new_matrix\norder[marker] = None : Menghapus nilai yang telah diproses dengan mengubahnya menjadi None\nelse: break : Menghentikan loop jika non_none_values kosong, yang berarti semua nilai dalam order telah diproses\n\nMengonversi matriks new_matrix menjadi string tunggal dengan menggabungkan nilai-nilainya secara berurutan dan menghapus spasi ekstra di akhir string\nresult_string = \"\"\n\nfor row in new_matrix:\n    for value in row:\n        result_string += str(value)\n\nresult_string = result_string.strip()\n\nprint(result_string)\nFor More Detail :\n\nresult_string = \"\" : Inisialisasi string kosong result_string yang akan digunakan untuk menyimpan hasil akhir\nfor row in new_matrix: : Melakukan iterasi melalui setiap baris dalam new_matrix\nfor value in row: : Melakukan iterasi melalui setiap nilai dalam baris row\nresult_string += str(value) : Mengonversi nilai value menjadi string (jika belum string) dan menambahkannya ke result_string\nresult_string = result_string.strip() : Menghapus spasi ekstra di awal dan akhir string menggunakan metode strip()\n\nHasil Ciphertext : ENTKFINOKKM TIAIRA\n\n\nProses Dekripsi\ncipherTeks = input(\"masukkan kata : \")\nkey = input(\"masukkan kunci : \")\ncleanCipherTeks = cipherTeks.replace(\" \", \" \")\nprint(cleanCipherTeks)\nkolom = 0\nangka_urutan = []\nfor huruf in key:\n    if huruf.isalpha():\n        angka_urutan.append(ascii[huruf.lower()])\n        kolom = kolom+1\n        cleanKey = angka_urutan\n\nprint(f\"Urutan kunci dari kata '{key}' adalah: {angka_urutan}\")\nmatrix = []\npanjang = len(cleanCipherTeks)\ntemp = panjang/kolom\nbaris = round(temp)\nprint(baris)\nfor i in range(baris):\n    row = []\n    for j in range(kolom):\n        if i * kolom + j &lt; len(cleanCipherTeks):\n            elemen = cleanCipherTeks[i + baris * j]\n        else:\n            elemen = \"a\"\n        row.append(elemen)\n    matrix.append(row)\nprint(\"Matriks yang Anda buat:\")\nfor row in matrix:\n    print(row)\ntransposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\nfor row in transposed_matrix:\n    print(row)\norder = [None] * len(cleanKey)\ni = 0\nwhile len(cleanKey) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, cleanKey))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = cleanKey.index(nilai_terkecil)\n        order[marker] = i\n        cleanKey[marker] = None  \n        i = i + 1\n    else:\n        break\nprint(order)\ntransposed_matrix = [transposed_matrix[i] for i in order]\n\nfor row in transposed_matrix:\n    print(row)\nmatriks = [[row[i] for row in transposed_matrix] for i in range(len(transposed_matrix[0]))]\nfor row in matriks:\n    print(row)\nresult_string = \"\"\n\nfor row in matriks:\n    for value in row:\n        result_string += str(value)\n\nresult_string = result_string.strip()\n\nprint(result_string)\nHasil Dekripsi : TEKNIKINFORMATIKA\nPerbedaan Proses :\n\nEnkripsi: Teks asli diubah menjadi matriks berdasarkan kolom kunci, kemudian kolom-kolom diurutkan berdasarkan kunci. Pada enkripsi, transposed_matrix adalah matriks transposisi dari matrix awal\nDekripsi: Teks sandi diubah menjadi matriks berdasarkan kolom kunci, kemudian baris-baris diurutkan berdasarkan kunci untuk mengembalikan teks asli. Pada dekripsi, transposed_matrix diurutkan berdasarkan order untuk mengembalikan teks asli",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Playfair"
    ]
  },
  {
    "objectID": "1_caesar.html",
    "href": "1_caesar.html",
    "title": "1. Caesar Cipher",
    "section": "",
    "text": "Analogi Caesar Cipher\nMisalkan kita memiliki teks “HELLO” dan kita ingin mengenkripsinya dengan kunci pergeseran 3 posisi ke kanan.",
    "crumbs": [
      "Kriptografi Klasik",
      "1. Caesar Cipher"
    ]
  },
  {
    "objectID": "1_caesar.html#lingkungan-pengembangan-web",
    "href": "1_caesar.html#lingkungan-pengembangan-web",
    "title": "1. Caesar",
    "section": "Lingkungan Pengembangan Web",
    "text": "Lingkungan Pengembangan Web\n\nEditor kode\n\n\n\nVisual Studio Code\n\n\nGunakan editor teks atau lingkungan pengembangan terintegrasi (IDE) seperti Visual Studio Code, Sublime Text, atau Atom untuk menulis kode web. \n\n\nBrowser\n\nBerbagai browser seperti Chrome, Firefox, atau Safari digunakan untuk menguji dan melihat hasil dari halaman web yang dikembangkan. \n\n\nServer lokal\nAnda dapat menginstal server web lokal seperti Apache, Nginx, atau XAMPP untuk menguji halaman web secara lokal sebelum diunggah ke server publik.\n\n\nURL (Uniform Resource Locator)\nAlamat yang digunakan untuk mengakses halaman web. URL terdiri dari protokol (misalnya http:// atau https://), nama domain, dan path halaman.\n\n\n\nHTTP (Hypertext Transfer Protocol)\nProtokol komunikasi yang digunakan untuk mentransfer data antara klien dan server. Permintaan klien dan respons server terjadi melalui metode HTTP seperti GET, POST, PUT, dan DELETE.\n\n\n\nMarkup Languages\nMarkup languages adalah bahasa yang digunakan untuk membuat struktur dan tampilan konten dalam halaman web.\n\nHTML (HyperText Markup Language) adalah markup language yang paling umum digunakan untuk membangun struktur halaman web. XML (eXtensible Markup Language) digunakan untuk menyimpan dan mengirim data secara terstruktur.\nStruktur Dasar HTML\nMerupakan bahasa markup paling popular, disusul eXtensible Markup Language (XML). XML adalah bahasa yang digunakan untuk membuat bahasa markup lain yaitu Wireless Markup Language (WML).Bahasa markup bukan bahasa pemrograman. Oleh karena itu, penyebutan bahasa pemrograman HTML adalah kurang tepat.\nFormat Dasar HTML\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Untitled Document&lt;/title&gt;\n&lt;meta http-equiv=\"Content-Type\" content=\"text/html;\ncharset=iso-8859-1\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n{ Tempat untuk coding }\n&lt;/body&gt;\n&lt;/html&gt;\n&lt; HTML &gt;\nDokumen HTML harus diawali dengan tag &lt; html &gt; dan diakhiri dengan &lt; /html &gt;memberi tahu kepada browser bahwa yang berada dalam kedua tag tersebut adalah dokumen HTML.\n&lt; HEAD &gt; Bagian header dalam dokumen HTML. Biasanya berisi judul halaman web. Bentuk secara umum:\n&lt;head&gt;\n&lt;title&gt;Judul ini akan ditampilkan pada bagian atas\nbrowser\n&lt;/title&gt;\n&lt;/head&gt;\n&lt; BODY &gt;\nBagian isi dari dokumen HTML yang dapat disisipkan teks, gambar, video maupun link. Sesuatu yang ditulis di dalam bodyakan ditampilkan pada halaman web.\nHTML Tags\nInstruksi/perintah dalam HTML disebut tag. Tag pada HTML tidak bersifat case sensitive.\n&lt;element atribut=value&gt;\nKeterangan:\n\nelement = nama tag\natribut = atribut\nvalue = nilai dari atribut Contoh:\n\n&lt;font color=red&gt;\n\nFONT merupakan element,\nCOLOR merupakan atribut,\nRED adalah value\n\n\n\n\n\n\n\nContoh HTML\n\n\n\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;\nHalaman Latihan 1\n&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;\nIni adalah latihan pemrograman web pertamaku.\n&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nCSS (Cascading Style Sheets) digunakan untuk mengatur tampilan dan gaya elemen-elemen dalam halaman web.\n\n\n\nArsitektur Klien dan Server\n\n\n\nArsitektur Klien dan Server\n\n\nPada pemrograman web, arsitektur klien dan server digunakan. Klien (misalnya browser web) mengirimkan permintaan ke server, dan server merespons dengan mengirimkan halaman web yang diminta.\nKlien menginterpretasikan halaman web menggunakan HTML, CSS, dan JavaScript, sementara server mengurus pemrosesan data dan logika di balik halaman.\n\n\n\nDatabase\n\n\n\nDatabase MySQL\n\n\nDBMS atau Database Management System digunakan untuk menyimpan dan mengelola data dalam aplikasi web. Beberapa sistem database yang umum digunakan termasuk MySQL, PostgreSQL, MongoDB, dan Oracle. Pemahaman tentang database meliputi pembuatan tabel dan relasi antar tabel, manipulasi data dengan menggunakan bahasa query seperti SQL, dan pengoptimalan kinerja database\n\n\n\nFramework\n\n\n\n\n\n\n\n\n\nLaravel\n\n\n\n\n\n\n\nBootstrap\n\n\n\n\n\nFramework adalah kerangka kerja perangkat lunak yang menyediakan struktur, komponen, dan alat bantu untuk membangun aplikasi web dengan lebih cepat dan efisien. Framework menyediakan aturan dan konvensi yang konsisten, menyederhanakan tugas umum, jika seperti routing, validasi data, interaksi dengan database, dan lainnya. Dalam pemrograman web khsusnya dengan menggunakan bahasa pemrograman php yang populer termasuk Laravel dan CodeIgniter. Dalam pemrograman web,\n\n\n\nWeb Servers\n\n\n\nApache Server\n\n\nWeb server adalah perangkat lunak yang mengelola permintaan dari browser dan mengirimkan halaman web ke pengguna melalui protokol HTTP. Beberapa server web yang umum digunakan adalah Apache, Nginx, dan IIS (Internet Information Services). Pemahaman tentang konfigurasi server web, manajemen domain, dan penanganan permintaan HTTP penting dalam pengembangan web.\n\n\n\nVersion Control\nVersion control adalah metode untuk melacak perubahan kode sumber selama pengembangan aplikasi. Git adalah sistem version control yang populer yang memungkinkan pengembang untuk bekerja secara kolaboratif, membuat cabang (branch), menggabungkan perubahan (merge), dan melakukan pemulihan (revert) jika terjadi kesalahan. Version control membantu dalam manajemen kode, pengendalian versi, dan kolaborasi tim.\n\n\n\nResposive Web Design\nResponsive web design adalah pendekatan desain web yang memastikan tampilan dan pengalaman pengguna yang optimal di berbagai perangkat dan ukuran layar. Ini melibatkan penggunaan teknik seperti media queries, flexible grids, dan CSS frameworks (seperti Bootstrap atau Foundation) untuk mengatur tata letak dan tampilan halaman web secara responsif.\n\n\n\nTesting and Debugging\nTesting dan debugging adalah proses penting dalam pengembangan web untuk memastikan aplikasi berfungsi dengan baik dan bebas dari kesalahan. Testing adalah proses verifikasi dan validasi untuk memastikan bahwa aplikasi web berfungsi sesuai dengan yang diharapkan dan memenuhi persyaratan bisnis yang telah ditetapkan. Tujuan dari testing adalah untuk menemukan bug atau kesalahan dalam aplikasi sebelum dirilis ke pengguna akhir. Debugging adalah proses untuk menemukan, mendiagnosis, dan memperbaiki bug atau kesalahan dalam kode aplikasi web.\n\n\n\nAPI (Application Programming Interface)\nAPI adalah antarmuka yang memungkinkan aplikasi web berkomunikasi dan berbagi data dengan aplikasi atau layanan lain. RESTful API adalah pendekatan populer untuk mengembangkan API yang menggunakan protokol HTTP dan standar seperti JSON atau XML untuk bertukar data.",
    "crumbs": [
      "Kriptografi Klasik",
      "1. Caesar{.unnumbered}"
    ]
  },
  {
    "objectID": "1_caesar.html#php-hypertext-preprocessor",
    "href": "1_caesar.html#php-hypertext-preprocessor",
    "title": "1. Caesar",
    "section": "PHP (Hypertext Preprocessor)",
    "text": "PHP (Hypertext Preprocessor)\nPHP adalah bahasa pemrograman server-side yang populer untuk pengembangan web. PHP digunakan untuk memproses permintaan dari klien, mengakses basis data, dan menghasilkan respons yang dikirimkan kembali ke klien.\n\nMemulai PHP\nSetiap memulai kode php selalu diawali dengan &lt;?php dan ditutup dengan ?&gt; \n&lt;?php\n    $kata = \"Hello World!\"\n    echo \"$kata\"; // Output: Hello World!\n?&gt;\nMenggunakan echo untuk print\nDalam variabel php menggunakan tanda $ ($variable) untuk inisialisasi variabel\n\n\nPHP - Kondisional\nKondisional dalam bahasa pemrograman adalah proses yang berfungsi untuk menentukan blok instruksi akan dieksekusi atau tidak, tergantung pada kondisinya sendiri seperti nilainya sudah benar (True) atau belum (False). Ada beberapa jenis percabangan yaitu if-else, switch case dll.\n$angka = -5;\nif($angka &lt; 0){\n    echo 'Angka negatif';\n} else {\n    echo'Angka positif ';\n};\n//Output : Angka Negatif\n$input = 3;\nswitch($input){\n    case \"1\":\n    echo\"Inputan adalah satu\";\n    break;\n    case \"2\":\n    echo\"Inputan adalah dua\";\n    break;\n    case \"3\":\n    echo\"Inputan adalah tiga\";\n    break;\n    default:\n    echo\"Tidak ada input yang cocok dengan pilihan anda.\";\n    }\n    /* Output: Inputan adalah tiga\n    Jika nilai dari variable `$input` bukan sama dengan `case`,\n    maka akan menampilkan pesan “Tidak ada input yang cocok\n    */\n\n\n\nPHP – isset dan empty\nFungsi isset digunakan untuk memeriksa apakah suatu variabel telah diatur atau tidak. Sintaks fungsi ini sebagai berikut:\n$nama = \"Bengkel Koding\";\nif(isset($nama)){\n    print(\"Nama telah diatur\");\n} else {\n    print(\"Nama belum diatur\")\n}\n// output : Nama telah diatur\n\nFungsi empty digunakan untuk memeriksa apakah suatu variabel kosong atau tidak. Sintaks fungsi ini sebagai berikut:\n$nama = \"\";\nif(empty($nama)) {\n    print(\"nama kosong\");\n} else {\n    print(\"nama tidak kosong\");\n}\n// output : Nama kosong\n\n\n\nPHP - Looping\nPerulangan pada php terdapat beberapa fungsi yang dapat digunakan, diantaranya adalah for, while, do while, dan foreach\n\nLooping For\nLooping For adalah salah satu looping statement pada bahasa pemrograman php, yang memiliki sintaks seperti for (expression1; expression2; expression3) {} dimana expression 1 merupakan awal dari pengulangan, expression 2 menentukan kondisi yang harus terpenuhi agar perintah d iterasi lebih lanjut, sedangkan expresion 3 mengubah nilai variable dalam setiap iterasinya.\nContoh Penggunaannya:\nfor ($i=0;$i&lt;=5;$i++){\necho \"$i \";\n}\n// Output: 0 1 2 3 4 5\nDalam contoh diatas, nilai x mulai dari angka 0 dan terus ditambah sampai batas yaitu &lt;=5. Setelah itu akan di eksekusi dengan cara mencetak isi value dari x ke layar.\n\n\nWhile\nLooping while juga ada didalam bahasa pemograman PHP, sintaksnya sama tapi bedanya hanya bisa melakukan looping selama kondisinya benar/true.\nContohnya:\n$x = 0; //awal variabel $x\nwhile($x &lt;= 5){\necho \"$x \";\n$x++;\n}\n// Output : 0 1 2 3 4 5\n\n\nDo While\nPerulangan do-while adalah perintah yang digunakan untuk mengulang suatu proses terhadap nilai kondisional (expression) saat awal loop dilanjutkan dengan evaluasi ulang pada akhir setiap iterasi.\nSintaks nya adalah sebagai berikut:\n$i = 1;\ndo{\n    echo $i;\n    $i++;\n} while ($i &lt;= 5);\n// Output : 0 1 2 3 4 5\n\n\nForeach\nForeach merupakan perintah yang digunakan untuk mengiterasi set data array dalam bahasa pemrograman php. Sintaks nya seperti ini:\n$buah = array(\"Apel\", \"Jeruk\", \"Mangga\", \"Pisang\");\nforeach ($buah as $item) :\n    echo $item . \"\\n\";\nendforeach;\n/* output : \napel\njeruk\nmangga\npisang\n*/\nSelain menggnakan endforeach bisa juga menggunakan kurung kurawal {}\n$buah = array(\"Apel\", \"Jeruk\", \"Mangga\", \"Pisang\");\nforeach ($buah as $item) {\n    echo $item . \"\\n\";\n}\n/* output : \napel\njeruk\nmangga\npisang\n*/\n\n\n\nInclude - Require\nFungsi-fungsi ini digunakan untuk menyisipkan (include) atau memasukkan (require) file PHP eksternal ke dalam file PHP yang sedang aktif. Berguna untuk mengorganisir kode secara modular.",
    "crumbs": [
      "Kriptografi Klasik",
      "1. Caesar{.unnumbered}"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Kriptografi",
    "section": "",
    "text": "Pengantar\nPelatihan Web Developer terbagi menjadi dua tahap (kelas) yaitu Junior Web Developer dan Web Developer. Materi yang diajarkan pada kedua kelas berbeda namun berkelanjutan. Pada modul Junior Web Developer berisi tentang dasar-dasar dari pemrograman web dengan permasalahan yang sering dialami mahasiswa. Sedangkan pada modul Web Developer berisi materi pemrograman web dengan menggunakan framework. Sehingga peserta yang lulus pada setiap kelas berhak melanjutkan ke kelas selanjutnya.",
    "crumbs": [
      "**Pengantar**"
    ]
  },
  {
    "objectID": "index.html#materi-junior-web-developer",
    "href": "index.html#materi-junior-web-developer",
    "title": "Kriptografi",
    "section": "Materi Junior Web Developer",
    "text": "Materi Junior Web Developer\nTerdapat topik-topik dan materi-materi yang akan diajarkan, diantaranya sebagai berikut:\n\n\nTopik dan Materi Junior Web Developer\n\n\n\n\n\n\n\nTopik\nMateri\nOutcome\n\n\n\n\nWeb Developments Fundamentals \n1. Konsep Dasar Pemrograman Berbasis Web  2. Pengenalan Tools (J.620100.001.01), Library, komponen dan Framework pemrograman berbasis web (J.620100.003.01) \nPeserta memahami konsep dasar pemrograman berbasis web, mengenal tools, library, framework yang diperlukan untuk mengembangkan aplikasi berbasis web \n\n\nMelakukan Migrasi ke Teknologi Baru (J.620100.024.02) \n1. Pengenalan Responsive Web Design (Mobile First),  2. Praktek Instalasi Bootstrap Framework \nPeserta memiliki pengetahuan mengenai teknologi terkini dalam pembangunan aplikasi berbasis web dan cara menggunakannya \n\n\nMenerapkan Rancangan User Interface / User Experience (UI/UX) (J.620100.006.01) dan alert notification jika terdapat suatu permasalahan pada aplikasi (J.620100.044.01) \nPraktek mengimplementasikan design UI halaman depan (front page) aplikasi To Do List menggunakan Bootstrap \nPeserta dapat menerapkan rancangan UI/UX dan alert notification dari project yang diberikan \n\n\nKonsep Basis Data Dan Menggunakan SQL (J.620100.020.02)\n1. Review Konsep Basis Data  2. Query SQL: DDL, DML  3. Praktek membuat database dan tabel aplikasi To Do List \nPeserta memiliki pengetahuan mengenai konsep Basis Data dan menggunakan Database Management System (DBMS) berbasis SQL \n\n\nMenerapkan Pemrograman Terstruktur (J.620100.017.02) Dan Akses Basis Data (J.620100.021.02) \nPraktek pembuatan Aplikasi To Do List  Praktek Studi Kasus aplikasi Poliklinik (langkah-langkah pembuatan) \nPeserta mampu menerapkan konsep dasar pemrograman terstruktur dan mengakses basis data menggunakan kode program \n\n\nDebugging, Pengujian Program dan Code Review (J.620100.025.02, J.620100.036.02, J.620100.032.01) \nPengenalan Tool untuk melakukan pengujian aplikasi berbasis web   Praktek software testing aplikasi Poliklinik \nPeserta mampu melakukan debugging, pengujian program, meninjau dan memeriksa kode program yang telah dibuat \n\n\nPembaruan Perangkat Lunak pada Web Dasar (J.620100.047.01)\nPraktek mengembangkan aplikasi Poliklinik  Penilaian final project \nPeserta dapat menambahkan fitur tambahan dari project web yang diberikan",
    "crumbs": [
      "**Pengantar**"
    ]
  },
  {
    "objectID": "5_transposisi_kolom.html",
    "href": "5_transposisi_kolom.html",
    "title": "5. Transposisi Kolom",
    "section": "",
    "text": "Analogi Transposisi Kolom\nBayangkan Kita memiliki rak buku dengan beberapa kolom dan setiap kolom berisi tumpukan buku.\nDengan kata lain, transposisi kolom mengubah urutan kolom tanpa mengubah isi kolom. Dalam kriptografi, ini dilakukan untuk mengacak data agar lebih sulit ditebak oleh pihak yang tidak berwenang.",
    "crumbs": [
      "Kriptografi Klasik",
      "5. Transposisi Kolom"
    ]
  },
  {
    "objectID": "5_transposisi_kolom.html#implementasi-pada-python",
    "href": "5_transposisi_kolom.html#implementasi-pada-python",
    "title": "5. Transposisi Kolom",
    "section": "Implementasi Pada Python",
    "text": "Implementasi Pada Python\nMasukkan plaintext\nplainText = input(\"Plaintext : \")\nMasukkan kunci\nkey = input(\"masukkan kunci : \")\nMembersihkan teks dari spasi ganda\ncleanPlainTeks = plainTeks.replace(\" \", \"\")\nprint(cleanPlainTeks)\nDeklarasi urutan huruf dalam alfabet\nascii = {\n'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8, 'i': 9, 'j': 10, 'k': 11, \n'l': 12, 'm': 13, 'n': 14, 'o': 15, 'p': 16, 'q': 17, 'r': 18, 's': 19, 't': 20, 'u': 21, \n'v': 22, 'w': 23, 'x': 24, 'y': 25, 'z': 26\n}\n\nProses Enkripsi\nInisialisasi list untuk menyimpan urutan numerik dari setiap huruf alfabet\nkolom = 0\nangka_urutan = []\nMengonversi setiap huruf dalam kata kunci menjadi urutan numeriknya sesuai dengan posisi dalam alfabet\nfor huruf in key:\n    if huruf.isalpha():\n        angka_urutan.append(ascii[huruf.lower()])\n        kolom = kolom+1\n        cleanKey = angka_urutan\n\nprint(f\"Urutan kunci dari kata '{key}' adalah {angka_urutan}\")\nFor More Detail :\n\nfor huruf in key : Loop ini digunakan untuk memeriksa setiap huruf dalam variabel key, yang diharapkan merupakan kata kunci yang diberikan oleh pengguna\nif huruf.isalpha() : Kondisi ini memastikan bahwa hanya karakter alfabet yang akan diproses. Karakter non-alfabet akan dilewati\n`huruf.lower(): Mengubah huruf menjadi huruf kecil untuk konsistensi, sehingga tidak ada perbedaan antara huruf besar dan kecil\nascii[huruf.lower()] : Mengambil nilai urutan numerik dari huruf. Di sini diasumsikan ada sebuah kamus (dictionary) bernama ascii yang memetakan setiap huruf ke urutan numeriknya\nangka_urutan.append(...) : Menambahkan urutan numerik dari huruf ke dalam list angka_urutan\nkolom = kolom + 1 : Menghitung jumlah kolom dengan menambah nilai kolom setiap kali huruf diproses\ncleanKey = angka_urutan : Menyimpan hasil akhir urutan numerik ke dalam variabel cleanKey\n\nMembuat sebuah matriks kosong untuk menyimpan teks yang telah diolah dalam bentuk matriks\nmatrix = []\nMenghitung panjang dari teks yang telah dibersihkan dan disimpan dalam variabel cleanPlainTeks\npanjang = len(cleanPlainTeks)\nMencari tahu berapa kali kolom dapat digunakan untuk memuat seluruh teks, dengan membagi panjang teks dengan jumlah kolom\ntemp = panjang/kolom\nMembulatkan hasil pembagian sebelumnya ke bilangan bulat terdekat\nbulat = round(temp)\nMenghitung jumlah baris untuk memuat teks dalam matriks\nif temp - bulat == 0:\n    baris = bulat\nelse:\n    if temp - bulat &lt; 0:\n        baris = bulat\n    else:\n        baris = bulat + 1\nprint(baris)\nFor More Detail :\n\ntemp : hasil pembagian panjang teks dengan jumlah kolom\nbulat: hasil pembagian yang dibulatkan ke bilangan bulat terdekat. Jika temp adalah bilangan bulat (tidak ada sisa), jumlah baris adalah bulat. Jika ada sisa, jumlah baris adalah bulat + 1\n\nMengisi matriks dengan karakter dari teks yang telah dibersihkan (cleanPlainTeks)\nfor i in range(baris):\n    row = []\n    for j in range(kolom):\n        if i * kolom + j &lt; len(cleanPlainTeks):\n            elemen = cleanPlainTeks[i * kolom + j]\n        else:\n            elemen = \" \"\n        row.append(elemen)\n    matrix.append(row)\nFor More Detail :\n\nfor i in range(baris) : Loop untuk setiap baris dalam matriks\nrow = [] : Inisialisasi list kosong untuk setiap baris\nif i * kolom + j &lt; len(cleanPlainTeks) : Memeriksa apakah indeks saat ini berada dalam rentang panjang teks yang dibersihkan.\nelemen = cleanPlainTeks[i * kolom + j] : Jika indeks berada dalam rentang, maka ambil karakter dari cleanPlainTeks berdasarkan indeks yang dihitung.\nelse : Jika indeks melebihi panjang teks, isi elemen dengan spasi.\nrow.append(elemen) : Menambahkan elemen ke dalam baris.\nmatrix.append(row) : Menambahkan baris yang telah diisi ke dalam matriks.`\n\nMencetak matriks\nprint(\"Matriks yang Anda buat:\")\nfor row in matrix:\n    print(row)\nMentransposisikan matriks yang telah dibuat dan kemudian mencetak matriks yang telah ditransposisikan\ntransposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\nfor row in transposed_matrix:\n    print(row)\nFor More Detail :\n\nfor i in range(len(matrix[0])) : Iterasi melalui indeks kolom matriks asli\nrow[i] for row in matrix : Untuk setiap indeks kolom i, ambil elemen i dari setiap baris dalam matriks asli dan akan menghasilkan kolom baru dari elemen-elemen tersebut, membentuk baris baru di matriks yang ditransposisikan\n\nMembuat list kosong dengan panjang yang sama dengan cleanKey untuk menyimpan urutan indeks\norder = [None] * len(cleanKey)\nMengurutkan elemen-elemen dalam cleanKey berdasarkan nilai terkecil hingga terbesar\ni = 0\nwhile len(cleanKey) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, cleanKey))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = cleanKey.index(nilai_terkecil)\n\n        order[marker] = i\n        cleanKey[marker] = None \n        i = i + 1\n    else:\n        break\nprint(order)\nFor More Detail :\n\ni = 0 : Inisialisasi counter i\nwhile len(cleanKey) &gt; 0 : Loop hingga cleanKey kosong (semua elemen None)\nnon_none_values = list(filter(lambda x: x is not None, cleanKey)) : Membuat list yang hanya berisi elemen-elemen cleanKey yang bukan None\nif non_none_values : Mengecek apakah list non_none_values tidak kosong nilai_terkecil = min(non_none_values) : Mencari nilai terkecil dari non_none_values\nmarker = cleanKey.index(nilai_terkecil) : Mendapatkan indeks dari nilai terkecil dalam cleanKey Menyimpan Urutan dan Menghapus Nilai Terkecil:\norder[marker] = i : Menyimpan urutan i pada indeks marker di list order\ncleanKey[marker] = None : Menghapus nilai terkecil dari cleanKey dengan mengubahnya menjadi None\ni = i + 1 : Increment counter i.\n\nMengubah urutan kolom matriks transposed_matrix berdasarkan urutan yang telah diatur dalam order, dan kemudian mencetak matriks yang sudah diubah urutan kolomnya\nnew_matrix = []\nwhile len(order) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, order))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = order.index(nilai_terkecil)\n       \n        new_matrix.append(transposed_matrix[marker])\n        order[marker] = None\n    else:\n        break\n\nfor row in new_matrix:\n    print(row)\nFor More Detail :\n\nnew_matrix = [] : Membuat list kosong new_matrix untuk menampung baris-baris matriks yang baru diurutkan Looping untuk Mengubah Urutan Kolom:\nwhile len(order) &gt; 0 : Melakukan looping selama masih ada elemen yang tersisa dalam order\nnon_none_values = list(filter(lambda x: x is not None, order)) : Membuat list non_none_values yang hanya berisi nilai-nilai yang bukan None dari order\nif non_none_values : Memeriksa apakah non_none_values tidak kosong\nnilai_terkecil = min(non_none_values) : Menemukan nilai terkecil dari non_none_values\nmarker = order.index(nilai_terkecil) : Mencari indeks dari nilai_terkecil dalam order\nnew_matrix.append(transposed_matrix[marker]) : Menambahkan baris dari transposed_matrix yang sesuai dengan marker ke new_matrix\norder[marker] = None : Menghapus nilai yang telah diproses dengan mengubahnya menjadi None\nelse: break : Menghentikan loop jika non_none_values kosong, yang berarti semua nilai dalam order telah diproses\n\nMengonversi matriks new_matrix menjadi string tunggal dengan menggabungkan nilai-nilainya secara berurutan dan menghapus spasi ekstra di akhir string\nresult_string = \"\"\n\nfor row in new_matrix:\n    for value in row:\n        result_string += str(value)\n\nresult_string = result_string.strip()\n\nprint(result_string)\nFor More Detail :\n\nresult_string = \"\" : Inisialisasi string kosong result_string yang akan digunakan untuk menyimpan hasil akhir\nfor row in new_matrix: : Melakukan iterasi melalui setiap baris dalam new_matrix\nfor value in row: : Melakukan iterasi melalui setiap nilai dalam baris row\nresult_string += str(value) : Mengonversi nilai value menjadi string (jika belum string) dan menambahkannya ke result_string\nresult_string = result_string.strip() : Menghapus spasi ekstra di awal dan akhir string menggunakan metode strip()\n\nHasil Ciphertext : ENTKFINOKKM TIAIRA\n\n\nProses Dekripsi\ncipherTeks = input(\"masukkan kata : \")\nkey = input(\"masukkan kunci : \")\ncleanCipherTeks = cipherTeks.replace(\" \", \" \")\nprint(cleanCipherTeks)\nkolom = 0\nangka_urutan = []\nfor huruf in key:\n    if huruf.isalpha():\n        angka_urutan.append(ascii[huruf.lower()])\n        kolom = kolom+1\n        cleanKey = angka_urutan\n\nprint(f\"Urutan kunci dari kata '{key}' adalah: {angka_urutan}\")\nmatrix = []\npanjang = len(cleanCipherTeks)\ntemp = panjang/kolom\nbaris = round(temp)\nprint(baris)\nfor i in range(baris):\n    row = []\n    for j in range(kolom):\n        if i * kolom + j &lt; len(cleanCipherTeks):\n            elemen = cleanCipherTeks[i + baris * j]\n        else:\n            elemen = \"a\"\n        row.append(elemen)\n    matrix.append(row)\nprint(\"Matriks yang Anda buat:\")\nfor row in matrix:\n    print(row)\ntransposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\nfor row in transposed_matrix:\n    print(row)\norder = [None] * len(cleanKey)\ni = 0\nwhile len(cleanKey) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, cleanKey))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = cleanKey.index(nilai_terkecil)\n        order[marker] = i\n        cleanKey[marker] = None  \n        i = i + 1\n    else:\n        break\nprint(order)\ntransposed_matrix = [transposed_matrix[i] for i in order]\n\nfor row in transposed_matrix:\n    print(row)\nmatriks = [[row[i] for row in transposed_matrix] for i in range(len(transposed_matrix[0]))]\nfor row in matriks:\n    print(row)\nresult_string = \"\"\n\nfor row in matriks:\n    for value in row:\n        result_string += str(value)\n\nresult_string = result_string.strip()\n\nprint(result_string)\nHasil Dekripsi : TEKNIKINFORMATIKA\nPerbedaan Proses :\n\nEnkripsi: Teks asli diubah menjadi matriks berdasarkan kolom kunci, kemudian kolom-kolom diurutkan berdasarkan kunci. Pada enkripsi, transposed_matrix adalah matriks transposisi dari matrix awal\nDekripsi: Teks sandi diubah menjadi matriks berdasarkan kolom kunci, kemudian baris-baris diurutkan berdasarkan kunci untuk mengembalikan teks asli. Pada dekripsi, transposed_matrix diurutkan berdasarkan order untuk mengembalikan teks asli",
    "crumbs": [
      "Kriptografi Klasik",
      "5. Transposisi Kolom"
    ]
  },
  {
    "objectID": "1_caesar.html#implementasi-pada-python",
    "href": "1_caesar.html#implementasi-pada-python",
    "title": "1. Caesar Cipher",
    "section": "Implementasi Pada Python",
    "text": "Implementasi Pada Python\nLANGKAH 1 :  Deklarasi kamus (dictionary) abjad_indeks -&gt; Kamus ini memetakan setiap huruf alfabet ke sebuah indeks numerik.\nabjad_indeks = {\n    'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5,\n    'f': 6, 'g': 7, 'h': 8, 'i': 9, 'j': 10,\n    'k': 11, 'l': 12, 'm': 13, 'n': 14, 'o': 15,\n    'p': 16, 'q': 17, 'r': 18, 's': 19, 't': 20,\n    'u': 21, 'v': 22, 'w': 23, 'x': 24, 'y': 25, 'z': 26\n}\nLANGKAH 2 :  Deklarasi variabel key -&gt; Nilai key ditetapkan ke 3, yang berarti setiap huruf dalam pesan akan digeser sebanyak 3 posisi dalam alfabet untuk enkripsi. Selanjutnya Input variabel pesan -&gt; Pesan yang akan dienkripsi.\n# Key untuk pergeseran\nkey = 3\n# Deklarasi variabel pesan: Pesan yang akan dienkripsi.\npesan = input(\"Masukkan pesan     : \")\ncleanPesan = pesan.replace(\" \", \"\")\nprint(\"Pesan Anda         :\",cleanPesan)\nPesan Anda : udinus\n\nProses Enkripsi\nLANGKAH 3 :  Inisialisasi pesan_terenkripsi: String kosong untuk menyimpan hasil enkripsi.\n\nIterasi melalui setiap huruf dalam pesan: Menggunakan loop for. Cek apakah huruf ada di abjad_indeks:\nJika Ya Hitung indeks baru dengan formula (abjad_indeks[huruf] + key) % 26. Ini menggeser posisi huruf dalam alfabet.\nCari huruf baru yang sesuai dengan indeks baru dari daftar kunci abjad_indeks dan tambahkan ke pesan_terenkripsi.\nJika Tidak (misalnya angka atau simbol): Tambahkan huruf tersebut langsung kepesan_terenkripsi tanpa perubahan.\n\n\npesan_terenkripsi = ''\nfor huruf in cleanPesan:\n    if huruf in abjad_indeks:\n        indeks = (abjad_indeks[huruf] + key) % 26\n        pesan_terenkripsi += list(abjad_indeks.keys())[indeks - 1]\n    else:\n        pesan_terenkripsi += huruf\n\nprint(\"Pesan terenkripsi:\", pesan_terenkripsi)\nPesan terenkripsi: xglqxv\n\n\nProses Dekripsi\nLANGKAH 4 :  Inisialisasi pesan_terdekripsi: String kosong untuk menyimpan hasil dekripsi.\n\nIterasi melalui setiap huruf dalam pesan: Menggunakan loop for. Cek apakah huruf ada di abjad_indeks:\nJika Ya Hitung indeks baru dengan formula (abjad_indeks[huruf] - key) % 26. Ini menggeser posisi huruf dalam alfabet.\nCari huruf baru yang sesuai dengan indeks baru dari daftar kunci abjad_indeks dan tambahkan ke pesan_terenkripsi.\nJika Tidak (misalnya angka atau simbol): Tambahkan huruf tersebut langsung kepesan_terenkripsi tanpa perubahan.\n\npesan_terdekripsi = ''\nfor huruf in pesan_terenkripsi:\n    if huruf in abjad_indeks:\n        indeks = (abjad_indeks[huruf] - key) % 26\n        pesan_terdekripsi += list(abjad_indeks.keys())[indeks - 1]\n    else:\n        pesan_terdekripsi += huruf\n\nprint(\"Pesan terdekripsi:\", pesan_terdekripsi)\nPesan terdekripsi:: udinus",
    "crumbs": [
      "Kriptografi Klasik",
      "1. Caesar Cipher"
    ]
  },
  {
    "objectID": "3_vigenere_cipher.html",
    "href": "3_vigenere_cipher.html",
    "title": "3. Vigenere Cipher",
    "section": "",
    "text": "Analogi Vigenere Cipher\nMisalnya, jika kita memiliki teks “HELLO” dan kunci “KEY”, kita akan menggeser huruf-huruf dalam teks “HELLO” sesuai dengan urutan huruf dalam kata kunci “KEY”.",
    "crumbs": [
      "Kriptografi Klasik",
      "3. Vigenere Cipher"
    ]
  },
  {
    "objectID": "3_vigenere_cipher.html#teks-editor",
    "href": "3_vigenere_cipher.html#teks-editor",
    "title": "3. Vigenere Cipher",
    "section": "",
    "text": "Silahkan download file installer dari Visual Studio Code. Klik download pada halaman web Visual Studio Code sesuai dengan sistem operasi yang digunakan.\n\n\n\n\nLaman VSCode\n\n\n\nSetelah selesai download, klik dua kali pada file installer.\nJika muncul peringatan Run as Administrator, klik Yes.\nKemudian akan tampil window Installer Microsoft Visual Studio Code. Untuk menyetujui License Agreement, pilih “I accept the agreement” lalu next.\n\n\n\n\nLicense Agreement VS Code\n\n\n\nLalu pilih lokasi instalasinya. Jika ingin menggunakan lokasi default dapat langsung klik next.\n\n\n\n\nLokasi instalasi VS Code\n\n\n\nMemilih lokasi shortcuts program. Jika ingin menggunakan default dapat langsung klik next.\nPada bagian Select Additional Tasks, terdapat beberapa tasks yang bisa diinstall atau tidak. Untuk memudahkan ketika membuka file melalui berkas atau explorer dapat dipilih semua dan klik next.\nKlik install dan jalankan Visual Studio Code\n\n\n\n\nvscode\n\n\n\n\n\n\n\n\nIntalasi Visual Studio Code",
    "crumbs": [
      "Kriptografi Klasik",
      "3. Vigenere Cipher"
    ]
  },
  {
    "objectID": "3_vigenere_cipher.html#web-browser",
    "href": "3_vigenere_cipher.html#web-browser",
    "title": "3. Vigenere Cipher",
    "section": "Web Browser",
    "text": "Web Browser\nWeb browser adalah perangkat lunak yang awalnya dirancang untuk menampilkan dokumen web/HTML. Namun, pada saat ini, web browser harus memiliki kemampuan untuk menginterpretasikan dan menjalankan JavaScript atau VBScript, menjalankan Java Applet, memahami dokumen XML, dan menjalankan dokumen khusus dengan menggunakan fasilitas plugin seperti file .swf Macromedia Flash, dan lain sebagainya. \nBanyak web browser yang dapat digunakan, dan paling umum digunakan adalah Google Chrome dan Mozilla Firefox atau dapat menggunakan web browser yang tersedia pada laptop atau pc yang digunakan seperti safari atau microsoft edge. \n\n\n\n\n\n\n\n\n\nChrome\n\n\n\n\n \n\n\n\n\n\nMozilla Firefox",
    "crumbs": [
      "Kriptografi Klasik",
      "3. Vigenere Cipher"
    ]
  },
  {
    "objectID": "3_vigenere_cipher.html#web-server",
    "href": "3_vigenere_cipher.html#web-server",
    "title": "3. Vigenere Cipher",
    "section": "Web Server",
    "text": "Web Server\nWeb Server adalah server HTTP yang bertugas menyediakan dokumen yang diminta oleh web browser. Saat ini, web server telah berkembang menjadi lebih kompleks karena harus melayani banyak fungsi dan bahkan menjadi pusat layanan-layanan lain. \nWeb server juga menjadi komponen yang sangat penting dalam application server. Sebagai server HTTP, web server harus dapat menangani permintaan dokumen yang diberikan oleh web browser dan juga harus bisa dikonfigurasi untuk berinteraksi dengan program-program seperti JSP, ASP, PHP, melalui CGI, dan sebagainya. Contoh-contoh web server yang populer antara lain Apache dan IIS (Internet Information Service). \nXAMPP \nXAMPP adalah sebuah web server open source yang dapat berjalan diberbagai sistem operasi seperti Windows, Linux, dan MacOS. \nXAMPP menyediakan semua komponen yang diperlukan untuk mengelola sebuah website, termasuk Apache, MySQL/MariaDB, PHP, dan Perl. XAMPP dapat digunakan untuk membuat web server lokal di komputer. \nUntuk menginstall XAMPP ikuti langkah-langkah berikut: \n\nUnduh file installer dari website XAMPP. Unduh sesuai dengan sistem operasi atau komputer yang digunakan. \n\n\n\n\nWeb XAMPP\n\n\n\nLakukan instalasi XAMPP sesuai panduan (wizard) yang ditampilkan dan pilih Yes untuk melanjutkan instalasi. Bila ada pesan error biarkan saja. \n\n\n\n\nPesan error\n\n\n\nPilih komponen yang Anda butuhkan dalam instalasi tersebut. Sebagai contoh, centang MySQL dan phpMyAdmin.\nTentukan direktori instalasi yang tepat, misalnya C:\\xampp.\nLanjutkan tahapan dan klik install.\n\n Untuk melihat konfigurasi php dapat membuka config pada baris apache lalu membuka php.ini \n\n\n\nApache Config\n\n\nCek versi php dan ekstensi lain dengan cara membuat file “info.php” yang isinya &lt;?php phpinfo(); ?&gt;, letakkan pada C:\\xampp\\htdocs. Lalu buka localhost/info.php pada browser\n\n\n\n\n\n\nInstalasi Xampp",
    "crumbs": [
      "Kriptografi Klasik",
      "3. Vigenere Cipher"
    ]
  },
  {
    "objectID": "3_vigenere_cipher.html#bootstrap",
    "href": "3_vigenere_cipher.html#bootstrap",
    "title": "3. Vigenere Cipher",
    "section": "Bootstrap",
    "text": "Bootstrap\nBootstrap adalah sebuah kerangka kerja (framework) front-end yang populer untuk pengembangan desain web responsif (responsive web design). Dikembangkan oleh tim Twitter, Bootstrap menyediakan serangkaian komponen dan gaya CSS yang dapat digunakan untuk membangun tampilan web yang konsisten, menarik, dan responsif secara cepat. Sampai dengan modul ini dibuat, Bootstrap telah mengalami pembaruan Bootstrap versi 5.\n\n\n\n\nBootstrap\n\n\n\nCara instalasi Bootstrap \n\nBuka halaman resmi Bootstrap di https://getbootstrap.com.\nDi halaman utama, Anda akan melihat tombol “Download” di bagian bawah. Klik tombol tersebut untuk mengunduh file Bootstrap. \n\n\n\n\n\n\n\n\n\n\nTampilan Halaman Bootstrap\n\n\n\n\n \n\n\n\n\n\nDownload Paket Bootstrap\n\n\n\n\n\n\nSetelah selesai mengunduh, ekstrak file zip Bootstrap yang telah diunduh ke direktori proyek web Anda. \n\n\n\n\nEkstrak File\n\n\n\nDi dalam direktori proyek, buatlah folder baru (misalnya “css” dan “js”) untuk menyimpan file CSS dan JavaScript Bootstrap. \n\n\n\n\nEkstrak File\n\n\n\nSalin file bootstrap.min.css yang ada di dalam direktori “dist/css” dalam file Bootstrap yang telah diekstrak, ke dalam folder “css” di dalam direktori proyek Anda.\nSalin file bootstrap.min.js yang ada di dalam direktori “dist/js” dalam file Bootstrap yang telah diekstrak, ke dalam folder “js” di dalam direktori proyek Anda.\nSetelah itu, Anda dapat menggunakan Bootstrap dengan menautkan file CSS dan JavaScript ke dalam halaman HTML Anda. Dalam elemen &lt;head&gt; dari file HTML, tambahkan tag link berikut untuk menautkan file CSS Bootstrap: \n\n&lt;link rel=\"stylesheet\" href=\"css/bootstrap.min.css\"&gt;\n\nJuga di dalam elemen &lt;body&gt; atau sebelum penutup tag &lt;/body&gt; dalam file HTML, tambahkan tag script berikut untuk menautkan file JavaScript Bootstrap: \n\n&lt;script src=\"js/bootstrap.min.js\"&gt;&lt;/script&gt; \n\nSekarang, Anda dapat menggunakan kelas-kelas, komponen, dan gaya Bootstrap dalam halaman web Anda.Sekarang, Anda dapat menggunakan kelas-kelas, komponen, dan gaya Bootstrap dalam halaman web Anda.\n\n\n\n\n\n\n\nInstalasi Bootstrap\n\n\n\nBerikut adalah penjelasan mengenai instalasi bootstrap!",
    "crumbs": [
      "Kriptografi Klasik",
      "3. Vigenere Cipher"
    ]
  },
  {
    "objectID": "3_vigenere_cipher.html#implementasi-pada-python",
    "href": "3_vigenere_cipher.html#implementasi-pada-python",
    "title": "3. Vigenere Cipher",
    "section": "Implementasi Pada Python",
    "text": "Implementasi Pada Python\nLANGKAH 1 :  Deklarasi kamus (dictionary) abjad -&gt; Kamus ini memetakan setiap huruf alfabet ke sebuah indeks numerik.\nabjad = {\n    'A': 1, 'B': 2, 'C': 3, 'D': 4, 'E': 5,\n    'F': 6, 'G': 7, 'H': 8, 'I': 9, 'J': 10,\n    'K': 11, 'L': 12, 'M': 13, 'N': 14, 'O': 15,\n    'P': 16, 'Q': 17, 'R': 18, 'S': 19, 'T': 20,\n    'U': 21, 'V': 22, 'W': 23, 'X': 24, 'Y': 25, 'Z': 26\n}\nLANGKAH 2 :  Masukkan Plaintext dan Kunci\n# Input teks asli dan kunci\nteks = input(\"Masukkan Plaintext : \")\nkunci = \"key\"\nteks = teks.upper()\nkunci = kunci.upper()\nMasukkan Plaintext : udinus24\n\nProses Enkripsi\nLANGKAH 3 :  Melakukan Enkripsi\n# Inisialisasi variabel hasil\npesan_terenkripsi = ''\npanjang_kunci = len(kunci)\nindeks_kunci = 0\n\n# Iterasi melalui setiap karakter di teks asli\nfor huruf in teks:\n    # Periksa apakah karakter adalah huruf alfabet\n    if huruf in abjad:\n        # Temukan indeks dari teks asli dan kunci\n        indeks_teks = abjad[huruf]\n        huruf_kunci = kunci[indeks_kunci % panjang_kunci]\n        indeks_huruf_kunci = abjad[huruf_kunci]\n\n        # Hitung indeks hasil menggunakan rumus Vigenere cipher\n        indeks_hasil = (indeks_teks + indeks_huruf_kunci - 1) % 26 + 1\n\n        # Temukan karakter hasil berdasarkan indeks\n        for k, v in abjad.items():\n            if v == indeks_hasil:\n                pesan_terenkripsi += k\n                break\n\n        # Pindah ke karakter berikutnya dalam kunci\n        indeks_kunci += 1\n    else:\n        # Jika karakter bukan alfabet, tambahkan tanpa perubahan\n        pesan_terenkripsi += huruf\nCETAK HASIL ENKRIPSI : \nteks_per_huruf = ', '.join(f\"'{char}'\" for char in teks)\n# Menyusun kunci berulang sesuai panjang teks asli\nkunci_berulang = (kunci * (len(teks) // panjang_kunci)) + kunci[:len(teks) % panjang_kunci]\nkunci_per_huruf = ', '.join(f\"'{char}'\" for char in kunci_berulang)\n# output\nhasil_encrypt = ', '.join(f\"'{char}'\" for char in pesan_terenkripsi)\n\nprint(f\"Plaintext     : {teks_per_huruf}\")\nprint(\"\")\nprint(f\"Kunci         : {kunci_per_huruf}\")\nprint(\"\")\nprint(f\"Hasil Encrypt : {hasil_encrypt}\")\nPlaintext     : 'U', 'D', 'I', 'N', 'U', 'S', '2', '4' \nKunci         : 'K', 'E', 'Y', 'K', 'E', 'Y', 'K', 'E' \nHasil Encrypt : 'F', 'I', 'H', 'Y', 'Z', 'R', '2', '4' \n\n\nProses Dekripsi\nLANGKAH 4 :  Melakukan Dekripsi\n# Inisialisasi variabel hasil\npesan_terdekripsi = ''\npanjang_kunci = len(kunci)\nindeks_kunci = 0\n\n# Iterasi melalui setiap karakter di teks asli\nfor huruf in pesan_terenkripsi:\n    # Periksa apakah karakter adalah huruf alfabet\n    if huruf in abjad:\n        # Temukan indeks dari teks asli dan kunci\n        indeks_teks = abjad[huruf]\n        huruf_kunci = kunci[indeks_kunci % panjang_kunci]\n        indeks_huruf_kunci = abjad[huruf_kunci]\n\n        # Hitung indeks hasil menggunakan rumus Vigenere cipher\n        indeks_hasil = (indeks_teks - indeks_huruf_kunci - 1) % 26 + 1\n\n        # Temukan karakter hasil berdasarkan indeks\n        for k, v in abjad.items():\n            if v == indeks_hasil:\n                pesan_terdekripsi += k\n                break\n\n        # Pindah ke karakter berikutnya dalam kunci\n        indeks_kunci += 1\n    else:\n        # Jika karakter bukan alfabet, tambahkan tanpa perubahan\n        pesan_terdekripsi += huruf\nCETAK HASIL DEKRIPSI : \nhasil_decrypt = ', '.join(f\"'{char}'\" for char in pesan_terdekripsi)\nprint(f\"Ciphertext    : {hasil_encrypt}\")\nprint(\"\")\nprint(f\"Kunci         : {kunci_per_huruf}\")\nprint(\"\")\nprint(f\"Hasil Decrypt : {hasil_decrypt}\")\nCiphertext    : 'F', 'I', 'H', 'Y', 'Z', 'R', '2', '4'\nKunci         : 'K', 'E', 'Y', 'K', 'E', 'Y', 'K', 'E'\nHasil Decrypt : 'U', 'D', 'I', 'N', 'U', 'S', '2', '4'",
    "crumbs": [
      "Kriptografi Klasik",
      "3. Vigenere Cipher"
    ]
  },
  {
    "objectID": "8_transposisi_route.html",
    "href": "8_transposisi_route.html",
    "title": "8. Transposisi Route",
    "section": "",
    "text": "Analogi Transposisi Railfence\nMari kita analogikan transposisi railfence dengan menyusun pesan di pagar besi sebagai proses enkripsinya dan membaca pesan tersembunyi dalam sebuah pagar besi sebagai proses dekripsinya\nEnkripsi: Menyusun Pesan di Pagar Besi\nBayangkan Anda memiliki sebuah pesan yang ingin Anda sembunyikan, seperti “HELLO WORLD”. Untuk mengenkripsi pesan ini dengan algoritma transposisi Rail Fence, Kita akan menggunakan sebuah pagar besi dengan beberapa tingkat atau baris (rails).\nMisalnya, jika Anda menggunakan 3 tingkat (rails), maka Anda akan menyusun pesan Anda dengan cara berikut:\nSekarang, Kita membaca huruf-huruf tersebut dari tingkat pertama ke tingkat terakhir:\nDengan Menggabungkan semua huruf-huruf ini, Kita akan mendapatkan pesan terenkripsi atau ciphertext: “HOR ELWLD LO”\nDekripsi: Membaca Pesan dari Pagar Besi\nSekarang, bayangkan seseorang menerima pesan terenkripsi “HOR ELWLD LO” dan ingin membacanya. Untuk mendekripsi pesan tersebut, mereka harus menggunakan pagar besi yang sama dengan jumlah tingkat yang sama (3 tingkat dalam contoh ini).\nSekarang, mereka bisa membaca pesan asli dengan mengikuti jalur dari tingkat pertama ke tingkat terakhir dan kembali:\nDengan menggabungkan semua huruf-huruf ini, mereka mendapatkan hasil dekripsi atau pesan asli : “HELLO WORLD”",
    "crumbs": [
      "Kriptografi Klasik",
      "8. Transposisi Route"
    ]
  },
  {
    "objectID": "8_transposisi_route.html#contoh-soal",
    "href": "8_transposisi_route.html#contoh-soal",
    "title": "8. Transposisi Route",
    "section": "Contoh Soal",
    "text": "Contoh Soal\nPlainteks   : UNIVERSITAS DIAN NUSWANTORO\nKunci       : 3 baris (spasi ditulis)\nLangkah mengerjakan :\n\nSusun huruf-huruf plainteks ke dalam pola zigzag menggunakan 3 baris\n\nketerangan : jika di plainteks ada spasi, maka spasi di tulis, contohnya setelah huruf S pada kata UNIVERSITAS ada pengosongan tempat itu adalah spasi.\nBaca huruf-huruf dari baris-baris tersebut secara berurutan dari baris atas ke baris bawah\n\nHasil Ciphertext : UETD WONVRIA INNSATRISSAUNO",
    "crumbs": [
      "Kriptografi Klasik",
      "8. Transposisi Route"
    ]
  },
  {
    "objectID": "8_transposisi_route.html#implementasi-pada-python",
    "href": "8_transposisi_route.html#implementasi-pada-python",
    "title": "8. Transposisi Route",
    "section": "Implementasi Pada Python",
    "text": "Implementasi Pada Python\nMasukkan Plaintext\nplainText = input(\"Plaintext : \")\nMasukkan Kunci atau Jumlah Baris\nrailFenceKey = int(input(\"Kunci: \"))\n\nProses Enkripsi\n\nMembuat Matriks Kosong Sesuai Dengan Jumlah Baris (kunci)\n\n   rails = [[' ' for _ in range(len(plainText))] for _ in \n   range(railFenceKey)]\n\nMenentukan Arah Pola Zig-Zag Dari Huruf-Huruf Dalam Plaintext, jika direction = 1 maka pola turun, jika -1 maka pola naik\n\n   i, j = 0, 0\n   direction = 1  \n\nMenempatkan karakter-karakter dari plainText ke dalam matriks dalam pola zigzag sesuai dengan kunci Rail Fence\n\n   for char in plainText:\n     rails[i][j] = char\n     if i == 0:\n       direction = 1\n     elif i == railFenceKey - 1:\n       direction = -1\n     i += direction\n     j += 1\nFor More Detail :\n\nfor char in plainText : Setiap karakter dalam teks yang ingin dienkripsi akan diproses satu per satu\nrails[i][j] = char : Karakter saat ini ditempatkan di baris [i] dan kolom [j] dari matriks rails\nif i == 0: direction = 1 : Jika berada di baris teratas, ubah arah pergerakan ke bawah\nelif i == railFenceKey - 1 : direction = -1: Jika berada di baris terbawah, ubah arah pergerakan ke atas\ni += direction : Indeks baris [i] ditambah atau dikurangi sesuai dengan arah pergerakan (ke bawah atau ke atas) Mengupdate indeks kolom [j] untuk pindah ke karakter berikutnya:\nj += 1 : Indeks kolom [j] selalu bertambah satu untuk setiap karakter\n\n\nMembentuk Teks Terenkripsi Berdasarkan Pola Zig-Zag\n\n   enkripsi_teks = '\\n'.join([''.join(row) for row in rails])\n   print(\"* RAIL FENCE: \")\n   print(enkripsi_teks)\nFore More Detail :\n\nrow merepresentasikan setiap baris dalam matriks rails.\n''.join(row) : Menggabungkan semua karakter dalam baris row menjadi satu string\nfor row in rails : Ini adalah list comprehension yang mengiterasi setiap baris dalam matriks rails\n'\\n'.join([...]) : Menggabungkan semua string dalam daftar hasil dari list comprehension di langkah sebelumnya menjadi satu string besar\n\n\nMempersiapkan daftar untuk setiap baris (rail) dan mengatur agar kita mulai dari baris pertama dengan pergerakan ke bawah.\n\n   rails = [[] for _ in range(railFenceKey)]\n   index = 0\n   direction = 1\nFor More Detail :\n\nrails = [[] for _ in range(railFenceKey)] : Membuat daftar berisi daftar kosong untuk setiap baris (rail) sesuai dengan jumlah baris yang ditentukan oleh railFenceKey\nindex = 0 : Menentukan bahwa kita mulai dari baris pertama (index 0).\ndirection = 1 : Menentukan bahwa pergerakan awalnya ke bawah (nilai 1).\n\n\nMenempatkan karakter-karakter dari plainText ke dalam daftar rails dalam pola zigzag, mengubah arah pergerakan ketika mencapai baris pertama atau terakhir\n\n   for char in plainText:\n     rails[index].append(char)\n     if index == 0:\n       direction = 1\n\n     elif index == railFenceKey - 1:\n       direction = -1\n\n     index += direction\nFor More Detail :\n\nfor char in plainText : Looping untuk Mengiterasi setiap karakter dalam plainText satu per satu\nrails[index].append(char) : Menambahkan karakter char ke daftar rails pada posisi index saat ini\nif index == 0: direction = 1 : Jika index adalah 0 (baris pertama), ubah arah pergerakan ke bawah (direction = 1)\nelif index == railFenceKey - 1: direction = -1 : Jika index adalah railFenceKey - 1 (baris terakhir), ubah arah pergerakan ke atas (direction = -1)\nindex += direction : Menambah atau mengurangi index sesuai dengan direction\n\n\nmenggabungkan karakter-karakter yang telah disusun dalam matriks rails menjadi satu string yang merupakan teks terenkripsi (ciphertext)\n\n   enkripsi_teks = \"\".join([\"\".join(rail) for rail in rails])\n   print(\"CIPHERTEXT : \" + enkripsi_teks)\nFor More Detail :\n\n[\"\".join(rail) for rail in rails] : List comprehension yang menghasilkan daftar string, di mana setiap string adalah satu baris dari matriks rails\n\"\".join([...]) : Menggabungkan semua string dalam daftar menjadi satu string besar tanpa pemisah\n\"\".join(rail) : Menggabungkan semua karakter dalam baris rail menjadi satu string\nHasilnya adalah satu string panjang yang merupakan teks terenkripsi (enkripsi_teks).\n\n   CIPHERTEXT : UETD WONVRIA INNSATRISSAUNO\n\n\nProses Dekripsi\n\nMempersiapkan daftar untuk setiap baris (rail) dan mengatur agar kita mulai dari baris pertama dengan pergerakan ke bawah\n\n   rails = [[] for _ in range(railFenceKey)]\n   index = 0\n   direction = 1\nFor More Detail :\n\nrails = [[] for _ in range(railFenceKey)]: Membuat daftar berisi daftar kosong untuk setiap baris (rail) sesuai dengan jumlah baris yang ditentukan oleh railFenceKey Membuat placeholder untuk menyiapkan “kotak-kotak” yang akan mengorganisir karakter-karakter terenkripsi sehingga dapat didekripsi kembali dengan benar\nindex = 0: Menentukan bahwa kita mulai dari baris pertama (index 0)\ndirection = 1: Menentukan bahwa pergerakan awalnya ke bawah (nilai 1)\n\n\nMempersiapkan tempat untuk karakter-karakter dari teks terenkripsi agar bisa ditempatkan di posisi yang benar selama proses dekripsi\n\n   for char in enkripsi_teks:\n     rails[index].append(None)\n     if index == 0:\n       direction = 1\n  \n     elif index == railFenceKey - 1:\n       direction = -1\n     index += direction\nFor More Detail :\n\nif index == 0: direction = 1 : Mengiterasi setiap karakter dalam enkripsi_teks satu persatu.\nelif index == railFenceKey - 1: direction = -1: Jika index adalah railFenceKey - 1 (baris terakhir), ubah arah pergerakan ke atas (direction = -1)\nindex += direction : Menambah atau mengurangi index sesuai dengan direction. Jika direction = 1 bergerak ke bawah sedangkan direction = -1 bergerak ke atas\n\n\nMenempatkan karakter-karakter dari teks terenkripsi kembali ke posisi yang benar dalam matriks rails, sesuai dengan placeholder (None) yang telah ditandai sebelumnya\n\n   index_char = 0\n   for rail in rails:\n     for i in range(len(rail)):\n       rail[i] = enkripsi_teks[index_char]\n       index_char += 1\nFor More Detail :\n\nindex_char : Melacak posisi karakter dalam enkripsi_teks.\nfor rail in rails : Looping untuk mengiterasi setiap baris dalam matriks rails.\nfor i in range(len(rail)): : Mengiterasi setiap posisi dalam baris rail yang memiliki placeholder.\nrail[i] = enkripsi_teks[index_char] : Menempatkan karakter dari enkripsi_teks pada posisi yang sesuai dalam rail.\nindex_char += 1 : Meningkatkan index_char untuk berpindah ke karakter berikutnya dalam enkripsi_teks.\n\n\nMembaca kembali karakter-karakter dari matriks rails dalam urutan zigzag yang benar dan menyusunnya menjadi teks asli\n\n   index = 0\n   direction = 1\n   dekripsi_teks = []\nFor More Detail :\n\nindex : Melacak baris saat ini dalam matriks rails\ndirection : Menentukan arah pergerakan (ke bawah atau ke atas)\ndekripsi_teks = [] : Daftar yang akan menyimpan karakter karakter teks asli dalam urutan yang benar.\n\n\nMembaca kembali karakter-karakter dari matriks rails dalam urutan zigzag yang benar dan menyusunnya menjadi teks asli\n\n    for _ in range(len(enkripsi_teks)):\n      dekripsi_teks.append(rails[index].pop(0))\n      if index == 0:\n        direction = 1\n\n      elif index == railFenceKey - 1:\n        direction = -1\n      index += direction\nFor More Detail :\n\nfor _ in range(len(enkripsi_teks)): : Mengiterasi sebanyak panjang enkripsi_teks untuk memastikan semua karakter diproses.\ndekripsi_teks.append(rails[index]) : Mengambil karakter pertama dari baris index dalam rails dan menambahkannya ke dekripsi_teks\n.pop(0) : pop(0) menghapus dan mengembalikan elemen pertama dari baris index\nif index == 0: direction = 1 : Jika index adalah 0 (baris pertama), ubah arah pergerakan ke bawah (direction = 1)\nelif index == railFenceKey - 1: direction = -1 : Jika index adalah railFenceKey - 1 (baris terakhir), ubah arah pergerakan ke atas (direction = -1)\nindex += direction: Mengupdate indeks baris\n\n\nMenggabungkan karakter-karakter yang telah disusun kembali dalam dekripsi_teks menjadi satu string yang merupakan teks asli hasil dekripsi\n\n   railFenceDecryption = \"\".join(dekripsi_teks)\n   print(\" DECRYPTED : \" + railFenceDecryption)\nFor More Detail :\n\n''.join(dekripsi_teks) : Menggabungkan semua elemen dalam dekripsi_teks menjadi satu string tanpa pemisah.\nVariabel railFenceDecryption akan menyimpan string hasil dek\n\nHASIL DECRYPTED : UNIVERSITAS DIAN NUSWANTORO",
    "crumbs": [
      "Kriptografi Klasik",
      "8. Transposisi Route"
    ]
  },
  {
    "objectID": "7_transposisi_rail_fence.html",
    "href": "7_transposisi_rail_fence.html",
    "title": "7. Transposisi Rail Fence",
    "section": "",
    "text": "Analogi Transposisi Railfence\nMari kita analogikan transposisi railfence dengan menyusun pesan di pagar besi sebagai proses enkripsinya dan membaca pesan tersembunyi dalam sebuah pagar besi sebagai proses dekripsinya\nEnkripsi: Menyusun Pesan di Pagar Besi\nBayangkan Anda memiliki sebuah pesan yang ingin Anda sembunyikan, seperti “HELLO WORLD”. Untuk mengenkripsi pesan ini dengan algoritma transposisi Rail Fence, Kita akan menggunakan sebuah pagar besi dengan beberapa tingkat atau baris (rails).\nMisalnya, jika Anda menggunakan 3 tingkat (rails), maka Anda akan menyusun pesan Anda dengan cara berikut:\nSekarang, Kita membaca huruf-huruf tersebut dari tingkat pertama ke tingkat terakhir:\nDengan Menggabungkan semua huruf-huruf ini, Kita akan mendapatkan pesan terenkripsi atau ciphertext: “HOR ELWLD LO”\nDekripsi: Membaca Pesan dari Pagar Besi\nSekarang, bayangkan seseorang menerima pesan terenkripsi “HOR ELWLD LO” dan ingin membacanya. Untuk mendekripsi pesan tersebut, mereka harus menggunakan pagar besi yang sama dengan jumlah tingkat yang sama (3 tingkat dalam contoh ini).\nSekarang, mereka bisa membaca pesan asli dengan mengikuti jalur dari tingkat pertama ke tingkat terakhir dan kembali:\nDengan menggabungkan semua huruf-huruf ini, mereka mendapatkan hasil dekripsi atau pesan asli : “HELLO WORLD”",
    "crumbs": [
      "Kriptografi Klasik",
      "7. Transposisi Rail Fence"
    ]
  },
  {
    "objectID": "7_transposisi_rail_fence.html#contoh-soal",
    "href": "7_transposisi_rail_fence.html#contoh-soal",
    "title": "7. Transposisi Rail Fence",
    "section": "Contoh Soal",
    "text": "Contoh Soal\nPlainteks   : UNIVERSITAS DIAN NUSWANTORO\nKunci       : 3 baris (spasi ditulis)\nLangkah mengerjakan :\n\nSusun huruf-huruf plainteks ke dalam pola zigzag menggunakan 3 baris\n\nketerangan : jika di plainteks ada spasi, maka spasi di tulis, contohnya setelah huruf S pada kata UNIVERSITAS ada pengosongan tempat itu adalah spasi.\nBaca huruf-huruf dari baris-baris tersebut secara berurutan dari baris atas ke baris bawah\n\nHasil Ciphertext : UETD WONVRIA INNSATRISSAUNO",
    "crumbs": [
      "Kriptografi Klasik",
      "7. Transposisi Rail Fence"
    ]
  },
  {
    "objectID": "7_transposisi_rail_fence.html#implementasi-pada-python",
    "href": "7_transposisi_rail_fence.html#implementasi-pada-python",
    "title": "7. Transposisi Rail Fence",
    "section": "Implementasi Pada Python",
    "text": "Implementasi Pada Python\nMasukkan Plaintext\nplainText = input(\"Plaintext : \")\nMasukkan Kunci atau Jumlah Baris\nrailFenceKey = int(input(\"Kunci: \"))\n\nProses Enkripsi\n\nMembuat Matriks Kosong Sesuai Dengan Jumlah Baris (kunci)\n\n   rails = [[' ' for _ in range(len(plainText))] for _ in \n   range(railFenceKey)]\n\nMenentukan Arah Pola Zig-Zag Dari Huruf-Huruf Dalam Plaintext, jika direction = 1 maka pola turun, jika -1 maka pola naik\n\n   i, j = 0, 0\n   direction = 1  \n\nMenempatkan karakter-karakter dari plainText ke dalam matriks dalam pola zigzag sesuai dengan kunci Rail Fence\n\n   for char in plainText:\n     rails[i][j] = char\n     if i == 0:\n       direction = 1\n     elif i == railFenceKey - 1:\n       direction = -1\n     i += direction\n     j += 1\nFor More Detail :\n\nfor char in plainText : Setiap karakter dalam teks yang ingin dienkripsi akan diproses satu per satu\nrails[i][j] = char : Karakter saat ini ditempatkan di baris [i] dan kolom [j] dari matriks rails\nif i == 0: direction = 1 : Jika berada di baris teratas, ubah arah pergerakan ke bawah\nelif i == railFenceKey - 1 : direction = -1: Jika berada di baris terbawah, ubah arah pergerakan ke atas\ni += direction : Indeks baris [i] ditambah atau dikurangi sesuai dengan arah pergerakan (ke bawah atau ke atas) Mengupdate indeks kolom [j] untuk pindah ke karakter berikutnya:\nj += 1 : Indeks kolom [j] selalu bertambah satu untuk setiap karakter\n\n\nMembentuk Teks Terenkripsi Berdasarkan Pola Zig-Zag\n\n   enkripsi_teks = '\\n'.join([''.join(row) for row in rails])\n   print(\"* RAIL FENCE: \")\n   print(enkripsi_teks)\nFore More Detail :\n\nrow merepresentasikan setiap baris dalam matriks rails.\n''.join(row) : Menggabungkan semua karakter dalam baris row menjadi satu string\nfor row in rails : Ini adalah list comprehension yang mengiterasi setiap baris dalam matriks rails\n'\\n'.join([...]) : Menggabungkan semua string dalam daftar hasil dari list comprehension di langkah sebelumnya menjadi satu string besar\n\n\nMempersiapkan daftar untuk setiap baris (rail) dan mengatur agar kita mulai dari baris pertama dengan pergerakan ke bawah.\n\n   rails = [[] for _ in range(railFenceKey)]\n   index = 0\n   direction = 1\nFor More Detail :\n\nrails = [[] for _ in range(railFenceKey)] : Membuat daftar berisi daftar kosong untuk setiap baris (rail) sesuai dengan jumlah baris yang ditentukan oleh railFenceKey\nindex = 0 : Menentukan bahwa kita mulai dari baris pertama (index 0).\ndirection = 1 : Menentukan bahwa pergerakan awalnya ke bawah (nilai 1).\n\n\nMenempatkan karakter-karakter dari plainText ke dalam daftar rails dalam pola zigzag, mengubah arah pergerakan ketika mencapai baris pertama atau terakhir\n\n   for char in plainText:\n     rails[index].append(char)\n     if index == 0:\n       direction = 1\n\n     elif index == railFenceKey - 1:\n       direction = -1\n\n     index += direction\nFor More Detail :\n\nfor char in plainText : Looping untuk Mengiterasi setiap karakter dalam plainText satu per satu\nrails[index].append(char) : Menambahkan karakter char ke daftar rails pada posisi index saat ini\nif index == 0: direction = 1 : Jika index adalah 0 (baris pertama), ubah arah pergerakan ke bawah (direction = 1)\nelif index == railFenceKey - 1: direction = -1 : Jika index adalah railFenceKey - 1 (baris terakhir), ubah arah pergerakan ke atas (direction = -1)\nindex += direction : Menambah atau mengurangi index sesuai dengan direction\n\n\nmenggabungkan karakter-karakter yang telah disusun dalam matriks rails menjadi satu string yang merupakan teks terenkripsi (ciphertext)\n\n   enkripsi_teks = \"\".join([\"\".join(rail) for rail in rails])\n   print(\"CIPHERTEXT : \" + enkripsi_teks)\nFor More Detail :\n\n[\"\".join(rail) for rail in rails] : List comprehension yang menghasilkan daftar string, di mana setiap string adalah satu baris dari matriks rails\n\"\".join([...]) : Menggabungkan semua string dalam daftar menjadi satu string besar tanpa pemisah\n\"\".join(rail) : Menggabungkan semua karakter dalam baris rail menjadi satu string\nHasilnya adalah satu string panjang yang merupakan teks terenkripsi (enkripsi_teks).\n\n   CIPHERTEXT : UETD WONVRIA INNSATRISSAUNO\n\n\nProses Dekripsi\n\nMempersiapkan daftar untuk setiap baris (rail) dan mengatur agar kita mulai dari baris pertama dengan pergerakan ke bawah\n\n   rails = [[] for _ in range(railFenceKey)]\n   index = 0\n   direction = 1\nFor More Detail :\n\nrails = [[] for _ in range(railFenceKey)]: Membuat daftar berisi daftar kosong untuk setiap baris (rail) sesuai dengan jumlah baris yang ditentukan oleh railFenceKey Membuat placeholder untuk menyiapkan “kotak-kotak” yang akan mengorganisir karakter-karakter terenkripsi sehingga dapat didekripsi kembali dengan benar\nindex = 0: Menentukan bahwa kita mulai dari baris pertama (index 0)\ndirection = 1: Menentukan bahwa pergerakan awalnya ke bawah (nilai 1)\n\n\nMempersiapkan tempat untuk karakter-karakter dari teks terenkripsi agar bisa ditempatkan di posisi yang benar selama proses dekripsi\n\n   for char in enkripsi_teks:\n     rails[index].append(None)\n     if index == 0:\n       direction = 1\n  \n     elif index == railFenceKey - 1:\n       direction = -1\n     index += direction\nFor More Detail :\n\nif index == 0: direction = 1 : Mengiterasi setiap karakter dalam enkripsi_teks satu persatu.\nelif index == railFenceKey - 1: direction = -1: Jika index adalah railFenceKey - 1 (baris terakhir), ubah arah pergerakan ke atas (direction = -1)\nindex += direction : Menambah atau mengurangi index sesuai dengan direction. Jika direction = 1 bergerak ke bawah sedangkan direction = -1 bergerak ke atas\n\n\nMenempatkan karakter-karakter dari teks terenkripsi kembali ke posisi yang benar dalam matriks rails, sesuai dengan placeholder (None) yang telah ditandai sebelumnya\n\n   index_char = 0\n   for rail in rails:\n     for i in range(len(rail)):\n       rail[i] = enkripsi_teks[index_char]\n       index_char += 1\nFor More Detail :\n\nindex_char : Melacak posisi karakter dalam enkripsi_teks.\nfor rail in rails : Looping untuk mengiterasi setiap baris dalam matriks rails.\nfor i in range(len(rail)): : Mengiterasi setiap posisi dalam baris rail yang memiliki placeholder.\nrail[i] = enkripsi_teks[index_char] : Menempatkan karakter dari enkripsi_teks pada posisi yang sesuai dalam rail.\nindex_char += 1 : Meningkatkan index_char untuk berpindah ke karakter berikutnya dalam enkripsi_teks.\n\n\nMembaca kembali karakter-karakter dari matriks rails dalam urutan zigzag yang benar dan menyusunnya menjadi teks asli\n\n   index = 0\n   direction = 1\n   dekripsi_teks = []\nFor More Detail :\n\nindex : Melacak baris saat ini dalam matriks rails\ndirection : Menentukan arah pergerakan (ke bawah atau ke atas)\ndekripsi_teks = [] : Daftar yang akan menyimpan karakter karakter teks asli dalam urutan yang benar.\n\n\nMembaca kembali karakter-karakter dari matriks rails dalam urutan zigzag yang benar dan menyusunnya menjadi teks asli\n\n    for _ in range(len(enkripsi_teks)):\n      dekripsi_teks.append(rails[index].pop(0))\n      if index == 0:\n        direction = 1\n\n      elif index == railFenceKey - 1:\n        direction = -1\n      index += direction\nFor More Detail :\n\nfor _ in range(len(enkripsi_teks)): : Mengiterasi sebanyak panjang enkripsi_teks untuk memastikan semua karakter diproses.\ndekripsi_teks.append(rails[index]) : Mengambil karakter pertama dari baris index dalam rails dan menambahkannya ke dekripsi_teks\n.pop(0) : pop(0) menghapus dan mengembalikan elemen pertama dari baris index\nif index == 0: direction = 1 : Jika index adalah 0 (baris pertama), ubah arah pergerakan ke bawah (direction = 1)\nelif index == railFenceKey - 1: direction = -1 : Jika index adalah railFenceKey - 1 (baris terakhir), ubah arah pergerakan ke atas (direction = -1)\nindex += direction: Mengupdate indeks baris\n\n\nMenggabungkan karakter-karakter yang telah disusun kembali dalam dekripsi_teks menjadi satu string yang merupakan teks asli hasil dekripsi\n\n   railFenceDecryption = \"\".join(dekripsi_teks)\n   print(\" DECRYPTED : \" + railFenceDecryption)\nFor More Detail :\n\n''.join(dekripsi_teks) : Menggabungkan semua elemen dalam dekripsi_teks menjadi satu string tanpa pemisah.\nVariabel railFenceDecryption akan menyimpan string hasil dek\n\nHASIL DECRYPTED : UNIVERSITAS DIAN NUSWANTORO",
    "crumbs": [
      "Kriptografi Klasik",
      "7. Transposisi Rail Fence"
    ]
  }
]