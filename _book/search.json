[
  {
    "objectID": "2_monoalphabetic_random_key.html",
    "href": "2_monoalphabetic_random_key.html",
    "title": "2. Monoalphabetic Random Key",
    "section": "",
    "text": "Analogi Transposisi Kolom\nBayangkan Kita memiliki rak buku dengan beberapa kolom dan setiap kolom berisi tumpukan buku.\nDengan kata lain, transposisi kolom mengubah urutan kolom tanpa mengubah isi kolom. Dalam kriptografi, ini dilakukan untuk mengacak data agar lebih sulit ditebak oleh pihak yang tidak berwenang.",
    "crumbs": [
      "Kriptografi Klasik",
      "2. Monoalphabetic Random Key"
    ]
  },
  {
    "objectID": "2_monoalphabetic_random_key.html#implementasi-pada-python",
    "href": "2_monoalphabetic_random_key.html#implementasi-pada-python",
    "title": "2. Monoalphabetic Random Key",
    "section": "Implementasi Pada Python",
    "text": "Implementasi Pada Python\nMasukkan plaintext\nplainText = input(\"Plaintext : \")\nMasukkan kunci\nkey = input(\"masukkan kunci : \")\nMembersihkan teks dari spasi ganda\ncleanPlainTeks = plainTeks.replace(\" \", \"\")\nprint(cleanPlainTeks)\nDeklarasi urutan huruf dalam alfabet\nascii = {\n'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8, 'i': 9, 'j': 10, 'k': 11, \n'l': 12, 'm': 13, 'n': 14, 'o': 15, 'p': 16, 'q': 17, 'r': 18, 's': 19, 't': 20, 'u': 21, \n'v': 22, 'w': 23, 'x': 24, 'y': 25, 'z': 26\n}\n\nProses Enkripsi\nInisialisasi list untuk menyimpan urutan numerik dari setiap huruf alfabet\nkolom = 0\nangka_urutan = []\nMengonversi setiap huruf dalam kata kunci menjadi urutan numeriknya sesuai dengan posisi dalam alfabet\nfor huruf in key:\n    if huruf.isalpha():\n        angka_urutan.append(ascii[huruf.lower()])\n        kolom = kolom+1\n        cleanKey = angka_urutan\n\nprint(f\"Urutan kunci dari kata '{key}' adalah {angka_urutan}\")\nFor More Detail :\n\nfor huruf in key : Loop ini digunakan untuk memeriksa setiap huruf dalam variabel key, yang diharapkan merupakan kata kunci yang diberikan oleh pengguna\nif huruf.isalpha() : Kondisi ini memastikan bahwa hanya karakter alfabet yang akan diproses. Karakter non-alfabet akan dilewati\n`huruf.lower(): Mengubah huruf menjadi huruf kecil untuk konsistensi, sehingga tidak ada perbedaan antara huruf besar dan kecil\nascii[huruf.lower()] : Mengambil nilai urutan numerik dari huruf. Di sini diasumsikan ada sebuah kamus (dictionary) bernama ascii yang memetakan setiap huruf ke urutan numeriknya\nangka_urutan.append(...) : Menambahkan urutan numerik dari huruf ke dalam list angka_urutan\nkolom = kolom + 1 : Menghitung jumlah kolom dengan menambah nilai kolom setiap kali huruf diproses\ncleanKey = angka_urutan : Menyimpan hasil akhir urutan numerik ke dalam variabel cleanKey\n\nMembuat sebuah matriks kosong untuk menyimpan teks yang telah diolah dalam bentuk matriks\nmatrix = []\nMenghitung panjang dari teks yang telah dibersihkan dan disimpan dalam variabel cleanPlainTeks\npanjang = len(cleanPlainTeks)\nMencari tahu berapa kali kolom dapat digunakan untuk memuat seluruh teks, dengan membagi panjang teks dengan jumlah kolom\ntemp = panjang/kolom\nMembulatkan hasil pembagian sebelumnya ke bilangan bulat terdekat\nbulat = round(temp)\nMenghitung jumlah baris untuk memuat teks dalam matriks\nif temp - bulat == 0:\n    baris = bulat\nelse:\n    if temp - bulat &lt; 0:\n        baris = bulat\n    else:\n        baris = bulat + 1\nprint(baris)\nFor More Detail :\n\ntemp : hasil pembagian panjang teks dengan jumlah kolom\nbulat: hasil pembagian yang dibulatkan ke bilangan bulat terdekat. Jika temp adalah bilangan bulat (tidak ada sisa), jumlah baris adalah bulat. Jika ada sisa, jumlah baris adalah bulat + 1\n\nMengisi matriks dengan karakter dari teks yang telah dibersihkan (cleanPlainTeks)\nfor i in range(baris):\n    row = []\n    for j in range(kolom):\n        if i * kolom + j &lt; len(cleanPlainTeks):\n            elemen = cleanPlainTeks[i * kolom + j]\n        else:\n            elemen = \" \"\n        row.append(elemen)\n    matrix.append(row)\nFor More Detail :\n\nfor i in range(baris) : Loop untuk setiap baris dalam matriks\nrow = [] : Inisialisasi list kosong untuk setiap baris\nif i * kolom + j &lt; len(cleanPlainTeks) : Memeriksa apakah indeks saat ini berada dalam rentang panjang teks yang dibersihkan.\nelemen = cleanPlainTeks[i * kolom + j] : Jika indeks berada dalam rentang, maka ambil karakter dari cleanPlainTeks berdasarkan indeks yang dihitung.\nelse : Jika indeks melebihi panjang teks, isi elemen dengan spasi.\nrow.append(elemen) : Menambahkan elemen ke dalam baris.\nmatrix.append(row) : Menambahkan baris yang telah diisi ke dalam matriks.`\n\nMencetak matriks\nprint(\"Matriks yang Anda buat:\")\nfor row in matrix:\n    print(row)\nMentransposisikan matriks yang telah dibuat dan kemudian mencetak matriks yang telah ditransposisikan\ntransposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\nfor row in transposed_matrix:\n    print(row)\nFor More Detail :\n\nfor i in range(len(matrix[0])) : Iterasi melalui indeks kolom matriks asli\nrow[i] for row in matrix : Untuk setiap indeks kolom i, ambil elemen i dari setiap baris dalam matriks asli dan akan menghasilkan kolom baru dari elemen-elemen tersebut, membentuk baris baru di matriks yang ditransposisikan\n\nMembuat list kosong dengan panjang yang sama dengan cleanKey untuk menyimpan urutan indeks\norder = [None] * len(cleanKey)\nMengurutkan elemen-elemen dalam cleanKey berdasarkan nilai terkecil hingga terbesar\ni = 0\nwhile len(cleanKey) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, cleanKey))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = cleanKey.index(nilai_terkecil)\n\n        order[marker] = i\n        cleanKey[marker] = None \n        i = i + 1\n    else:\n        break\nprint(order)\nFor More Detail :\n\ni = 0 : Inisialisasi counter i\nwhile len(cleanKey) &gt; 0 : Loop hingga cleanKey kosong (semua elemen None)\nnon_none_values = list(filter(lambda x: x is not None, cleanKey)) : Membuat list yang hanya berisi elemen-elemen cleanKey yang bukan None\nif non_none_values : Mengecek apakah list non_none_values tidak kosong nilai_terkecil = min(non_none_values) : Mencari nilai terkecil dari non_none_values\nmarker = cleanKey.index(nilai_terkecil) : Mendapatkan indeks dari nilai terkecil dalam cleanKey Menyimpan Urutan dan Menghapus Nilai Terkecil:\norder[marker] = i : Menyimpan urutan i pada indeks marker di list order\ncleanKey[marker] = None : Menghapus nilai terkecil dari cleanKey dengan mengubahnya menjadi None\ni = i + 1 : Increment counter i.\n\nMengubah urutan kolom matriks transposed_matrix berdasarkan urutan yang telah diatur dalam order, dan kemudian mencetak matriks yang sudah diubah urutan kolomnya\nnew_matrix = []\nwhile len(order) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, order))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = order.index(nilai_terkecil)\n       \n        new_matrix.append(transposed_matrix[marker])\n        order[marker] = None\n    else:\n        break\n\nfor row in new_matrix:\n    print(row)\nFor More Detail :\n\nnew_matrix = [] : Membuat list kosong new_matrix untuk menampung baris-baris matriks yang baru diurutkan Looping untuk Mengubah Urutan Kolom:\nwhile len(order) &gt; 0 : Melakukan looping selama masih ada elemen yang tersisa dalam order\nnon_none_values = list(filter(lambda x: x is not None, order)) : Membuat list non_none_values yang hanya berisi nilai-nilai yang bukan None dari order\nif non_none_values : Memeriksa apakah non_none_values tidak kosong\nnilai_terkecil = min(non_none_values) : Menemukan nilai terkecil dari non_none_values\nmarker = order.index(nilai_terkecil) : Mencari indeks dari nilai_terkecil dalam order\nnew_matrix.append(transposed_matrix[marker]) : Menambahkan baris dari transposed_matrix yang sesuai dengan marker ke new_matrix\norder[marker] = None : Menghapus nilai yang telah diproses dengan mengubahnya menjadi None\nelse: break : Menghentikan loop jika non_none_values kosong, yang berarti semua nilai dalam order telah diproses\n\nMengonversi matriks new_matrix menjadi string tunggal dengan menggabungkan nilai-nilainya secara berurutan dan menghapus spasi ekstra di akhir string\nresult_string = \"\"\n\nfor row in new_matrix:\n    for value in row:\n        result_string += str(value)\n\nresult_string = result_string.strip()\n\nprint(result_string)\nFor More Detail :\n\nresult_string = \"\" : Inisialisasi string kosong result_string yang akan digunakan untuk menyimpan hasil akhir\nfor row in new_matrix: : Melakukan iterasi melalui setiap baris dalam new_matrix\nfor value in row: : Melakukan iterasi melalui setiap nilai dalam baris row\nresult_string += str(value) : Mengonversi nilai value menjadi string (jika belum string) dan menambahkannya ke result_string\nresult_string = result_string.strip() : Menghapus spasi ekstra di awal dan akhir string menggunakan metode strip()\n\nHasil Ciphertext : ENTKFINOKKM TIAIRA\n\n\nProses Dekripsi\ncipherTeks = input(\"masukkan kata : \")\nkey = input(\"masukkan kunci : \")\ncleanCipherTeks = cipherTeks.replace(\" \", \" \")\nprint(cleanCipherTeks)\nkolom = 0\nangka_urutan = []\nfor huruf in key:\n    if huruf.isalpha():\n        angka_urutan.append(ascii[huruf.lower()])\n        kolom = kolom+1\n        cleanKey = angka_urutan\n\nprint(f\"Urutan kunci dari kata '{key}' adalah: {angka_urutan}\")\nmatrix = []\npanjang = len(cleanCipherTeks)\ntemp = panjang/kolom\nbaris = round(temp)\nprint(baris)\nfor i in range(baris):\n    row = []\n    for j in range(kolom):\n        if i * kolom + j &lt; len(cleanCipherTeks):\n            elemen = cleanCipherTeks[i + baris * j]\n        else:\n            elemen = \"a\"\n        row.append(elemen)\n    matrix.append(row)\nprint(\"Matriks yang Anda buat:\")\nfor row in matrix:\n    print(row)\ntransposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\nfor row in transposed_matrix:\n    print(row)\norder = [None] * len(cleanKey)\ni = 0\nwhile len(cleanKey) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, cleanKey))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = cleanKey.index(nilai_terkecil)\n        order[marker] = i\n        cleanKey[marker] = None  \n        i = i + 1\n    else:\n        break\nprint(order)\ntransposed_matrix = [transposed_matrix[i] for i in order]\n\nfor row in transposed_matrix:\n    print(row)\nmatriks = [[row[i] for row in transposed_matrix] for i in range(len(transposed_matrix[0]))]\nfor row in matriks:\n    print(row)\nresult_string = \"\"\n\nfor row in matriks:\n    for value in row:\n        result_string += str(value)\n\nresult_string = result_string.strip()\n\nprint(result_string)\nHasil Dekripsi : TEKNIKINFORMATIKA\nPerbedaan Proses :\n\nEnkripsi: Teks asli diubah menjadi matriks berdasarkan kolom kunci, kemudian kolom-kolom diurutkan berdasarkan kunci. Pada enkripsi, transposed_matrix adalah matriks transposisi dari matrix awal\nDekripsi: Teks sandi diubah menjadi matriks berdasarkan kolom kunci, kemudian baris-baris diurutkan berdasarkan kunci untuk mengembalikan teks asli. Pada dekripsi, transposed_matrix diurutkan berdasarkan order untuk mengembalikan teks asli",
    "crumbs": [
      "Kriptografi Klasik",
      "2. Monoalphabetic Random Key"
    ]
  },
  {
    "objectID": "4_playfair.html",
    "href": "4_playfair.html",
    "title": "4. Playfair",
    "section": "",
    "text": "Prinsip Dasar",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Playfair"
    ]
  },
  {
    "objectID": "4_playfair.html#pengenalan-responsive-web-design",
    "href": "4_playfair.html#pengenalan-responsive-web-design",
    "title": "4. Playfair",
    "section": "",
    "text": "Responsive Web\n\n\n\n\n&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n\n\n\n\n&lt;img src=\"images.jpg\" style=\"width:100%;\"&gt;\n\n\n&lt;h1 style=\"font-size:10vw\"&gt;Hello World&lt;/h1&gt;",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Playfair"
    ]
  },
  {
    "objectID": "4_playfair.html#responsive-web-design-framework-bootstrap",
    "href": "4_playfair.html#responsive-web-design-framework-bootstrap",
    "title": "4. Playfair",
    "section": "Responsive Web Design Framework (Bootstrap)",
    "text": "Responsive Web Design Framework (Bootstrap)\nBootstrap merupakan HTML, CSS dan Javascript framework paling popular untuk mengambangkan responsive web design yang mengutamakan tampilan mobile (mobile first) Bootstrap dapat diunduh secara gratis pada laman https://getbootstrap.com/. Sampai saat modul ini dibuat versi terakhir adalah Bootstrap v5.3.\n\nMengapa menggunakan Bootstrap?\nBanyak keuntungan dan kemudahan yang diberikan Bootstrap diantaranya adalah: \nBerikut adalah beberapa penjelasan mengenai Bootstrap: \n\nResponsif: Salah satu fitur utama Bootstrap adalah kemampuannya untuk menghasilkan tampilan yang responsif secara otomatis. Dengan menggunakan class CSS yang telah disediakan oleh Bootstrap, elemen-elemen halaman web dapat menyesuaikan diri dengan baik pada berbagai perangkat dan ukuran layar, mulai dari desktop hingga perangkat mobile.\nGrid System: Bootstrap menyediakan sistem grid yang fleksibel untuk membagi layout halaman web menjadi kolom-kolom yang responsif. Grid system ini memungkinkan pengaturan layout yang mudah dan dapat diatur untuk menciptakan tampilan yang rapi dan terstruktur pada berbagai perangkat.\nKomponen Siap Pakai: Bootstrap menyediakan beragam komponen UI siap pakai seperti tombol, navigasi, formulir, jumbotron, kartu, jendela modal, dan banyak lagi. Komponen ini telah dirancang dengan baik dan dapat langsung digunakan dalam proyek tanpa perlu memikirkan desain atau gaya dasar, menghemat waktu dan usaha pengembangan.\nGaya dan Tema: Bootstrap memiliki gaya dan tema default yang estetis dan modern. Selain itu, Bootstrap juga menyediakan beragam tema kustom yang dapat diterapkan dengan mudah untuk memberikan tampilan yang unik dan sesuai dengan kebutuhan proyek Anda. Anda juga dapat menyesuaikan gaya dan tema Bootstrap sesuai dengan preferensi Anda sendiri.\nKompatibilitas Browser: Bootstrap dirancang untuk mendukung sebagian besar browser modern. Ini berarti tampilan dan fungsionalitas situs web yang dibangun dengan menggunakan Bootstrap akan konsisten dan berfungsi dengan baik di berbagai browser yang umum digunakan.\nDokumentasi dan Komunitas: Bootstrap memiliki dokumentasi yang sangat baik, lengkap dengan contoh-contoh kode dan penjelasan yang rinci. Selain itu, karena popularitasnya, Bootstrap memiliki komunitas pengembang yang besar dan aktif, yang dapat memberikan dukungan dan sumber daya yang berguna untuk menjawab pertanyaan, memecahkan masalah, dan berbagi pengalaman.\n\n\n\n\nHTML5\nPenambahan doctype dilakukan untuk menetapkan dokumen HTML sebagai HTML versi 5 (HTML5), agar dapat menggunakan elemen-elemen HTML5 dan properti CSS Bootstrap. Sebagai contohnya pada script berikut. \n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\n&lt;/html&gt;\n\nJika menggunakan Text Editor Visual Studio Code, ketika mengetikan html di awal kode maka akan muncul snippets yang memunculkan beberapa pilihan template kode \n\n\n\nSnippets\n\n\n\n\nGrid System\nPada Bootstrap menerapkan grid system dengan 12 (dua belas) kolom pada setiap halaman. Jika kita tidak menginginkan layout menggunakan ke-12 kolom, kita bisa mengelompokkan kolom bersama untuk membuat kolom yang lebih lebar. Sebagai contoh gambaran dari grid system dengan 12 kolom ditampilkan seperti pada gambar di bawah ini. \n\n\n\nContoh Grid System Bootstrap\n\n\n Sistem grid pada bootstrap dapat menyesuaikan terhadap enam keadaan atau ukuran diantaranya adalah : \n\nEkstra kecil atau extra small (xs)\nKecil atau small (sm)\nSedang atau medium (md)\nBesar atau large (lg)\nEkstra besar atau extra large (xl)\nEkstra ekstra besar atau extra extra large (xxl) \n\n\n\n\nTabel Breakpoint Grid\n\n\n\n\nFungsi Bootsrtap yang umum digunakan\n\nGrid  Seperti yang telah dijelaskan pada Grid System, bahwa pada bootstrap dapat mengelompokkan layout menjadi 12 kolom, dimana kita dapat menggunakan grid ini dengan kelas row yang didalamnya terdapat kelas col, seperti berikut:\n&lt;div class=\"row\"&gt;\n    &lt;div class=\"col\"&gt;&lt;/div&gt;\n    ...\n&lt;/div&gt;&lt;!-- row--&gt;\n Dalam kelas col ini dapat dituliskan dengan value seperti col-4, yang artinya objek yang diberikan kelas tersebut pada row atau baris akan mengisi sebanyak 4 kolom. Dalam 1 row tersebut dapat berisi dengan akumulai 12 kolom.  Selain iitu juga bisa dikombinasikan dengan class breakpoint. Pada seperti yang dijelaskan pada tabel penjelasan grid system bahwa kolom akan mengikuti ukuran breakppoint dari device yang dimasukkan. Misalkan col-md-4, maka ketika ukuran dari device yang digunakan lebih besar dari atau sama dengan 768px maka tampilan kolom akan mendatar memenuhi row, namun akan berubah tampilannya jika ukuran devicenya berkurang 1 pixel saja (kurang dari 768px).\nWarna  Terdapat beberapa template kelas warna yang disediakan oleh Bootstrap diantaranya \n\nPrimary: (Biru tua)\nSecondary: (Abu-abu)\nSuccess: (Hijau)\nDanger: (Merah)\nWarning: (Kuning)\nInfo: (Biru cerah)\nLight: (Putih atau hampir putih)\nDark: (Hitam atau hampir hitam) \n\nPemilihan warna juga merupakan hal yang sangat penting dan perlu diperhatikan.Pemilihan warna akan sangat berpengaruh pada tampilan atau UI sehingga akan mempercantik tampilan dan menarik bagi user. Selain itu dengan warna yang sesuai akan membantu menyampaikan fungsi dari fitur, misalnya merah menandakan suatu yang penting yang memerlukan perhatian lebih, hal tersebut akan memudahkan konsumen dalam menggunakan aplikasi atau disebut user experience\nTypografi  Dalam cara penulisan pada bootstrap memberikan kemudahan dalam mengatur tampilan teks, melalui beberapa class, seperti \n\nHeading, selain menggunakan tag &lt;h1&gt;,&lt;h2&gt;,..,&lt;h6&gt; pada bootstrap juga terdapat kelas heading contohnya:\n&lt;p class=\"h1\"&gt;Heading 1&lt;p&gt;\nDisplay, dengan manambahkan class display pada teks akan memberikan tampilan teks yang besar namun dengan style font yang tipis, misalnya: \n&lt;p class=\"display-1\"&gt;Display 1&lt;/p&gt;\nFont Size, class font size atau yang ditulis fs memberikan styling berupa ukuran dari teks dimana semakin besar nilai fs akan semakin kecil font yang ditampilkan: \n&lt;p class=\"fs-1\"&gt;ini teks&lt;/p&gt;\nFont Weight, melalui font weight dapat memberikan pengaturan terhadap tebal tipis dari font atau teks, dengan parameter bolder, bold, light, lighter, dan normal, berikut contoh penggunaannya: \n&lt;p class=\"fw-bold\"&gt;Ini tebal&lt;/p&gt;\nFont Style, dengan font style kita dapat merubah style dari font atau teks bold dan italic tanpa menggunakan tag html &lt;b&gt; dan &lt;i&gt;, atau sebagai berikut: \n&lt;p class=\"fst-italic\"&gt;ini font style&lt;/p&gt;\n&lt;p class=\"fst-normal\"&gt;ini font style&lt;/p&gt;\n\nSpacing & Sizing \nPengaturan Spasi dan ukuran pada Bootstrap dapat menggunakan padding dan margin, Padding merupakan bagian yang membatasi konten dengan border, sedangkan margin merupakkan bagian yang membatasi antara border dengan bagian luar dari konten. Pengaturan margin dan padding dapat dilakukan dengan mudah hanya dengan menambahkan class m untuk margin dan p untuk padding yang diikuti dengan parameter t (top), b (bottom), s (start), e (end), x (menambahkan pada kedua sis horizontal), y (menambahkan pada kedua sisi vertikal), serta diikuti oleh besar margin atau padding yang diinginkan dengan nilai mulai dari 1 hingga 5, atau seperti berikut:\n ```html\n &lt;!-- Heading --&gt;\n &lt;div class=\"item mt-5 mb-3\"&gt;item1&lt;/div&gt;\n &lt;div class=\"item ms-2 me-3\"&gt;item2&lt;/div&gt;\n &lt;div class=\"item my-5\"&gt;item3&lt;/div&gt;\n &lt;div class=\"item mx-3\"&gt;item4&lt;/div&gt;\n &lt;div class=\"item m-3\"&gt;item4&lt;/div&gt;\n\n &lt;!-- Padding --&gt;\n &lt;div class=\"item pt-5 pb-3\"&gt;item1&lt;/div&gt;\n &lt;div class=\"item ps-2 pe-3\"&gt;item2&lt;/div&gt;\n &lt;div class=\"item py-5\"&gt;item3&lt;/div&gt;\n &lt;div class=\"item px-3\"&gt;item4&lt;/div&gt;\n &lt;div class=\"item p-3\"&gt;item4&lt;/div&gt;\n ```\n\n\n\n\nMargin-Padding-Border\n\n\n\n\n\nKomponen yang umum digunakan\n\nNavbar Navbar pada bootstrap sudah memiliki kemampuan untuk responsif ketika ukuran dari perangkat yang digunakan terlalu kecil untuk menampilkan konten atau menu didalamnya akan otomatis menjadi humberger menu, berikut salah satu contoh dokumentasi navbar yang umum digunakan.\n\n\n\n\nNavbar\n\n\n\nTable Pada class yang disediakan bootstrap terdapat beberapa pilihan tampilan table dan modifikasi yang diberikan, dengan memasukkan tag table ke dalam div yang diberikan kelas dari table yang diinginkan misalnya seperti berikut :\n\n\n\n\nTable\n\n\n\nButton Tombol merupakan bagian terpenting dalam suatu tampilan website yang dapat mengirimkan input dari pengguna ke server. Dalam bootstrap terdapat beberapa variasi yang diberikan untuk penggunaan tombol atau button misalnya warna, bentuk, style, rounded dan masih banyak lagi yang bisa didalami melalui dokumentasi yang ada pada halaman bootstrap\n\n\n\n\nButton\n\n\n\nCard Pada website blog atau e-commerce biasanya menampilkan artikel-artikel mereka pada card dapat menampilkan gambar, serta deskripsi atau tombol untuk melihat lebih banyak mengenai informasi dari blog tersebut. berikut adalah contoh penggunaan card:\n\n\n\n\nCard\n\n\n\n\n\n\n\n\n\n\nResponsive design menggunakan Bootstrap\n\n\n\nBerikut penjelasan mengenai penggunaan bootstrap dan elemen-elemen yang banyak digunakan!",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Playfair"
    ]
  },
  {
    "objectID": "4_playfair.html#implementasi-pada-python",
    "href": "4_playfair.html#implementasi-pada-python",
    "title": "4. Playfair",
    "section": "Implementasi Pada Python",
    "text": "Implementasi Pada Python\nDeklarasi list abjad yang berisi huruf a-z tanpa huruf j\nabjad = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\nMemasukkan plaintext\nplaintext_playfair = input(\"Masukkan teks yang akan dienkripsi: \")\nMenghilangkan spasi pada plaintext dan membuat plaintext menjadi lowercase\nplaintext_playfair = plaintext_playfair.replace(' ','').lower()\nprint(plaintext_playfair)\nMemasukkan kunci\nkey_playfair = input(\"Masukkan kunci: \")\n\nPemrosesan Kunci\nMenghilangkan spasi pada kunci dan membuat kunci menjadi lowercase\nkey_playfair = key_playfair.replace(' ','').lower()\nprint(key_playfair)\nMenghapus huruf ‘j’ jika ada di kunci\nkey_playfair = key_playfair.replace('j', '')\nprint(key_playfair)\nMenghapus huruf yang berulang\nkey_result = []\nfor i in key_playfair:\n  if i not in key_result:\n    key_result.append(i)\nprint(key_result)\nperulangan untuk menghapus huruf yang berulang dengan menambahkan kondisi apakah huruf tersebut sudah ditambahkan ke list key_result\nMenambahkan sisa huruf alphabet yang belum ada ke dalam matrix kunci\nfor i in abjad:\n  if i != 'j' and i not in key_result:\n    key_result.append(i)\nprint(key_result)\nMembuat matrix kunci 5x5\nkey_created = []\nwhile key_result!= []:\n  key_created.append(key_result[:5])\n  key_result = key_result[5:]\nfor row in key_created:\n        print(row)\n\n\nProses Enkripsi\nMengganti huruf ‘j’ yang ada di plainteks menjadi huruf ‘i’\nplaintext_playfair = plaintext_playfair.replace('j', 'i')\nprint(plaintext_playfair)\nProses pembuatan plaintext menjadi bentuk bigram atau pasangan huruf\nbigram_plaintext = []\n# perulangan untuk menambahkan pasangan huruf atau bigram ke dalam list bigram_plaintext\ni = 0\nwhile i&lt;len(plaintext_playfair):\n  x = plaintext_playfair[i]\n  y = ''\n\n  # situasi jika berada di huruf terakhir di plaintext\n  if((i+1) == len(plaintext_playfair)):\n    y = 'z'\n  else:\n    y = plaintext_playfair[i+1]\n\n  # jika hurufnya keduanya sama, maka disisipkan z di tengahnya\n  if(x!=y):\n    bigram_plaintext.append(x+y)\n    i += 2\n  else:\n    bigram_plaintext.append(x+'z')\n    i += 1\nprint(bigram_plaintext)\nPenjelasan prosesnya:\n\nbigram_plaintext = [] adalah sebuah list kosong yang akan diisi dengan pasangan huruf (bigram) yang diambil dari plaintext_playfair.\nwhile loop digunakan untuk iterasi melalui teks plaintext_playfair sampai semua huruf di teks tersebut telah diproses. Loop ini akan berlanjut selama i kurang dari panjang teks plaintext_playfair. Jadi perulangan ini digunakan untuk memproses semua huruf yang ada di plaintext_playfair.\nx = plaintext_playfair[i] dan y = '' adalah variabel yang digunakan untuk menampung huruf bigram pertama dan kedua dengan inisiasi nilai awal itu nilai dari plaintext_playfair[i] dan string kosong.\nSelanjutnya untuk pengkondisian pertama itu digunakan untuk kondisi dimana sudah sampai huruf terkahir dalam plaintext_playfair.\nTerakhir untuk pengkondisian kedua itu digunakan untuk kondisi dimana kedua hurufnya itu sama.\n\nProses substitusi plainteks dengan 3 aturan yang sudah di jelaskan diatas\nbigram_ciphertext = []\n# perulangan untuk mencari bigram ciphertex\nfor bigram in bigram_plaintext:\n  flag = False\n  # cek aturan 1, apakah pasangan huruf plaintext berada di baris yang sama\n  for row in key_created:\n    # jika berada di baris yang sama maka huruf yang berada di sebelah kanannya ditambahkan ke bigram ciphertext\n    if(bigram[0] in row and bigram[1] in row):\n      x1 = row.index(bigram[0])\n      x2 = row.index(bigram[1])\n      cipher_created = row[(x1 + 1) % 5] + row[(x2 + 1) % 5]\n      bigram_ciphertext.append(cipher_created)\n      flag = True\n  if flag:\n    continue\n\n  # cek aturan 2, apakah pasangan huruf plaintext berada di kolom yang sama\n  for j in range(5):\n    col = ''.join([key_created[i][j] for i in range(5)])\n    # jika berada di kolom yang sama maka huruf yang berada di bawahnya ditambahkan ke bigram ciphertext\n    if(bigram[0] in col and bigram[1] in col):\n      y1 = col.index(bigram[0])\n      y2 = col.index(bigram[1])\n      cipher_created = col[(y1 + 1) % 5] + col[(y2 + 1) % 5]\n      bigram_ciphertext.append(cipher_created)\n      flag = True\n  if flag:\n    continue\n\n  foundOne = False\n  foundTwo = False\n\n  # cek aturan 3, apakah pasangan huruf plaintext berada di baris dan kolom yang berbeda\n  for i in range(5):\n    row = key_created[i]\n    # jika huruf pertama dalam bigram ada pada baris urutan ke 'i'\n    if(bigram[0] in row):\n      x1 = i\n      y1 = row.index(bigram[0])\n      foundOne = True\n    # jika huruf kedua dalam bigram ada pada baris urutan ke 'i'\n    if(bigram[1] in row):\n      x2 = i\n      y2 = row.index(bigram[1])\n      foundTwo = True\n    # jika kedua posisi pasangan huruf atau bigram sudah diketahui, maka pembentukan cipher sesuai aturan ketiga dilakukan\n    if foundOne and foundTwo:\n      cipher_created = key_created[x1][y2] + key_created[x2][y1]\n      bigram_ciphertext.append(cipher_created)\n      break\nprint(bigram_ciphertext)\nPenjelasan prosesnya:\n\nbigram_ciphertext adalah list kosong yang akan diisi dengan pasangan huruf (bigram) yang telah dienkripsi dari bigram_plaintext.\nfor bigram in bigram_plaintext: digunakan untuk iterasi melalui setiap bigram yang ada dalam bigram_plaintext.\nflag = False adalah variabel boolean yang digunakan untuk menandai apakah aturan tertentu sudah dipenuhi sehingga tidak perlu memeriksa aturan lainnya untuk bigram yang sama.\nPemeriksaan Aturan 1: Baris yang Sama\n\nfor row in key_created:\n    if(bigram[0] in row and bigram[1] in row):\n        x1 = row.index(bigram[0])\n        x2 = row.index(bigram[1])\n        cipher_created = row[(x1 + 1) % 5] + row[(x2 + 1) % 5]\n        bigram_ciphertext.append(cipher_created)\n        flag = True\n\nLoop ini memeriksa setiap baris (row) dalam matriks kunci (key_created).\nJika kedua huruf dalam bigram (bigram[0] dan bigram[1]) berada di baris yang sama (row), maka:\n\nIndeks masing-masing huruf dalam baris ditemukan (x1 dan x2).\nHuruf di sebelah kanan dari masing-masing huruf ditentukan dengan menggunakan (index + 1) % 5 untuk menangani kasus melingkar (huruf di ujung kanan).\nHuruf-huruf ini kemudian digabungkan menjadi cipher_created dan ditambahkan ke bigram_ciphertext.\nflag diatur ke True untuk menandai bahwa aturan ini telah diterapkan, dan loop berhenti memeriksa aturan lain untuk bigram ini.\n\nLanjut ke Bigram Berikutnya Jika Aturan 1 Terpenuhi\n\nif flag:\n    continue\n\nJika flag True, bigram ini sudah diproses, dan loop lanjut ke bigram berikutnya tanpa memeriksa aturan lainnya.\nPemeriksaan Aturan 2: Kolom yang Sama\n\nfor j in range(5):\n    col = ''.join([key_created[i][j] for i in range(5)])\n    if(bigram[0] in col and bigram[1] in col):\n        y1 = col.index(bigram[0])\n        y2 = col.index(bigram[1])\n        cipher_created = col[(y1 + 1) % 5] + col[(y2 + 1) % 5]\n        bigram_ciphertext.append(cipher_created)\n        flag = True\n\nLoop ini memeriksa setiap kolom dalam matriks kunci (key_created).\nSetiap kolom (col) dibentuk dengan menggabungkan huruf-huruf dari setiap baris pada indeks j.\nJika kedua huruf dalam bigram (bigram[0] dan bigram[1]) berada di kolom yang sama (col), maka:\n\nIndeks masing-masing huruf dalam kolom ditemukan (y1 dan y2).\nHuruf di bawah masing-masing huruf ditentukan dengan menggunakan (index + 1) % 5 untuk menangani kasus melingkar (huruf di ujung bawah).\nHuruf-huruf ini kemudian digabungkan menjadi cipher_created dan ditambahkan ke bigram_ciphertext.\nflag diatur ke True, dan loop berhenti memeriksa aturan lain untuk bigram ini.\n\nLanjut ke Bigram Berikutnya Jika Aturan 2 Terpenuhi\n\nif flag:\n    continue\n\nJika flag True, bigram ini sudah diproses, dan loop lanjut ke bigram berikutnya tanpa memeriksa aturan lainnya.\nPemeriksaan Aturan 3: Baris dan Kolom Berbeda\n\nfoundOne = False\nfoundTwo = False\n\nfor i in range(5):\n    row = key_created[i]\n    if(bigram[0] in row):\n        x1 = i\n        y1 = row.index(bigram[0])\n        foundOne = True\n    if(bigram[1] in row):\n        x2 = i\n        y2 = row.index(bigram[1])\n        foundTwo = True\n    if foundOne and foundTwo:\n        cipher_created = key_created[x1][y2] + key_created[x2][y1]\n        bigram_ciphertext.append(cipher_created)\n        break\n\nLoop ini memeriksa setiap baris dalam matriks kunci (key_created) untuk menemukan posisi huruf pertama dan kedua dari bigram.\nJika huruf pertama (bigram[0]) ditemukan dalam baris i, indeks baris (x1) dan kolom (y1) disimpan, dan foundOne diatur ke True.\nJika huruf kedua (bigram[1]) ditemukan dalam baris i, indeks baris (x2) dan kolom (y2) disimpan, dan foundTwo diatur ke True.\nJika kedua huruf ditemukan (foundOne dan foundTwo), aturan ketiga diterapkan:\n\nHuruf di posisi silang yang berlawanan diambil dari matriks kunci: key_created[x1][y2] dan key_created[x2][y1].\nHuruf-huruf ini digabungkan menjadi cipher_created dan ditambahkan ke bigram_ciphertext.\nLoop dihentikan dengan break karena bigram telah diproses.\n\n\nHasil enkripsi\nhasil_enkripsi = ''.join(bigram_ciphertext)\nprint(hasil_enkripsi)\n\n\nProses Dekripsi\nMemasukkan ciphertext\nciphertext_playfair = input(\"Masukkan teks yang akan di dekripsi: \")\nProses pembuatan ciphertext menjadi bentuk bigram atau pasangan huruf\nbigram_ciphertext = [ciphertext_playfair[i:i+2] for i in range(0, len(ciphertext_playfair), 2)]\nprint(bigram_ciphertext)\nProses substitusi Cipherteks dengan 3 aturan yang sudah di jelaskan diatas\nbigram_dekripsi = []\n# perulangan untuk mencari bigram decrypt text\nfor bigram in bigram_ciphertext:\n  flag = False\n  # cek aturan 1, apakah pasangan huruf ciphertext berada di baris yang sama\n  for row in key_created:\n    # jika berada di baris yang sama maka huruf yang berada di sebelah kanannya ditambahkan ke bigram decrypt text\n    if(bigram[0] in row and bigram[1] in row):\n      x1 = row.index(bigram[0])\n      x2 = row.index(bigram[1])\n      decrypt_created = row[(x1 - 1) % 5] + row[(x2 - 1) % 5]\n      bigram_dekripsi.append(decrypt_created)\n      flag = True\n  if flag:\n    continue\n\n  # cek aturan 2, apakah pasangan huruf ciphertext berada di kolom yang sama\n  for j in range(5):\n    col = ''.join([key_created[i][j] for i in range(5)])\n    # jika berada di kolom yang sama maka huruf yang berada di bawahnya ditambahkan ke bigram decrypt text\n    if(bigram[0] in col and bigram[1] in col):\n      y1 = col.index(bigram[0])\n      y2 = col.index(bigram[1])\n      decrypt_created = col[(y1 - 1) % 5] + col[(y2 - 1) % 5]\n      bigram_dekripsi.append(decrypt_created)\n      flag = True\n  if flag:\n    continue\n\n  foundOne = False\n  foundTwo = False\n\n  # cek aturan 3, apakah pasangan huruf ciphertext berada di baris dan kolom yang berbeda\n  for i in range(5):\n    row = key_created[i]\n    # jika huruf pertama dalam bigram ada pada baris urutan ke 'i'\n    if(bigram[0] in row):\n      x1 = i\n      y1 = row.index(bigram[0])\n      foundOne = True\n    # jika huruf kedua dalam bigram ada pada baris urutan ke 'i'\n    if(bigram[1] in row):\n      x2 = i\n      y2 = row.index(bigram[1])\n      foundTwo = True\n    # jika kedua posisi pasangan huruf atau bigram sudah diketahui, maka pembentukan cipher sesuai aturan ketiga dilakukan\n    if foundOne and foundTwo:\n      decrypt_created = key_created[x1][y2] + key_created[x2][y1]\n      bigram_dekripsi.append(decrypt_created)\n      break\nprint(bigram_dekripsi)\nHasil dekripsi\nhasil_dekripsi = ''.join(bigram_dekripsi)\nprint(hasil_dekripsi)",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Playfair"
    ]
  },
  {
    "objectID": "1_caesar.html",
    "href": "1_caesar.html",
    "title": "1. Caesar Cipher",
    "section": "",
    "text": "Analogi Caesar Cipher\nMisalkan kita memiliki teks “HELLO” dan kita ingin mengenkripsinya dengan kunci pergeseran 3 posisi ke kanan.",
    "crumbs": [
      "Kriptografi Klasik",
      "1. Caesar Cipher"
    ]
  },
  {
    "objectID": "1_caesar.html#lingkungan-pengembangan-web",
    "href": "1_caesar.html#lingkungan-pengembangan-web",
    "title": "1. Caesar",
    "section": "Lingkungan Pengembangan Web",
    "text": "Lingkungan Pengembangan Web\n\nEditor kode\n\n\n\nVisual Studio Code\n\n\nGunakan editor teks atau lingkungan pengembangan terintegrasi (IDE) seperti Visual Studio Code, Sublime Text, atau Atom untuk menulis kode web. \n\n\nBrowser\n\nBerbagai browser seperti Chrome, Firefox, atau Safari digunakan untuk menguji dan melihat hasil dari halaman web yang dikembangkan. \n\n\nServer lokal\nAnda dapat menginstal server web lokal seperti Apache, Nginx, atau XAMPP untuk menguji halaman web secara lokal sebelum diunggah ke server publik.\n\n\nURL (Uniform Resource Locator)\nAlamat yang digunakan untuk mengakses halaman web. URL terdiri dari protokol (misalnya http:// atau https://), nama domain, dan path halaman.\n\n\n\nHTTP (Hypertext Transfer Protocol)\nProtokol komunikasi yang digunakan untuk mentransfer data antara klien dan server. Permintaan klien dan respons server terjadi melalui metode HTTP seperti GET, POST, PUT, dan DELETE.\n\n\n\nMarkup Languages\nMarkup languages adalah bahasa yang digunakan untuk membuat struktur dan tampilan konten dalam halaman web.\n\nHTML (HyperText Markup Language) adalah markup language yang paling umum digunakan untuk membangun struktur halaman web. XML (eXtensible Markup Language) digunakan untuk menyimpan dan mengirim data secara terstruktur.\nStruktur Dasar HTML\nMerupakan bahasa markup paling popular, disusul eXtensible Markup Language (XML). XML adalah bahasa yang digunakan untuk membuat bahasa markup lain yaitu Wireless Markup Language (WML).Bahasa markup bukan bahasa pemrograman. Oleh karena itu, penyebutan bahasa pemrograman HTML adalah kurang tepat.\nFormat Dasar HTML\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Untitled Document&lt;/title&gt;\n&lt;meta http-equiv=\"Content-Type\" content=\"text/html;\ncharset=iso-8859-1\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n{ Tempat untuk coding }\n&lt;/body&gt;\n&lt;/html&gt;\n&lt; HTML &gt;\nDokumen HTML harus diawali dengan tag &lt; html &gt; dan diakhiri dengan &lt; /html &gt;memberi tahu kepada browser bahwa yang berada dalam kedua tag tersebut adalah dokumen HTML.\n&lt; HEAD &gt; Bagian header dalam dokumen HTML. Biasanya berisi judul halaman web. Bentuk secara umum:\n&lt;head&gt;\n&lt;title&gt;Judul ini akan ditampilkan pada bagian atas\nbrowser\n&lt;/title&gt;\n&lt;/head&gt;\n&lt; BODY &gt;\nBagian isi dari dokumen HTML yang dapat disisipkan teks, gambar, video maupun link. Sesuatu yang ditulis di dalam bodyakan ditampilkan pada halaman web.\nHTML Tags\nInstruksi/perintah dalam HTML disebut tag. Tag pada HTML tidak bersifat case sensitive.\n&lt;element atribut=value&gt;\nKeterangan:\n\nelement = nama tag\natribut = atribut\nvalue = nilai dari atribut Contoh:\n\n&lt;font color=red&gt;\n\nFONT merupakan element,\nCOLOR merupakan atribut,\nRED adalah value\n\n\n\n\n\n\n\nContoh HTML\n\n\n\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;\nHalaman Latihan 1\n&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;\nIni adalah latihan pemrograman web pertamaku.\n&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nCSS (Cascading Style Sheets) digunakan untuk mengatur tampilan dan gaya elemen-elemen dalam halaman web.\n\n\n\nArsitektur Klien dan Server\n\n\n\nArsitektur Klien dan Server\n\n\nPada pemrograman web, arsitektur klien dan server digunakan. Klien (misalnya browser web) mengirimkan permintaan ke server, dan server merespons dengan mengirimkan halaman web yang diminta.\nKlien menginterpretasikan halaman web menggunakan HTML, CSS, dan JavaScript, sementara server mengurus pemrosesan data dan logika di balik halaman.\n\n\n\nDatabase\n\n\n\nDatabase MySQL\n\n\nDBMS atau Database Management System digunakan untuk menyimpan dan mengelola data dalam aplikasi web. Beberapa sistem database yang umum digunakan termasuk MySQL, PostgreSQL, MongoDB, dan Oracle. Pemahaman tentang database meliputi pembuatan tabel dan relasi antar tabel, manipulasi data dengan menggunakan bahasa query seperti SQL, dan pengoptimalan kinerja database\n\n\n\nFramework\n\n\n\n\n\n\n\n\n\nLaravel\n\n\n\n\n\n\n\nBootstrap\n\n\n\n\n\nFramework adalah kerangka kerja perangkat lunak yang menyediakan struktur, komponen, dan alat bantu untuk membangun aplikasi web dengan lebih cepat dan efisien. Framework menyediakan aturan dan konvensi yang konsisten, menyederhanakan tugas umum, jika seperti routing, validasi data, interaksi dengan database, dan lainnya. Dalam pemrograman web khsusnya dengan menggunakan bahasa pemrograman php yang populer termasuk Laravel dan CodeIgniter. Dalam pemrograman web,\n\n\n\nWeb Servers\n\n\n\nApache Server\n\n\nWeb server adalah perangkat lunak yang mengelola permintaan dari browser dan mengirimkan halaman web ke pengguna melalui protokol HTTP. Beberapa server web yang umum digunakan adalah Apache, Nginx, dan IIS (Internet Information Services). Pemahaman tentang konfigurasi server web, manajemen domain, dan penanganan permintaan HTTP penting dalam pengembangan web.\n\n\n\nVersion Control\nVersion control adalah metode untuk melacak perubahan kode sumber selama pengembangan aplikasi. Git adalah sistem version control yang populer yang memungkinkan pengembang untuk bekerja secara kolaboratif, membuat cabang (branch), menggabungkan perubahan (merge), dan melakukan pemulihan (revert) jika terjadi kesalahan. Version control membantu dalam manajemen kode, pengendalian versi, dan kolaborasi tim.\n\n\n\nResposive Web Design\nResponsive web design adalah pendekatan desain web yang memastikan tampilan dan pengalaman pengguna yang optimal di berbagai perangkat dan ukuran layar. Ini melibatkan penggunaan teknik seperti media queries, flexible grids, dan CSS frameworks (seperti Bootstrap atau Foundation) untuk mengatur tata letak dan tampilan halaman web secara responsif.\n\n\n\nTesting and Debugging\nTesting dan debugging adalah proses penting dalam pengembangan web untuk memastikan aplikasi berfungsi dengan baik dan bebas dari kesalahan. Testing adalah proses verifikasi dan validasi untuk memastikan bahwa aplikasi web berfungsi sesuai dengan yang diharapkan dan memenuhi persyaratan bisnis yang telah ditetapkan. Tujuan dari testing adalah untuk menemukan bug atau kesalahan dalam aplikasi sebelum dirilis ke pengguna akhir. Debugging adalah proses untuk menemukan, mendiagnosis, dan memperbaiki bug atau kesalahan dalam kode aplikasi web.\n\n\n\nAPI (Application Programming Interface)\nAPI adalah antarmuka yang memungkinkan aplikasi web berkomunikasi dan berbagi data dengan aplikasi atau layanan lain. RESTful API adalah pendekatan populer untuk mengembangkan API yang menggunakan protokol HTTP dan standar seperti JSON atau XML untuk bertukar data.",
    "crumbs": [
      "Kriptografi Klasik",
      "1. Caesar{.unnumbered}"
    ]
  },
  {
    "objectID": "1_caesar.html#php-hypertext-preprocessor",
    "href": "1_caesar.html#php-hypertext-preprocessor",
    "title": "1. Caesar",
    "section": "PHP (Hypertext Preprocessor)",
    "text": "PHP (Hypertext Preprocessor)\nPHP adalah bahasa pemrograman server-side yang populer untuk pengembangan web. PHP digunakan untuk memproses permintaan dari klien, mengakses basis data, dan menghasilkan respons yang dikirimkan kembali ke klien.\n\nMemulai PHP\nSetiap memulai kode php selalu diawali dengan &lt;?php dan ditutup dengan ?&gt; \n&lt;?php\n    $kata = \"Hello World!\"\n    echo \"$kata\"; // Output: Hello World!\n?&gt;\nMenggunakan echo untuk print\nDalam variabel php menggunakan tanda $ ($variable) untuk inisialisasi variabel\n\n\nPHP - Kondisional\nKondisional dalam bahasa pemrograman adalah proses yang berfungsi untuk menentukan blok instruksi akan dieksekusi atau tidak, tergantung pada kondisinya sendiri seperti nilainya sudah benar (True) atau belum (False). Ada beberapa jenis percabangan yaitu if-else, switch case dll.\n$angka = -5;\nif($angka &lt; 0){\n    echo 'Angka negatif';\n} else {\n    echo'Angka positif ';\n};\n//Output : Angka Negatif\n$input = 3;\nswitch($input){\n    case \"1\":\n    echo\"Inputan adalah satu\";\n    break;\n    case \"2\":\n    echo\"Inputan adalah dua\";\n    break;\n    case \"3\":\n    echo\"Inputan adalah tiga\";\n    break;\n    default:\n    echo\"Tidak ada input yang cocok dengan pilihan anda.\";\n    }\n    /* Output: Inputan adalah tiga\n    Jika nilai dari variable `$input` bukan sama dengan `case`,\n    maka akan menampilkan pesan “Tidak ada input yang cocok\n    */\n\n\n\nPHP – isset dan empty\nFungsi isset digunakan untuk memeriksa apakah suatu variabel telah diatur atau tidak. Sintaks fungsi ini sebagai berikut:\n$nama = \"Bengkel Koding\";\nif(isset($nama)){\n    print(\"Nama telah diatur\");\n} else {\n    print(\"Nama belum diatur\")\n}\n// output : Nama telah diatur\n\nFungsi empty digunakan untuk memeriksa apakah suatu variabel kosong atau tidak. Sintaks fungsi ini sebagai berikut:\n$nama = \"\";\nif(empty($nama)) {\n    print(\"nama kosong\");\n} else {\n    print(\"nama tidak kosong\");\n}\n// output : Nama kosong\n\n\n\nPHP - Looping\nPerulangan pada php terdapat beberapa fungsi yang dapat digunakan, diantaranya adalah for, while, do while, dan foreach\n\nLooping For\nLooping For adalah salah satu looping statement pada bahasa pemrograman php, yang memiliki sintaks seperti for (expression1; expression2; expression3) {} dimana expression 1 merupakan awal dari pengulangan, expression 2 menentukan kondisi yang harus terpenuhi agar perintah d iterasi lebih lanjut, sedangkan expresion 3 mengubah nilai variable dalam setiap iterasinya.\nContoh Penggunaannya:\nfor ($i=0;$i&lt;=5;$i++){\necho \"$i \";\n}\n// Output: 0 1 2 3 4 5\nDalam contoh diatas, nilai x mulai dari angka 0 dan terus ditambah sampai batas yaitu &lt;=5. Setelah itu akan di eksekusi dengan cara mencetak isi value dari x ke layar.\n\n\nWhile\nLooping while juga ada didalam bahasa pemograman PHP, sintaksnya sama tapi bedanya hanya bisa melakukan looping selama kondisinya benar/true.\nContohnya:\n$x = 0; //awal variabel $x\nwhile($x &lt;= 5){\necho \"$x \";\n$x++;\n}\n// Output : 0 1 2 3 4 5\n\n\nDo While\nPerulangan do-while adalah perintah yang digunakan untuk mengulang suatu proses terhadap nilai kondisional (expression) saat awal loop dilanjutkan dengan evaluasi ulang pada akhir setiap iterasi.\nSintaks nya adalah sebagai berikut:\n$i = 1;\ndo{\n    echo $i;\n    $i++;\n} while ($i &lt;= 5);\n// Output : 0 1 2 3 4 5\n\n\nForeach\nForeach merupakan perintah yang digunakan untuk mengiterasi set data array dalam bahasa pemrograman php. Sintaks nya seperti ini:\n$buah = array(\"Apel\", \"Jeruk\", \"Mangga\", \"Pisang\");\nforeach ($buah as $item) :\n    echo $item . \"\\n\";\nendforeach;\n/* output : \napel\njeruk\nmangga\npisang\n*/\nSelain menggnakan endforeach bisa juga menggunakan kurung kurawal {}\n$buah = array(\"Apel\", \"Jeruk\", \"Mangga\", \"Pisang\");\nforeach ($buah as $item) {\n    echo $item . \"\\n\";\n}\n/* output : \napel\njeruk\nmangga\npisang\n*/\n\n\n\nInclude - Require\nFungsi-fungsi ini digunakan untuk menyisipkan (include) atau memasukkan (require) file PHP eksternal ke dalam file PHP yang sedang aktif. Berguna untuk mengorganisir kode secara modular.",
    "crumbs": [
      "Kriptografi Klasik",
      "1. Caesar{.unnumbered}"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Kriptografi",
    "section": "",
    "text": "Pengantar\nPelatihan Web Developer terbagi menjadi dua tahap (kelas) yaitu Junior Web Developer dan Web Developer. Materi yang diajarkan pada kedua kelas berbeda namun berkelanjutan. Pada modul Junior Web Developer berisi tentang dasar-dasar dari pemrograman web dengan permasalahan yang sering dialami mahasiswa. Sedangkan pada modul Web Developer berisi materi pemrograman web dengan menggunakan framework. Sehingga peserta yang lulus pada setiap kelas berhak melanjutkan ke kelas selanjutnya.",
    "crumbs": [
      "**Pengantar**"
    ]
  },
  {
    "objectID": "index.html#materi-junior-web-developer",
    "href": "index.html#materi-junior-web-developer",
    "title": "Kriptografi",
    "section": "Materi Junior Web Developer",
    "text": "Materi Junior Web Developer\nTerdapat topik-topik dan materi-materi yang akan diajarkan, diantaranya sebagai berikut:\n\n\nTopik dan Materi Junior Web Developer\n\n\n\n\n\n\n\nTopik\nMateri\nOutcome\n\n\n\n\nWeb Developments Fundamentals \n1. Konsep Dasar Pemrograman Berbasis Web  2. Pengenalan Tools (J.620100.001.01), Library, komponen dan Framework pemrograman berbasis web (J.620100.003.01) \nPeserta memahami konsep dasar pemrograman berbasis web, mengenal tools, library, framework yang diperlukan untuk mengembangkan aplikasi berbasis web \n\n\nMelakukan Migrasi ke Teknologi Baru (J.620100.024.02) \n1. Pengenalan Responsive Web Design (Mobile First),  2. Praktek Instalasi Bootstrap Framework \nPeserta memiliki pengetahuan mengenai teknologi terkini dalam pembangunan aplikasi berbasis web dan cara menggunakannya \n\n\nMenerapkan Rancangan User Interface / User Experience (UI/UX) (J.620100.006.01) dan alert notification jika terdapat suatu permasalahan pada aplikasi (J.620100.044.01) \nPraktek mengimplementasikan design UI halaman depan (front page) aplikasi To Do List menggunakan Bootstrap \nPeserta dapat menerapkan rancangan UI/UX dan alert notification dari project yang diberikan \n\n\nKonsep Basis Data Dan Menggunakan SQL (J.620100.020.02)\n1. Review Konsep Basis Data  2. Query SQL: DDL, DML  3. Praktek membuat database dan tabel aplikasi To Do List \nPeserta memiliki pengetahuan mengenai konsep Basis Data dan menggunakan Database Management System (DBMS) berbasis SQL \n\n\nMenerapkan Pemrograman Terstruktur (J.620100.017.02) Dan Akses Basis Data (J.620100.021.02) \nPraktek pembuatan Aplikasi To Do List  Praktek Studi Kasus aplikasi Poliklinik (langkah-langkah pembuatan) \nPeserta mampu menerapkan konsep dasar pemrograman terstruktur dan mengakses basis data menggunakan kode program \n\n\nDebugging, Pengujian Program dan Code Review (J.620100.025.02, J.620100.036.02, J.620100.032.01) \nPengenalan Tool untuk melakukan pengujian aplikasi berbasis web   Praktek software testing aplikasi Poliklinik \nPeserta mampu melakukan debugging, pengujian program, meninjau dan memeriksa kode program yang telah dibuat \n\n\nPembaruan Perangkat Lunak pada Web Dasar (J.620100.047.01)\nPraktek mengembangkan aplikasi Poliklinik  Penilaian final project \nPeserta dapat menambahkan fitur tambahan dari project web yang diberikan",
    "crumbs": [
      "**Pengantar**"
    ]
  },
  {
    "objectID": "5_transposisi_kolom.html",
    "href": "5_transposisi_kolom.html",
    "title": "5. Transposisi Kolom",
    "section": "",
    "text": "Analogi Transposisi Kolom\nBayangkan Kita memiliki rak buku dengan beberapa kolom dan setiap kolom berisi tumpukan buku.\nDengan kata lain, transposisi kolom mengubah urutan kolom tanpa mengubah isi kolom. Dalam kriptografi, ini dilakukan untuk mengacak data agar lebih sulit ditebak oleh pihak yang tidak berwenang.",
    "crumbs": [
      "Kriptografi Klasik",
      "5. Transposisi Kolom"
    ]
  },
  {
    "objectID": "5_transposisi_kolom.html#implementasi-pada-python",
    "href": "5_transposisi_kolom.html#implementasi-pada-python",
    "title": "5. Transposisi Kolom",
    "section": "Implementasi Pada Python",
    "text": "Implementasi Pada Python\nMasukkan plaintext\nplainText = input(\"Plaintext : \")\nMasukkan kunci\nkey = input(\"masukkan kunci : \")\nMembersihkan teks dari spasi ganda\ncleanPlainTeks = plainTeks.replace(\" \", \"\")\nprint(cleanPlainTeks)\nDeklarasi urutan huruf dalam alfabet\nascii = {\n'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8, 'i': 9, 'j': 10, 'k': 11, \n'l': 12, 'm': 13, 'n': 14, 'o': 15, 'p': 16, 'q': 17, 'r': 18, 's': 19, 't': 20, 'u': 21, \n'v': 22, 'w': 23, 'x': 24, 'y': 25, 'z': 26\n}\n\nProses Enkripsi\nInisialisasi list untuk menyimpan urutan numerik dari setiap huruf alfabet\nkolom = 0\nangka_urutan = []\nMengonversi setiap huruf dalam kata kunci menjadi urutan numeriknya sesuai dengan posisi dalam alfabet\nfor huruf in key:\n    if huruf.isalpha():\n        angka_urutan.append(ascii[huruf.lower()])\n        kolom = kolom+1\n        cleanKey = angka_urutan\n\nprint(f\"Urutan kunci dari kata '{key}' adalah {angka_urutan}\")\nFor More Detail :\n\nfor huruf in key : Loop ini digunakan untuk memeriksa setiap huruf dalam variabel key, yang diharapkan merupakan kata kunci yang diberikan oleh pengguna\nif huruf.isalpha() : Kondisi ini memastikan bahwa hanya karakter alfabet yang akan diproses. Karakter non-alfabet akan dilewati\n`huruf.lower(): Mengubah huruf menjadi huruf kecil untuk konsistensi, sehingga tidak ada perbedaan antara huruf besar dan kecil\nascii[huruf.lower()] : Mengambil nilai urutan numerik dari huruf. Di sini diasumsikan ada sebuah kamus (dictionary) bernama ascii yang memetakan setiap huruf ke urutan numeriknya\nangka_urutan.append(...) : Menambahkan urutan numerik dari huruf ke dalam list angka_urutan\nkolom = kolom + 1 : Menghitung jumlah kolom dengan menambah nilai kolom setiap kali huruf diproses\ncleanKey = angka_urutan : Menyimpan hasil akhir urutan numerik ke dalam variabel cleanKey\n\nMembuat sebuah matriks kosong untuk menyimpan teks yang telah diolah dalam bentuk matriks\nmatrix = []\nMenghitung panjang dari teks yang telah dibersihkan dan disimpan dalam variabel cleanPlainTeks\npanjang = len(cleanPlainTeks)\nMencari tahu berapa kali kolom dapat digunakan untuk memuat seluruh teks, dengan membagi panjang teks dengan jumlah kolom\ntemp = panjang/kolom\nMembulatkan hasil pembagian sebelumnya ke bilangan bulat terdekat\nbulat = round(temp)\nMenghitung jumlah baris untuk memuat teks dalam matriks\nif temp - bulat == 0:\n    baris = bulat\nelse:\n    if temp - bulat &lt; 0:\n        baris = bulat\n    else:\n        baris = bulat + 1\nprint(baris)\nFor More Detail :\n\ntemp : hasil pembagian panjang teks dengan jumlah kolom\nbulat: hasil pembagian yang dibulatkan ke bilangan bulat terdekat. Jika temp adalah bilangan bulat (tidak ada sisa), jumlah baris adalah bulat. Jika ada sisa, jumlah baris adalah bulat + 1\n\nMengisi matriks dengan karakter dari teks yang telah dibersihkan (cleanPlainTeks)\nfor i in range(baris):\n    row = []\n    for j in range(kolom):\n        if i * kolom + j &lt; len(cleanPlainTeks):\n            elemen = cleanPlainTeks[i * kolom + j]\n        else:\n            elemen = \" \"\n        row.append(elemen)\n    matrix.append(row)\nFor More Detail :\n\nfor i in range(baris) : Loop untuk setiap baris dalam matriks\nrow = [] : Inisialisasi list kosong untuk setiap baris\nif i * kolom + j &lt; len(cleanPlainTeks) : Memeriksa apakah indeks saat ini berada dalam rentang panjang teks yang dibersihkan.\nelemen = cleanPlainTeks[i * kolom + j] : Jika indeks berada dalam rentang, maka ambil karakter dari cleanPlainTeks berdasarkan indeks yang dihitung.\nelse : Jika indeks melebihi panjang teks, isi elemen dengan spasi.\nrow.append(elemen) : Menambahkan elemen ke dalam baris.\nmatrix.append(row) : Menambahkan baris yang telah diisi ke dalam matriks.`\n\nMencetak matriks\nprint(\"Matriks yang Anda buat:\")\nfor row in matrix:\n    print(row)\nMentransposisikan matriks yang telah dibuat dan kemudian mencetak matriks yang telah ditransposisikan\ntransposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\nfor row in transposed_matrix:\n    print(row)\nFor More Detail :\n\nfor i in range(len(matrix[0])) : Iterasi melalui indeks kolom matriks asli\nrow[i] for row in matrix : Untuk setiap indeks kolom i, ambil elemen i dari setiap baris dalam matriks asli dan akan menghasilkan kolom baru dari elemen-elemen tersebut, membentuk baris baru di matriks yang ditransposisikan\n\nMembuat list kosong dengan panjang yang sama dengan cleanKey untuk menyimpan urutan indeks\norder = [None] * len(cleanKey)\nMengurutkan elemen-elemen dalam cleanKey berdasarkan nilai terkecil hingga terbesar\ni = 0\nwhile len(cleanKey) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, cleanKey))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = cleanKey.index(nilai_terkecil)\n\n        order[marker] = i\n        cleanKey[marker] = None \n        i = i + 1\n    else:\n        break\nprint(order)\nFor More Detail :\n\ni = 0 : Inisialisasi counter i\nwhile len(cleanKey) &gt; 0 : Loop hingga cleanKey kosong (semua elemen None)\nnon_none_values = list(filter(lambda x: x is not None, cleanKey)) : Membuat list yang hanya berisi elemen-elemen cleanKey yang bukan None\nif non_none_values : Mengecek apakah list non_none_values tidak kosong nilai_terkecil = min(non_none_values) : Mencari nilai terkecil dari non_none_values\nmarker = cleanKey.index(nilai_terkecil) : Mendapatkan indeks dari nilai terkecil dalam cleanKey Menyimpan Urutan dan Menghapus Nilai Terkecil:\norder[marker] = i : Menyimpan urutan i pada indeks marker di list order\ncleanKey[marker] = None : Menghapus nilai terkecil dari cleanKey dengan mengubahnya menjadi None\ni = i + 1 : Increment counter i.\n\nMengubah urutan kolom matriks transposed_matrix berdasarkan urutan yang telah diatur dalam order, dan kemudian mencetak matriks yang sudah diubah urutan kolomnya\nnew_matrix = []\nwhile len(order) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, order))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = order.index(nilai_terkecil)\n       \n        new_matrix.append(transposed_matrix[marker])\n        order[marker] = None\n    else:\n        break\n\nfor row in new_matrix:\n    print(row)\nFor More Detail :\n\nnew_matrix = [] : Membuat list kosong new_matrix untuk menampung baris-baris matriks yang baru diurutkan Looping untuk Mengubah Urutan Kolom:\nwhile len(order) &gt; 0 : Melakukan looping selama masih ada elemen yang tersisa dalam order\nnon_none_values = list(filter(lambda x: x is not None, order)) : Membuat list non_none_values yang hanya berisi nilai-nilai yang bukan None dari order\nif non_none_values : Memeriksa apakah non_none_values tidak kosong\nnilai_terkecil = min(non_none_values) : Menemukan nilai terkecil dari non_none_values\nmarker = order.index(nilai_terkecil) : Mencari indeks dari nilai_terkecil dalam order\nnew_matrix.append(transposed_matrix[marker]) : Menambahkan baris dari transposed_matrix yang sesuai dengan marker ke new_matrix\norder[marker] = None : Menghapus nilai yang telah diproses dengan mengubahnya menjadi None\nelse: break : Menghentikan loop jika non_none_values kosong, yang berarti semua nilai dalam order telah diproses\n\nMengonversi matriks new_matrix menjadi string tunggal dengan menggabungkan nilai-nilainya secara berurutan dan menghapus spasi ekstra di akhir string\nresult_string = \"\"\n\nfor row in new_matrix:\n    for value in row:\n        result_string += str(value)\n\nresult_string = result_string.strip()\n\nprint(result_string)\nFor More Detail :\n\nresult_string = \"\" : Inisialisasi string kosong result_string yang akan digunakan untuk menyimpan hasil akhir\nfor row in new_matrix: : Melakukan iterasi melalui setiap baris dalam new_matrix\nfor value in row: : Melakukan iterasi melalui setiap nilai dalam baris row\nresult_string += str(value) : Mengonversi nilai value menjadi string (jika belum string) dan menambahkannya ke result_string\nresult_string = result_string.strip() : Menghapus spasi ekstra di awal dan akhir string menggunakan metode strip()\n\nHasil Ciphertext : ENTKFINOKKM TIAIRA\n\n\nProses Dekripsi\ncipherTeks = input(\"masukkan kata : \")\nkey = input(\"masukkan kunci : \")\ncleanCipherTeks = cipherTeks.replace(\" \", \" \")\nprint(cleanCipherTeks)\nkolom = 0\nangka_urutan = []\nfor huruf in key:\n    if huruf.isalpha():\n        angka_urutan.append(ascii[huruf.lower()])\n        kolom = kolom+1\n        cleanKey = angka_urutan\n\nprint(f\"Urutan kunci dari kata '{key}' adalah: {angka_urutan}\")\nmatrix = []\npanjang = len(cleanCipherTeks)\ntemp = panjang/kolom\nbaris = round(temp)\nprint(baris)\nfor i in range(baris):\n    row = []\n    for j in range(kolom):\n        if i * kolom + j &lt; len(cleanCipherTeks):\n            elemen = cleanCipherTeks[i + baris * j]\n        else:\n            elemen = \"a\"\n        row.append(elemen)\n    matrix.append(row)\nprint(\"Matriks yang Anda buat:\")\nfor row in matrix:\n    print(row)\ntransposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\nfor row in transposed_matrix:\n    print(row)\norder = [None] * len(cleanKey)\ni = 0\nwhile len(cleanKey) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, cleanKey))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = cleanKey.index(nilai_terkecil)\n        order[marker] = i\n        cleanKey[marker] = None  \n        i = i + 1\n    else:\n        break\nprint(order)\ntransposed_matrix = [transposed_matrix[i] for i in order]\n\nfor row in transposed_matrix:\n    print(row)\nmatriks = [[row[i] for row in transposed_matrix] for i in range(len(transposed_matrix[0]))]\nfor row in matriks:\n    print(row)\nresult_string = \"\"\n\nfor row in matriks:\n    for value in row:\n        result_string += str(value)\n\nresult_string = result_string.strip()\n\nprint(result_string)\nHasil Dekripsi : TEKNIKINFORMATIKA\nPerbedaan Proses :\n\nEnkripsi: Teks asli diubah menjadi matriks berdasarkan kolom kunci, kemudian kolom-kolom diurutkan berdasarkan kunci. Pada enkripsi, transposed_matrix adalah matriks transposisi dari matrix awal\nDekripsi: Teks sandi diubah menjadi matriks berdasarkan kolom kunci, kemudian baris-baris diurutkan berdasarkan kunci untuk mengembalikan teks asli. Pada dekripsi, transposed_matrix diurutkan berdasarkan order untuk mengembalikan teks asli",
    "crumbs": [
      "Kriptografi Klasik",
      "5. Transposisi Kolom"
    ]
  },
  {
    "objectID": "1_caesar.html#implementasi-pada-python",
    "href": "1_caesar.html#implementasi-pada-python",
    "title": "1. Caesar Cipher",
    "section": "Implementasi Pada Python",
    "text": "Implementasi Pada Python\nLANGKAH 1 :  Deklarasi kamus (dictionary) abjad_indeks -&gt; Kamus ini memetakan setiap huruf alfabet ke sebuah indeks numerik.\nabjad_indeks = {\n    'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5,\n    'f': 6, 'g': 7, 'h': 8, 'i': 9, 'j': 10,\n    'k': 11, 'l': 12, 'm': 13, 'n': 14, 'o': 15,\n    'p': 16, 'q': 17, 'r': 18, 's': 19, 't': 20,\n    'u': 21, 'v': 22, 'w': 23, 'x': 24, 'y': 25, 'z': 26\n}\nLANGKAH 2 :  Deklarasi variabel key -&gt; Nilai key ditetapkan ke 3, yang berarti setiap huruf dalam pesan akan digeser sebanyak 3 posisi dalam alfabet untuk enkripsi. Selanjutnya Input variabel pesan -&gt; Pesan yang akan dienkripsi.\n# Key untuk pergeseran\nkey = 3\n# Deklarasi variabel pesan: Pesan yang akan dienkripsi.\npesan = input(\"Masukkan pesan     : \")\ncleanPesan = pesan.replace(\" \", \"\")\nprint(\"Pesan Anda         :\",cleanPesan)\nPesan Anda : udinus\n\nProses Enkripsi\nLANGKAH 3 :  Inisialisasi pesan_terenkripsi: String kosong untuk menyimpan hasil enkripsi.\n\nIterasi melalui setiap huruf dalam pesan: Menggunakan loop for. Cek apakah huruf ada di abjad_indeks:\nJika Ya Hitung indeks baru dengan formula (abjad_indeks[huruf] + key) % 26. Ini menggeser posisi huruf dalam alfabet.\nCari huruf baru yang sesuai dengan indeks baru dari daftar kunci abjad_indeks dan tambahkan ke pesan_terenkripsi.\nJika Tidak (misalnya angka atau simbol): Tambahkan huruf tersebut langsung kepesan_terenkripsi tanpa perubahan.\n\n\npesan_terenkripsi = ''\nfor huruf in cleanPesan:\n    if huruf in abjad_indeks:\n        indeks = (abjad_indeks[huruf] + key) % 26\n        pesan_terenkripsi += list(abjad_indeks.keys())[indeks - 1]\n    else:\n        pesan_terenkripsi += huruf\n\nprint(\"Pesan terenkripsi:\", pesan_terenkripsi)\nPesan terenkripsi: xglqxv\n\n\nProses Dekripsi\nLANGKAH 4 :  Inisialisasi pesan_terdekripsi: String kosong untuk menyimpan hasil dekripsi.\n\nIterasi melalui setiap huruf dalam pesan: Menggunakan loop for. Cek apakah huruf ada di abjad_indeks:\nJika Ya Hitung indeks baru dengan formula (abjad_indeks[huruf] - key) % 26. Ini menggeser posisi huruf dalam alfabet.\nCari huruf baru yang sesuai dengan indeks baru dari daftar kunci abjad_indeks dan tambahkan ke pesan_terenkripsi.\nJika Tidak (misalnya angka atau simbol): Tambahkan huruf tersebut langsung kepesan_terenkripsi tanpa perubahan.\n\npesan_terdekripsi = ''\nfor huruf in pesan_terenkripsi:\n    if huruf in abjad_indeks:\n        indeks = (abjad_indeks[huruf] - key) % 26\n        pesan_terdekripsi += list(abjad_indeks.keys())[indeks - 1]\n    else:\n        pesan_terdekripsi += huruf\n\nprint(\"Pesan terdekripsi:\", pesan_terdekripsi)\nPesan terdekripsi:: udinus",
    "crumbs": [
      "Kriptografi Klasik",
      "1. Caesar Cipher"
    ]
  },
  {
    "objectID": "3_vigenere_cipher.html",
    "href": "3_vigenere_cipher.html",
    "title": "3. Vigenere Cipher",
    "section": "",
    "text": "Analogi Vigenere Cipher\nMisalnya, jika kita memiliki teks “HELLO” dan kunci “KEY”, kita akan menggeser huruf-huruf dalam teks “HELLO” sesuai dengan urutan huruf dalam kata kunci “KEY”.",
    "crumbs": [
      "Kriptografi Klasik",
      "3. Vigenere Cipher"
    ]
  },
  {
    "objectID": "3_vigenere_cipher.html#teks-editor",
    "href": "3_vigenere_cipher.html#teks-editor",
    "title": "3. Vigenere Cipher",
    "section": "",
    "text": "Silahkan download file installer dari Visual Studio Code. Klik download pada halaman web Visual Studio Code sesuai dengan sistem operasi yang digunakan.\n\n\n\n\nLaman VSCode\n\n\n\nSetelah selesai download, klik dua kali pada file installer.\nJika muncul peringatan Run as Administrator, klik Yes.\nKemudian akan tampil window Installer Microsoft Visual Studio Code. Untuk menyetujui License Agreement, pilih “I accept the agreement” lalu next.\n\n\n\n\nLicense Agreement VS Code\n\n\n\nLalu pilih lokasi instalasinya. Jika ingin menggunakan lokasi default dapat langsung klik next.\n\n\n\n\nLokasi instalasi VS Code\n\n\n\nMemilih lokasi shortcuts program. Jika ingin menggunakan default dapat langsung klik next.\nPada bagian Select Additional Tasks, terdapat beberapa tasks yang bisa diinstall atau tidak. Untuk memudahkan ketika membuka file melalui berkas atau explorer dapat dipilih semua dan klik next.\nKlik install dan jalankan Visual Studio Code\n\n\n\n\nvscode\n\n\n\n\n\n\n\n\nIntalasi Visual Studio Code",
    "crumbs": [
      "Kriptografi Klasik",
      "3. Vigenere Cipher"
    ]
  },
  {
    "objectID": "3_vigenere_cipher.html#web-browser",
    "href": "3_vigenere_cipher.html#web-browser",
    "title": "3. Vigenere Cipher",
    "section": "Web Browser",
    "text": "Web Browser\nWeb browser adalah perangkat lunak yang awalnya dirancang untuk menampilkan dokumen web/HTML. Namun, pada saat ini, web browser harus memiliki kemampuan untuk menginterpretasikan dan menjalankan JavaScript atau VBScript, menjalankan Java Applet, memahami dokumen XML, dan menjalankan dokumen khusus dengan menggunakan fasilitas plugin seperti file .swf Macromedia Flash, dan lain sebagainya. \nBanyak web browser yang dapat digunakan, dan paling umum digunakan adalah Google Chrome dan Mozilla Firefox atau dapat menggunakan web browser yang tersedia pada laptop atau pc yang digunakan seperti safari atau microsoft edge. \n\n\n\n\n\n\n\n\n\nChrome\n\n\n\n\n \n\n\n\n\n\nMozilla Firefox",
    "crumbs": [
      "Kriptografi Klasik",
      "3. Vigenere Cipher"
    ]
  },
  {
    "objectID": "3_vigenere_cipher.html#web-server",
    "href": "3_vigenere_cipher.html#web-server",
    "title": "3. Vigenere Cipher",
    "section": "Web Server",
    "text": "Web Server\nWeb Server adalah server HTTP yang bertugas menyediakan dokumen yang diminta oleh web browser. Saat ini, web server telah berkembang menjadi lebih kompleks karena harus melayani banyak fungsi dan bahkan menjadi pusat layanan-layanan lain. \nWeb server juga menjadi komponen yang sangat penting dalam application server. Sebagai server HTTP, web server harus dapat menangani permintaan dokumen yang diberikan oleh web browser dan juga harus bisa dikonfigurasi untuk berinteraksi dengan program-program seperti JSP, ASP, PHP, melalui CGI, dan sebagainya. Contoh-contoh web server yang populer antara lain Apache dan IIS (Internet Information Service). \nXAMPP \nXAMPP adalah sebuah web server open source yang dapat berjalan diberbagai sistem operasi seperti Windows, Linux, dan MacOS. \nXAMPP menyediakan semua komponen yang diperlukan untuk mengelola sebuah website, termasuk Apache, MySQL/MariaDB, PHP, dan Perl. XAMPP dapat digunakan untuk membuat web server lokal di komputer. \nUntuk menginstall XAMPP ikuti langkah-langkah berikut: \n\nUnduh file installer dari website XAMPP. Unduh sesuai dengan sistem operasi atau komputer yang digunakan. \n\n\n\n\nWeb XAMPP\n\n\n\nLakukan instalasi XAMPP sesuai panduan (wizard) yang ditampilkan dan pilih Yes untuk melanjutkan instalasi. Bila ada pesan error biarkan saja. \n\n\n\n\nPesan error\n\n\n\nPilih komponen yang Anda butuhkan dalam instalasi tersebut. Sebagai contoh, centang MySQL dan phpMyAdmin.\nTentukan direktori instalasi yang tepat, misalnya C:\\xampp.\nLanjutkan tahapan dan klik install.\n\n Untuk melihat konfigurasi php dapat membuka config pada baris apache lalu membuka php.ini \n\n\n\nApache Config\n\n\nCek versi php dan ekstensi lain dengan cara membuat file “info.php” yang isinya &lt;?php phpinfo(); ?&gt;, letakkan pada C:\\xampp\\htdocs. Lalu buka localhost/info.php pada browser\n\n\n\n\n\n\nInstalasi Xampp",
    "crumbs": [
      "Kriptografi Klasik",
      "3. Vigenere Cipher"
    ]
  },
  {
    "objectID": "3_vigenere_cipher.html#bootstrap",
    "href": "3_vigenere_cipher.html#bootstrap",
    "title": "3. Vigenere Cipher",
    "section": "Bootstrap",
    "text": "Bootstrap\nBootstrap adalah sebuah kerangka kerja (framework) front-end yang populer untuk pengembangan desain web responsif (responsive web design). Dikembangkan oleh tim Twitter, Bootstrap menyediakan serangkaian komponen dan gaya CSS yang dapat digunakan untuk membangun tampilan web yang konsisten, menarik, dan responsif secara cepat. Sampai dengan modul ini dibuat, Bootstrap telah mengalami pembaruan Bootstrap versi 5.\n\n\n\n\nBootstrap\n\n\n\nCara instalasi Bootstrap \n\nBuka halaman resmi Bootstrap di https://getbootstrap.com.\nDi halaman utama, Anda akan melihat tombol “Download” di bagian bawah. Klik tombol tersebut untuk mengunduh file Bootstrap. \n\n\n\n\n\n\n\n\n\n\nTampilan Halaman Bootstrap\n\n\n\n\n \n\n\n\n\n\nDownload Paket Bootstrap\n\n\n\n\n\n\nSetelah selesai mengunduh, ekstrak file zip Bootstrap yang telah diunduh ke direktori proyek web Anda. \n\n\n\n\nEkstrak File\n\n\n\nDi dalam direktori proyek, buatlah folder baru (misalnya “css” dan “js”) untuk menyimpan file CSS dan JavaScript Bootstrap. \n\n\n\n\nEkstrak File\n\n\n\nSalin file bootstrap.min.css yang ada di dalam direktori “dist/css” dalam file Bootstrap yang telah diekstrak, ke dalam folder “css” di dalam direktori proyek Anda.\nSalin file bootstrap.min.js yang ada di dalam direktori “dist/js” dalam file Bootstrap yang telah diekstrak, ke dalam folder “js” di dalam direktori proyek Anda.\nSetelah itu, Anda dapat menggunakan Bootstrap dengan menautkan file CSS dan JavaScript ke dalam halaman HTML Anda. Dalam elemen &lt;head&gt; dari file HTML, tambahkan tag link berikut untuk menautkan file CSS Bootstrap: \n\n&lt;link rel=\"stylesheet\" href=\"css/bootstrap.min.css\"&gt;\n\nJuga di dalam elemen &lt;body&gt; atau sebelum penutup tag &lt;/body&gt; dalam file HTML, tambahkan tag script berikut untuk menautkan file JavaScript Bootstrap: \n\n&lt;script src=\"js/bootstrap.min.js\"&gt;&lt;/script&gt; \n\nSekarang, Anda dapat menggunakan kelas-kelas, komponen, dan gaya Bootstrap dalam halaman web Anda.Sekarang, Anda dapat menggunakan kelas-kelas, komponen, dan gaya Bootstrap dalam halaman web Anda.\n\n\n\n\n\n\n\nInstalasi Bootstrap\n\n\n\nBerikut adalah penjelasan mengenai instalasi bootstrap!",
    "crumbs": [
      "Kriptografi Klasik",
      "3. Vigenere Cipher"
    ]
  },
  {
    "objectID": "3_vigenere_cipher.html#implementasi-pada-python",
    "href": "3_vigenere_cipher.html#implementasi-pada-python",
    "title": "3. Vigenere Cipher",
    "section": "Implementasi Pada Python",
    "text": "Implementasi Pada Python\nLANGKAH 1 :  Deklarasi kamus (dictionary) abjad -&gt; Kamus ini memetakan setiap huruf alfabet ke sebuah indeks numerik.\nabjad = {\n    'A': 1, 'B': 2, 'C': 3, 'D': 4, 'E': 5,\n    'F': 6, 'G': 7, 'H': 8, 'I': 9, 'J': 10,\n    'K': 11, 'L': 12, 'M': 13, 'N': 14, 'O': 15,\n    'P': 16, 'Q': 17, 'R': 18, 'S': 19, 'T': 20,\n    'U': 21, 'V': 22, 'W': 23, 'X': 24, 'Y': 25, 'Z': 26\n}\nLANGKAH 2 :  Masukkan Plaintext dan Kunci\n# Input teks asli dan kunci\nteks = input(\"Masukkan Plaintext : \")\nkunci = \"key\"\nteks = teks.upper()\nkunci = kunci.upper()\nMasukkan Plaintext : udinus24\n\nProses Enkripsi\nLANGKAH 3 :  Melakukan Enkripsi\n# Inisialisasi variabel hasil\npesan_terenkripsi = ''\npanjang_kunci = len(kunci)\nindeks_kunci = 0\n\n# Iterasi melalui setiap karakter di teks asli\nfor huruf in teks:\n    # Periksa apakah karakter adalah huruf alfabet\n    if huruf in abjad:\n        # Temukan indeks dari teks asli dan kunci\n        indeks_teks = abjad[huruf]\n        huruf_kunci = kunci[indeks_kunci % panjang_kunci]\n        indeks_huruf_kunci = abjad[huruf_kunci]\n\n        # Hitung indeks hasil menggunakan rumus Vigenere cipher\n        indeks_hasil = (indeks_teks + indeks_huruf_kunci - 1) % 26 + 1\n\n        # Temukan karakter hasil berdasarkan indeks\n        for k, v in abjad.items():\n            if v == indeks_hasil:\n                pesan_terenkripsi += k\n                break\n\n        # Pindah ke karakter berikutnya dalam kunci\n        indeks_kunci += 1\n    else:\n        # Jika karakter bukan alfabet, tambahkan tanpa perubahan\n        pesan_terenkripsi += huruf\nCETAK HASIL ENKRIPSI : \nteks_per_huruf = ', '.join(f\"'{char}'\" for char in teks)\n# Menyusun kunci berulang sesuai panjang teks asli\nkunci_berulang = (kunci * (len(teks) // panjang_kunci)) + kunci[:len(teks) % panjang_kunci]\nkunci_per_huruf = ', '.join(f\"'{char}'\" for char in kunci_berulang)\n# output\nhasil_encrypt = ', '.join(f\"'{char}'\" for char in pesan_terenkripsi)\n\nprint(f\"Plaintext     : {teks_per_huruf}\")\nprint(\"\")\nprint(f\"Kunci         : {kunci_per_huruf}\")\nprint(\"\")\nprint(f\"Hasil Encrypt : {hasil_encrypt}\")\nPlaintext     : 'U', 'D', 'I', 'N', 'U', 'S', '2', '4' \nKunci         : 'K', 'E', 'Y', 'K', 'E', 'Y', 'K', 'E' \nHasil Encrypt : 'F', 'I', 'H', 'Y', 'Z', 'R', '2', '4' \n\n\nProses Dekripsi\nLANGKAH 4 :  Melakukan Dekripsi\n# Inisialisasi variabel hasil\npesan_terdekripsi = ''\npanjang_kunci = len(kunci)\nindeks_kunci = 0\n\n# Iterasi melalui setiap karakter di teks asli\nfor huruf in pesan_terenkripsi:\n    # Periksa apakah karakter adalah huruf alfabet\n    if huruf in abjad:\n        # Temukan indeks dari teks asli dan kunci\n        indeks_teks = abjad[huruf]\n        huruf_kunci = kunci[indeks_kunci % panjang_kunci]\n        indeks_huruf_kunci = abjad[huruf_kunci]\n\n        # Hitung indeks hasil menggunakan rumus Vigenere cipher\n        indeks_hasil = (indeks_teks - indeks_huruf_kunci - 1) % 26 + 1\n\n        # Temukan karakter hasil berdasarkan indeks\n        for k, v in abjad.items():\n            if v == indeks_hasil:\n                pesan_terdekripsi += k\n                break\n\n        # Pindah ke karakter berikutnya dalam kunci\n        indeks_kunci += 1\n    else:\n        # Jika karakter bukan alfabet, tambahkan tanpa perubahan\n        pesan_terdekripsi += huruf\nCETAK HASIL DEKRIPSI : \nhasil_decrypt = ', '.join(f\"'{char}'\" for char in pesan_terdekripsi)\nprint(f\"Ciphertext    : {hasil_encrypt}\")\nprint(\"\")\nprint(f\"Kunci         : {kunci_per_huruf}\")\nprint(\"\")\nprint(f\"Hasil Decrypt : {hasil_decrypt}\")\nCiphertext    : 'F', 'I', 'H', 'Y', 'Z', 'R', '2', '4'\nKunci         : 'K', 'E', 'Y', 'K', 'E', 'Y', 'K', 'E'\nHasil Decrypt : 'U', 'D', 'I', 'N', 'U', 'S', '2', '4'",
    "crumbs": [
      "Kriptografi Klasik",
      "3. Vigenere Cipher"
    ]
  },
  {
    "objectID": "4_playfair.html#penjelasan-prosesnya",
    "href": "4_playfair.html#penjelasan-prosesnya",
    "title": "4. Playfair",
    "section": "Penjelasan prosesnya:",
    "text": "Penjelasan prosesnya:\nMenghitung jumlah baris untuk memuat teks dalam matriks\nif temp - bulat == 0:\n    baris = bulat\nelse:\n    if temp - bulat &lt; 0:\n        baris = bulat\n    else:\n        baris = bulat + 1\nprint(baris)\nFor More Detail :\n\ntemp : hasil pembagian panjang teks dengan jumlah kolom\nbulat: hasil pembagian yang dibulatkan ke bilangan bulat terdekat. Jika temp adalah bilangan bulat (tidak ada sisa), jumlah baris adalah bulat. Jika ada sisa, jumlah baris adalah bulat + 1\n\nMengisi matriks dengan karakter dari teks yang telah dibersihkan (cleanPlainTeks)\nfor i in range(baris):\n    row = []\n    for j in range(kolom):\n        if i * kolom + j &lt; len(cleanPlainTeks):\n            elemen = cleanPlainTeks[i * kolom + j]\n        else:\n            elemen = \" \"\n        row.append(elemen)\n    matrix.append(row)\nFor More Detail :\n\nfor i in range(baris) : Loop untuk setiap baris dalam matriks\nrow = [] : Inisialisasi list kosong untuk setiap baris\nif i * kolom + j &lt; len(cleanPlainTeks) : Memeriksa apakah indeks saat ini berada dalam rentang panjang teks yang dibersihkan.\nelemen = cleanPlainTeks[i * kolom + j] : Jika indeks berada dalam rentang, maka ambil karakter dari cleanPlainTeks berdasarkan indeks yang dihitung.\nelse : Jika indeks melebihi panjang teks, isi elemen dengan spasi.\nrow.append(elemen) : Menambahkan elemen ke dalam baris.\nmatrix.append(row) : Menambahkan baris yang telah diisi ke dalam matriks.`\n\nMencetak matriks\nprint(\"Matriks yang Anda buat:\")\nfor row in matrix:\n    print(row)\nMentransposisikan matriks yang telah dibuat dan kemudian mencetak matriks yang telah ditransposisikan\ntransposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\nfor row in transposed_matrix:\n    print(row)\nFor More Detail :\n\nfor i in range(len(matrix[0])) : Iterasi melalui indeks kolom matriks asli\nrow[i] for row in matrix : Untuk setiap indeks kolom i, ambil elemen i dari setiap baris dalam matriks asli dan akan menghasilkan kolom baru dari elemen-elemen tersebut, membentuk baris baru di matriks yang ditransposisikan\n\nMembuat list kosong dengan panjang yang sama dengan cleanKey untuk menyimpan urutan indeks\norder = [None] * len(cleanKey)\nMengurutkan elemen-elemen dalam cleanKey berdasarkan nilai terkecil hingga terbesar\ni = 0\nwhile len(cleanKey) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, cleanKey))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = cleanKey.index(nilai_terkecil)\n\n        order[marker] = i\n        cleanKey[marker] = None \n        i = i + 1\n    else:\n        break\nprint(order)\nFor More Detail :\n\ni = 0 : Inisialisasi counter i\nwhile len(cleanKey) &gt; 0 : Loop hingga cleanKey kosong (semua elemen None)\nnon_none_values = list(filter(lambda x: x is not None, cleanKey)) : Membuat list yang hanya berisi elemen-elemen cleanKey yang bukan None\nif non_none_values : Mengecek apakah list non_none_values tidak kosong nilai_terkecil = min(non_none_values) : Mencari nilai terkecil dari non_none_values\nmarker = cleanKey.index(nilai_terkecil) : Mendapatkan indeks dari nilai terkecil dalam cleanKey Menyimpan Urutan dan Menghapus Nilai Terkecil:\norder[marker] = i : Menyimpan urutan i pada indeks marker di list order\ncleanKey[marker] = None : Menghapus nilai terkecil dari cleanKey dengan mengubahnya menjadi None\ni = i + 1 : Increment counter i.\n\nMengubah urutan kolom matriks transposed_matrix berdasarkan urutan yang telah diatur dalam order, dan kemudian mencetak matriks yang sudah diubah urutan kolomnya\nnew_matrix = []\nwhile len(order) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, order))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = order.index(nilai_terkecil)\n       \n        new_matrix.append(transposed_matrix[marker])\n        order[marker] = None\n    else:\n        break\n\nfor row in new_matrix:\n    print(row)\nFor More Detail :\n\nnew_matrix = [] : Membuat list kosong new_matrix untuk menampung baris-baris matriks yang baru diurutkan Looping untuk Mengubah Urutan Kolom:\nwhile len(order) &gt; 0 : Melakukan looping selama masih ada elemen yang tersisa dalam order\nnon_none_values = list(filter(lambda x: x is not None, order)) : Membuat list non_none_values yang hanya berisi nilai-nilai yang bukan None dari order\nif non_none_values : Memeriksa apakah non_none_values tidak kosong\nnilai_terkecil = min(non_none_values) : Menemukan nilai terkecil dari non_none_values\nmarker = order.index(nilai_terkecil) : Mencari indeks dari nilai_terkecil dalam order\nnew_matrix.append(transposed_matrix[marker]) : Menambahkan baris dari transposed_matrix yang sesuai dengan marker ke new_matrix\norder[marker] = None : Menghapus nilai yang telah diproses dengan mengubahnya menjadi None\nelse: break : Menghentikan loop jika non_none_values kosong, yang berarti semua nilai dalam order telah diproses\n\nMengonversi matriks new_matrix menjadi string tunggal dengan menggabungkan nilai-nilainya secara berurutan dan menghapus spasi ekstra di akhir string\nresult_string = \"\"\n\nfor row in new_matrix:\n    for value in row:\n        result_string += str(value)\n\nresult_string = result_string.strip()\n\nprint(result_string)\nFor More Detail :\n\nresult_string = \"\" : Inisialisasi string kosong result_string yang akan digunakan untuk menyimpan hasil akhir\nfor row in new_matrix: : Melakukan iterasi melalui setiap baris dalam new_matrix\nfor value in row: : Melakukan iterasi melalui setiap nilai dalam baris row\nresult_string += str(value) : Mengonversi nilai value menjadi string (jika belum string) dan menambahkannya ke result_string\nresult_string = result_string.strip() : Menghapus spasi ekstra di awal dan akhir string menggunakan metode strip()\n\nHasil Ciphertext : ENTKFINOKKM TIAIRA\n\nProses Dekripsi\ncipherTeks = input(\"masukkan kata : \")\nkey = input(\"masukkan kunci : \")\ncleanCipherTeks = cipherTeks.replace(\" \", \" \")\nprint(cleanCipherTeks)\nkolom = 0\nangka_urutan = []\nfor huruf in key:\n    if huruf.isalpha():\n        angka_urutan.append(ascii[huruf.lower()])\n        kolom = kolom+1\n        cleanKey = angka_urutan\n\nprint(f\"Urutan kunci dari kata '{key}' adalah: {angka_urutan}\")\nmatrix = []\npanjang = len(cleanCipherTeks)\ntemp = panjang/kolom\nbaris = round(temp)\nprint(baris)\nfor i in range(baris):\n    row = []\n    for j in range(kolom):\n        if i * kolom + j &lt; len(cleanCipherTeks):\n            elemen = cleanCipherTeks[i + baris * j]\n        else:\n            elemen = \"a\"\n        row.append(elemen)\n    matrix.append(row)\nprint(\"Matriks yang Anda buat:\")\nfor row in matrix:\n    print(row)\ntransposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\nfor row in transposed_matrix:\n    print(row)\norder = [None] * len(cleanKey)\ni = 0\nwhile len(cleanKey) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, cleanKey))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = cleanKey.index(nilai_terkecil)\n        order[marker] = i\n        cleanKey[marker] = None  \n        i = i + 1\n    else:\n        break\nprint(order)\ntransposed_matrix = [transposed_matrix[i] for i in order]\n\nfor row in transposed_matrix:\n    print(row)\nmatriks = [[row[i] for row in transposed_matrix] for i in range(len(transposed_matrix[0]))]\nfor row in matriks:\n    print(row)\nresult_string = \"\"\n\nfor row in matriks:\n    for value in row:\n        result_string += str(value)\n\nresult_string = result_string.strip()\n\nprint(result_string)\nHasil Dekripsi : TEKNIKINFORMATIKA\nPerbedaan Proses :\n\nEnkripsi: Teks asli diubah menjadi matriks berdasarkan kolom kunci, kemudian kolom-kolom diurutkan berdasarkan kunci. Pada enkripsi, transposed_matrix adalah matriks transposisi dari matrix awal\nDekripsi: Teks sandi diubah menjadi matriks berdasarkan kolom kunci, kemudian baris-baris diurutkan berdasarkan kunci untuk mengembalikan teks asli. Pada dekripsi, transposed_matrix diurutkan berdasarkan order untuk mengembalikan teks asli",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Playfair"
    ]
  },
  {
    "objectID": "4_playfair.html#pemrosesan-kunci",
    "href": "4_playfair.html#pemrosesan-kunci",
    "title": "4. Playfair",
    "section": "Pemrosesan Kunci",
    "text": "Pemrosesan Kunci\nMenghilangkan spasi pada kunci dan membuat kunci menjadi lowercase\nkey_playfair = key_playfair.replace(' ','').lower()\nprint(key_playfair)\nMenghapus huruf ‘j’ jika ada di kunci\nkey_playfair = key_playfair.replace('j', '')\nprint(key_playfair)\nMenghapus huruf yang berulang\nkey_result = []\nfor i in key_playfair:\n  if i not in key_result:\n    key_result.append(i)\nprint(key_result)\nperulangan untuk menghapus huruf yang berulang dengan menambahkan kondisi apakah huruf tersebut sudah ditambahkan ke list key_result\nMenambahkan sisa huruf alphabet yang belum ada ke dalam matrix kunci\nfor i in abjad:\n  if i != 'j' and i not in key_result:\n    key_result.append(i)\nprint(key_result)\nMembuat matrix kunci 5x5\nkey_created = []\nwhile key_result!= []:\n  key_created.append(key_result[:5])\n  key_result = key_result[5:]\nfor row in key_created:\n        print(row)",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Playfair"
    ]
  },
  {
    "objectID": "4_playfair.html#proses-enkripsi",
    "href": "4_playfair.html#proses-enkripsi",
    "title": "4. Playfair",
    "section": "Proses Enkripsi",
    "text": "Proses Enkripsi\nMengganti huruf ‘j’ yang ada di plainteks menjadi huruf ‘i’\nplaintext_playfair = plaintext_playfair.replace('j', 'i')\nprint(plaintext_playfair)\nProses pembuatan plaintext menjadi bentuk bigram atau pasangan huruf\nbigram_plaintext = []\n# perulangan untuk menambahkan pasangan huruf atau bigram ke dalam list bigram_plaintext\ni = 0\nwhile i&lt;len(plaintext_playfair):\n  x = plaintext_playfair[i]\n  y = ''\n\n  # situasi jika berada di huruf terakhir di plaintext\n  if((i+1) == len(plaintext_playfair)):\n    y = 'z'\n  else:\n    y = plaintext_playfair[i+1]\n\n  # jika hurufnya keduanya sama, maka disisipkan z di tengahnya\n  if(x!=y):\n    bigram_plaintext.append(x+y)\n    i += 2\n  else:\n    bigram_plaintext.append(x+'z')\n    i += 1\nprint(bigram_plaintext)\nPenjelasan prosesnya:\n\nbigram_plaintext = [] adalah sebuah list kosong yang akan diisi dengan pasangan huruf (bigram) yang diambil dari plaintext_playfair.\nwhile loop digunakan untuk iterasi melalui teks plaintext_playfair sampai semua huruf di teks tersebut telah diproses. Loop ini akan berlanjut selama i kurang dari panjang teks plaintext_playfair. Jadi perulangan ini digunakan untuk memproses semua huruf yang ada di plaintext_playfair.\nx = plaintext_playfair[i] dan y = '' adalah variabel yang digunakan untuk menampung huruf bigram pertama dan kedua dengan inisiasi nilai awal itu nilai dari plaintext_playfair[i] dan string kosong.\nSelanjutnya untuk pengkondisian pertama itu digunakan untuk kondisi dimana sudah sampai huruf terkahir dalam plaintext_playfair.\nTerakhir untuk pengkondisian kedua itu digunakan untuk kondisi dimana kedua hurufnya itu sama.\n\nProses substitusi plainteks dengan 3 aturan yang sudah di jelaskan diatas\nbigram_ciphertext = []\n# perulangan untuk mencari bigram ciphertex\nfor bigram in bigram_plaintext:\n  flag = False\n  # cek aturan 1, apakah pasangan huruf plaintext berada di baris yang sama\n  for row in key_created:\n    # jika berada di baris yang sama maka huruf yang berada di sebelah kanannya ditambahkan ke bigram ciphertext\n    if(bigram[0] in row and bigram[1] in row):\n      x1 = row.index(bigram[0])\n      x2 = row.index(bigram[1])\n      cipher_created = row[(x1 + 1) % 5] + row[(x2 + 1) % 5]\n      bigram_ciphertext.append(cipher_created)\n      flag = True\n  if flag:\n    continue\n\n  # cek aturan 2, apakah pasangan huruf plaintext berada di kolom yang sama\n  for j in range(5):\n    col = ''.join([key_created[i][j] for i in range(5)])\n    # jika berada di kolom yang sama maka huruf yang berada di bawahnya ditambahkan ke bigram ciphertext\n    if(bigram[0] in col and bigram[1] in col):\n      y1 = col.index(bigram[0])\n      y2 = col.index(bigram[1])\n      cipher_created = col[(y1 + 1) % 5] + col[(y2 + 1) % 5]\n      bigram_ciphertext.append(cipher_created)\n      flag = True\n  if flag:\n    continue\n\n  foundOne = False\n  foundTwo = False\n\n  # cek aturan 3, apakah pasangan huruf plaintext berada di baris dan kolom yang berbeda\n  for i in range(5):\n    row = key_created[i]\n    # jika huruf pertama dalam bigram ada pada baris urutan ke 'i'\n    if(bigram[0] in row):\n      x1 = i\n      y1 = row.index(bigram[0])\n      foundOne = True\n    # jika huruf kedua dalam bigram ada pada baris urutan ke 'i'\n    if(bigram[1] in row):\n      x2 = i\n      y2 = row.index(bigram[1])\n      foundTwo = True\n    # jika kedua posisi pasangan huruf atau bigram sudah diketahui, maka pembentukan cipher sesuai aturan ketiga dilakukan\n    if foundOne and foundTwo:\n      cipher_created = key_created[x1][y2] + key_created[x2][y1]\n      bigram_ciphertext.append(cipher_created)\n      break\nprint(bigram_ciphertext)\nPenjelasan prosesnya:\n\nbigram_ciphertext adalah list kosong yang akan diisi dengan pasangan huruf (bigram) yang telah dienkripsi dari bigram_plaintext.\nfor bigram in bigram_plaintext: digunakan untuk iterasi melalui setiap bigram yang ada dalam bigram_plaintext.\nflag = False adalah variabel boolean yang digunakan untuk menandai apakah aturan tertentu sudah dipenuhi sehingga tidak perlu memeriksa aturan lainnya untuk bigram yang sama.\nPemeriksaan Aturan 1: Baris yang Sama\n\nfor row in key_created:\n    if(bigram[0] in row and bigram[1] in row):\n        x1 = row.index(bigram[0])\n        x2 = row.index(bigram[1])\n        cipher_created = row[(x1 + 1) % 5] + row[(x2 + 1) % 5]\n        bigram_ciphertext.append(cipher_created)\n        flag = True\n\nLoop ini memeriksa setiap baris (row) dalam matriks kunci (key_created).\nJika kedua huruf dalam bigram (bigram[0] dan bigram[1]) berada di baris yang sama (row), maka:\n\nIndeks masing-masing huruf dalam baris ditemukan (x1 dan x2).\nHuruf di sebelah kanan dari masing-masing huruf ditentukan dengan menggunakan (index + 1) % 5 untuk menangani kasus melingkar (huruf di ujung kanan).\nHuruf-huruf ini kemudian digabungkan menjadi cipher_created dan ditambahkan ke bigram_ciphertext.\nflag diatur ke True untuk menandai bahwa aturan ini telah diterapkan, dan loop berhenti memeriksa aturan lain untuk bigram ini.\n\nLanjut ke Bigram Berikutnya Jika Aturan 1 Terpenuhi\n\nif flag:\n    continue\n\nJika flag True, bigram ini sudah diproses, dan loop lanjut ke bigram berikutnya tanpa memeriksa aturan lainnya.\nPemeriksaan Aturan 2: Kolom yang Sama\n\nfor j in range(5):\n    col = ''.join([key_created[i][j] for i in range(5)])\n    if(bigram[0] in col and bigram[1] in col):\n        y1 = col.index(bigram[0])\n        y2 = col.index(bigram[1])\n        cipher_created = col[(y1 + 1) % 5] + col[(y2 + 1) % 5]\n        bigram_ciphertext.append(cipher_created)\n        flag = True\n\nLoop ini memeriksa setiap kolom dalam matriks kunci (key_created).\nSetiap kolom (col) dibentuk dengan menggabungkan huruf-huruf dari setiap baris pada indeks j.\nJika kedua huruf dalam bigram (bigram[0] dan bigram[1]) berada di kolom yang sama (col), maka:\n\nIndeks masing-masing huruf dalam kolom ditemukan (y1 dan y2).\nHuruf di bawah masing-masing huruf ditentukan dengan menggunakan (index + 1) % 5 untuk menangani kasus melingkar (huruf di ujung bawah).\nHuruf-huruf ini kemudian digabungkan menjadi cipher_created dan ditambahkan ke bigram_ciphertext.\nflag diatur ke True, dan loop berhenti memeriksa aturan lain untuk bigram ini.\n\nLanjut ke Bigram Berikutnya Jika Aturan 2 Terpenuhi\n\nif flag:\n    continue\n\nJika flag True, bigram ini sudah diproses, dan loop lanjut ke bigram berikutnya tanpa memeriksa aturan lainnya.\nPemeriksaan Aturan 3: Baris dan Kolom Berbeda\n\nfoundOne = False\nfoundTwo = False\n\nfor i in range(5):\n    row = key_created[i]\n    if(bigram[0] in row):\n        x1 = i\n        y1 = row.index(bigram[0])\n        foundOne = True\n    if(bigram[1] in row):\n        x2 = i\n        y2 = row.index(bigram[1])\n        foundTwo = True\n    if foundOne and foundTwo:\n        cipher_created = key_created[x1][y2] + key_created[x2][y1]\n        bigram_ciphertext.append(cipher_created)\n        break\n\nLoop ini memeriksa setiap baris dalam matriks kunci (key_created) untuk menemukan posisi huruf pertama dan kedua dari bigram.\nJika huruf pertama (bigram[0]) ditemukan dalam baris i, indeks baris (x1) dan kolom (y1) disimpan, dan foundOne diatur ke True.\nJika huruf kedua (bigram[1]) ditemukan dalam baris i, indeks baris (x2) dan kolom (y2) disimpan, dan foundTwo diatur ke True.\nJika kedua huruf ditemukan (foundOne dan foundTwo), aturan ketiga diterapkan:\n\nHuruf di posisi silang yang berlawanan diambil dari matriks kunci: key_created[x1][y2] dan key_created[x2][y1].\nHuruf-huruf ini digabungkan menjadi cipher_created dan ditambahkan ke bigram_ciphertext.\nLoop dihentikan dengan break karena bigram telah diproses.\n\n\nHasil enkripsi\nhasil_enkripsi = ''.join(bigram_ciphertext)\nprint(hasil_enkripsi)",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Playfair"
    ]
  },
  {
    "objectID": "4_playfair.html#proses-dekripsi",
    "href": "4_playfair.html#proses-dekripsi",
    "title": "4. Playfair",
    "section": "Proses Dekripsi",
    "text": "Proses Dekripsi\nMemasukkan ciphertext\nciphertext_playfair = input(\"Masukkan teks yang akan di dekripsi: \")\nProses pembuatan ciphertext menjadi bentuk bigram atau pasangan huruf\nbigram_ciphertext = [ciphertext_playfair[i:i+2] for i in range(0, len(ciphertext_playfair), 2)]\nprint(bigram_ciphertext)\nProses substitusi Cipherteks dengan 3 aturan yang sudah di jelaskan diatas\nbigram_dekripsi = []\n# perulangan untuk mencari bigram decrypt text\nfor bigram in bigram_ciphertext:\n  flag = False\n  # cek aturan 1, apakah pasangan huruf ciphertext berada di baris yang sama\n  for row in key_created:\n    # jika berada di baris yang sama maka huruf yang berada di sebelah kanannya ditambahkan ke bigram decrypt text\n    if(bigram[0] in row and bigram[1] in row):\n      x1 = row.index(bigram[0])\n      x2 = row.index(bigram[1])\n      decrypt_created = row[(x1 - 1) % 5] + row[(x2 - 1) % 5]\n      bigram_dekripsi.append(decrypt_created)\n      flag = True\n  if flag:\n    continue\n\n  # cek aturan 2, apakah pasangan huruf ciphertext berada di kolom yang sama\n  for j in range(5):\n    col = ''.join([key_created[i][j] for i in range(5)])\n    # jika berada di kolom yang sama maka huruf yang berada di bawahnya ditambahkan ke bigram decrypt text\n    if(bigram[0] in col and bigram[1] in col):\n      y1 = col.index(bigram[0])\n      y2 = col.index(bigram[1])\n      decrypt_created = col[(y1 - 1) % 5] + col[(y2 - 1) % 5]\n      bigram_dekripsi.append(decrypt_created)\n      flag = True\n  if flag:\n    continue\n\n  foundOne = False\n  foundTwo = False\n\n  # cek aturan 3, apakah pasangan huruf ciphertext berada di baris dan kolom yang berbeda\n  for i in range(5):\n    row = key_created[i]\n    # jika huruf pertama dalam bigram ada pada baris urutan ke 'i'\n    if(bigram[0] in row):\n      x1 = i\n      y1 = row.index(bigram[0])\n      foundOne = True\n    # jika huruf kedua dalam bigram ada pada baris urutan ke 'i'\n    if(bigram[1] in row):\n      x2 = i\n      y2 = row.index(bigram[1])\n      foundTwo = True\n    # jika kedua posisi pasangan huruf atau bigram sudah diketahui, maka pembentukan cipher sesuai aturan ketiga dilakukan\n    if foundOne and foundTwo:\n      decrypt_created = key_created[x1][y2] + key_created[x2][y1]\n      bigram_dekripsi.append(decrypt_created)\n      break\nprint(bigram_dekripsi)\nHasil dekripsi\nhasil_dekripsi = ''.join(bigram_dekripsi)\nprint(hasil_dekripsi)",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Playfair"
    ]
  },
  {
    "objectID": "6_transposisi_myzkowski.html",
    "href": "6_transposisi_myzkowski.html",
    "title": "6. Transposisi Myzkowski",
    "section": "",
    "text": "Prinsip Dasar",
    "crumbs": [
      "Kriptografi Klasik",
      "6. Transposisi Myzkowski"
    ]
  },
  {
    "objectID": "6_transposisi_myzkowski.html#tipe-data",
    "href": "6_transposisi_myzkowski.html#tipe-data",
    "title": "6. Transposisi Myzkowski",
    "section": "Tipe Data",
    "text": "Tipe Data\nTipe Data dalam ilmu komputer erat kaitannya dengan pemrgoraman dan database. Didalam pemrograman tipe data biasa digunakan untuk mendefinisikan (menetapkan) isi dari sebuah variabel.\nPerbedaannya dalam database, tipe data ini digunakan untuk menentukan isi dari sebuah data yang akan disimpan.\nTipe data ini berbeda-beda tergantung dari bahasa pemgrograman atau jenis database yang kita gunakan.\nTipe data ini akan dikelompokan menjadi 5 bagian utama. Pada tipe data dalam MySQL dibagi menjadi 3, yaitu :\n\nTipe Data Numerik,\nTipe Data String, dan\nTipe Data Date/Time.\n\n\nTipe Data Numerik\nAdalah tipe data numerik untuk mengukur nilai secara matematik, misalnya mata uang, angka desimal, dll.\n\n\nTabel Tipe Data Numerik\n\n\n\n\n\n\n\n\nNo\nTipe\nKeterangan\nPenerapan\n\n\n\n\n1.\nINTEGER(size)\nTipe data yang berisi kumpulan bilangan bulat, baik dalam bentuk bilangan positif maupun negatif\nAngka secara umum\n\n\n2.\nFLOAT(size)\nBilangan desimal dengan presisi tunggal (single-precision)\nπ, desimal dengan fokus pada nilai input contoh : 3.14159265359\n\n\n3.\nDOUBLE(size, d)\nBilangan desimal dengan presisi ganda (double-precision). Jumlah total digit ditentukan oleh size, jumlah digit setelah titik decimal ditentukan oleh d\nUang, dengan fokus jumlah desimal 2 angka di belakang koma  contoh: 2.500,00\n\n\n\n\n\n\nTipe Data String\nMerupakan suatu teks dengan panjang variabel dimana setiap huruf dapat memiliki ukuran lebih kecil atau besar daripada satuan lainnya. Misalkan nama depan, nama belakang, alamat, nomor telepon, website, serta informasi lainnya.\n\n\nTabel Tipe Data String\n\n\n\n\n\n\n\n\nNo\nTipe\nKeterangan\nPenerapan\n\n\n\n\n1.\nCHAR(size)\nMenyatakan deretan karakter (String) yang lebarnya tetap.  Size : 0 hingga 255 karakter\nJenis_kelamin (L/P)  contoh : L\n\n\n2.\nVARCHAR(size)\nMenyatakan data String yang lebarnya bervariasi.  Size : 0 hingga 255 karakter\nNama pengguna  contoh : Amanda\n\n\n3.\nTEXT(size, d)\nMenampung string Panjang yang lebarnya tidak dapat diprediksi.\n\n\n\n\n\n\n\nTipe Data Date\nMenyimpan tanggal dan waktu dalam format tertentu seperti tahun, bulan, dan hari, jam, menit, dan detik. Tipe data date bisa digunakan untuk mengatur kronologis dari peristiwa.\n\n\nTabel Tipe Data Date\n\n\n\n\n\n\n\n\nNo\nTipe\nKeterangan\nPenerapan\n\n\n\n\n1.\nDATE(size)\nDigunakan dengan tanggal dengan format “YYYY-MM-DD”\n2004-09-21\n\n\n2.\nTIME(size)\nDigunakan untuk waktu dengan format “hh:mm:ss”\n12:33:12\n\n\n3.\nDATETIME(size, d)\nDigunakan untuk tanggal dan waktu dengan format “YYYY-MM-DD hh:mm:ss”\n2012-11-29 11:55:23",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Transposisi Myzkowski"
    ]
  },
  {
    "objectID": "6_transposisi_myzkowski.html#constraint-kekangan-nilai",
    "href": "6_transposisi_myzkowski.html#constraint-kekangan-nilai",
    "title": "6. Transposisi Myzkowski",
    "section": "Constraint / Kekangan Nilai",
    "text": "Constraint / Kekangan Nilai\nConstraint atau kekangan nilai digunakan untuk menentukan aturan yang mengizinkan atau membatasi nilai yang akan dimasukkan dalam tabel. Kekangan Nilai Menyediakan Metode Yang sesuai untuk memastikan akurasi dan integritas data di dalam table.\nContoh constraint, yaitu :\n\nMembuat Nilai Tidak Kosong(NOT NULL)\nMembuat Nilai Unik(UNIQUE)\nMembuat kenaikan nilai secara otomatis(AUTO INCREMENT)\nMembuat Kunci tamu(FOREIGN KEY)\nMenggunakan Alias table dan query antartable (INNER JOIN)\n\n\nConstraint NOT NULL\nConstraint NOT NULL mengatur agar data tertentu harus terisi atau tidak kosong. Ada kolom tertentu dari suatu table harus terisi dengan nilai valid. Contoh case :\nCREATE TABLE `mahasiswa`(\n    `nama` VARCHAR(50), NOT NULL,\n    `nim` VARCHAR(30) NOT NULL  \n)\nUntuk case di atas maka nama dan nim yang diinputkan ke dalam database tidak boleh kosong.\n\n\nConstraint UNIQUE\nConstraint UNIQUE ditujukan untuk memastikan bahwa nilai dalam kolom unik, artinya kolom tidak dapat menyimpan nilai duplikat. Contoh case:\nCREATE TABLE `mahasiswa`(\n    `nama` VARCHAR(50) NOT NULL,\n    `nim` VARCHAR(50) NOT NULL UNIQUE\n)\nUntuk case di atas nama mahasiswa bisa saja sama, tapi NIM mahasiswa tidak akan pernah sama maka diberi Constraint UNIQUE\n\n\nConstraint AUTO INCREMENT\nAuto increment digunakan untuk menaikkan nilai secara otomatis pada field numerik. Ada beberapa hal yang harus diperhatikan dalam menggunakan auto increment:\n\nHanya Dapat Digunakan Pada field numerik\nField harus bersifat primary key atau unik\nField tidak boleh bersifat null\nDalam Satu Tabel hanya ada satu field yang menggunakan auto increment\n\nCREATE TABLE `mahasiswa`(\n    `id` VARCHAR(11) NOT NULL AUTO_INCREMENT,\n    `nama` VARCHAR(50) NOT NULL,\n    `nim` VARCHAR(50) NOT NULL UNIQUE\n)",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Transposisi Myzkowski"
    ]
  },
  {
    "objectID": "6_transposisi_myzkowski.html#pembuatan-database",
    "href": "6_transposisi_myzkowski.html#pembuatan-database",
    "title": "6. Transposisi Myzkowski",
    "section": "Pembuatan Database",
    "text": "Pembuatan Database\nDalam pembuatan database dapat dibuat dalam 2 cara, yaitu menggunakan platform dan menggunakan scripting\n\n\n\n\n\n\n\n\n\nMenggunakan Platform\n\n\n\n\n\n\n\nMenggunakan scripting",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Transposisi Myzkowski"
    ]
  },
  {
    "objectID": "6_transposisi_myzkowski.html#perintah-mysql-ddl-dml-dcl",
    "href": "6_transposisi_myzkowski.html#perintah-mysql-ddl-dml-dcl",
    "title": "6. Transposisi Myzkowski",
    "section": "Perintah MySQL (DDL, DML, DCL)",
    "text": "Perintah MySQL (DDL, DML, DCL)\nSecara umum perintah fungsi MySQL dibagi menjadi 3, yaitu :\n\nDDL (Data Definition Language),\nDML(Data Manipulation), dan\nDCL (Data Control Language).\n\nPada modul ini akan dibatasi pada DDL dan DML untuk praktek.\n\n\n\nDDL, DML, DCL\n\n\n\nData Definition Language (DDL)\nData Definition Language (DDL) adalah bagian dari SQL (Structured Query Language) yang digunakan untuk mendefinisikan struktur database dan objeknya, seperti tabel, tampilan, indeks, dan prosedur dalam sebuah database. Pernyataan DDL digunakan untuk membuat, mengubah, dan menghapus objek database, termasuk tabel, tampilan, indeks, dan prosedur tersimpan. Beberapa pernyataan DDL yang paling umum meliputi:\n\nCREATE\nPernyataan ini membuat objek database baru, seperti tabel, tampilan, atau indeks. Misalnya, pernyataan SQL berikut membuat tabel yang disebut “pelanggan”:\nCREATE TABLE pelanggan ( id INT PRIMARY KEY, name VARCHAR(255), address VARCHAR(255));\n\n\nALTER\nPernyataan ini digunakan untuk memodifikasi objek database yang sudah ada. Misalnya, pernyataan SQL berikut menambahkan kolom baru bernama ” email ” ke tabel ” customers “:\npelanggan ALTER TABLE ADD email VARCHAR(255);\n\n\nDROP\nPernyataan ini digunakan untuk menghapus objek database yang sudah ada. Misalnya, pernyataan SQL berikut menghapus tabel “pelanggan”:\npelanggan DROP TABLE;\n\n\nTRUNCATE\nPernyataan ini digunakan untuk menghapus semua baris dalam tabel, tetapi tidak seperti pernyataan DROP, pernyataan ini mempertahankan struktur dan indeks tabel. \n\n\nRENAME\nPernyataan ini digunakan untuk mengganti nama objek database yang sudah ada. Misalnya, pernyataan SQL berikut mengganti nama tabel “pelanggan” menjadi “klien”:\nRENAME TABLE pelanggan TO klien;\nPenting untuk dicatat bahwa pernyataan DDL dieksekusi segera dan bersifat permanen, artinya setelah objek dibuat, diubah, atau dihapus, perubahan tidak dapat diurungkan. Oleh karena itu, sangat penting untuk berhati-hati dan memastikan bahwa Anda memiliki cadangan basis data sebelum menjalankan pernyataan DDL apa pun. Selain itu, pernyataan DDL biasanya dijalankan oleh administrator database atau pengembang dengan hak istimewa dan izin yang sesuai untuk mengubah struktur database. \n\n\nSHOW\nPerintah DDL ini digunakan untuk menampilkan daftar database atau tabel yang ada.\nPenerapan :\nSHOW TABLES;\n\n\n\n\n\n\n\nLatihan DDL\n\n\n\n\nCreate Database Mahasiswa dan Table identitas \nCREATE DATABASE mahasiswa;\nCREATE TABLE identitas (`Nama` VARCHAR(250) NOT NULL PRIMARY KEY);\nAlter Table \nALTER TABLE identitas ADD NIM VARCHAR(15) UNIQUE\nRename Table \nRENAME TABLE identitas TO id_mahasiswa\nShow Table \nSHOW TABLES;\nDrop Table \nDROP TABLE id_mahasiswa\nCoba kreasikan Database kalian dengan perintah DDL! Buatlah Database kuliah berisi 2 table yaitu id_dosen dan id_mahasiswa Table id_dosen berisi kolom : nama, NIDN, Jabatan Table id_mahasiswa berisi kolom : nama, NIM, Prodi\n\n\n\n\n\n\nData Manipulation Language (DML)\nData Manipulation Language (DML) adalah bagian dari SQL (Structured Query Language) yang digunakan untuk memanipulasi data dalam database. Sehingga pernyataan DML ini dapat digunakan ketika database dan tabel telah dibuat. Pernyataan DML digunakan untuk menyisipkan, memperbarui, dan menghapus data dalam database. Beberapa pernyataan DML yang paling umum meliputi:\n\nINSERT\nPernyataan ini digunakan untuk memasukkan data baru ke dalam tabel. Sebagai ilustrasi, pernyataan SQL berikut menyisipkan baris baru ke dalam tabel “pelanggan”:\nINSERT INTO pelanggan (id, nama, alamat) VALUES (1, 'John Smith,' '123 Main St');\n\n\nSELECT\nPernyataan ini digunakan untuk mengambil data dari satu atau lebih tabel dalam database. Sebagai contoh, kueri SQL berikut mengambil semua rekaman dari tabel “pelanggan”:\nSELECT * FROM pelanggan;\n\n\nUPDATE\nPernyataan ini digunakan untuk memodifikasi data yang ada dalam sebuah tabel. Misalnya, pernyataan SQL berikut memperbarui alamat pelanggan dengan ID 1 di tabel “pelanggan”:\nUPDATE pelanggan SET address = '456 Park Ave' WHERE id = 1;\n\n\nDELETE\nPernyataan ini digunakan untuk menghapus data dari tabel. Misalnya, pernyataan SQL berikut menghapus pelanggan dengan ID 1 dari tabel “pelanggan”:\nDELETE FROM pelanggan WHERE id = 1;\n\n\n\n\n\n\nLatihan DML\n\n\n\nGunakan Database yang telah kalian kerjakan pada Latihan DDL sebelumnya!\n\nInsert Data\nINSERT INTO id_mahasiswa VALUES ('Amanda', 'A11.2020.54321',);\nSelect Data\nSELECT Nama, NIM FROM id_mahasiswa;\nUpdate Data\nUPDATE id_mahasiswa SET `Prodi`='Ilmu Komunikasi' WHERE `Prodi`='';\nDelete Data\nDELETE FROM id_mahasiswa WHERE `NIM`='A11.2020.54321';\nKreasikan database kalian dengan perintah dari DDL dan DML !\n\n\n\n\n\n\n\n\n\nKonsep Database\n\n\n\nBerikut merupakan penjelasan dari konsep database!",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Transposisi Myzkowski"
    ]
  },
  {
    "objectID": "6_transposisi_myzkowski.html#pemrosesan-kunci",
    "href": "6_transposisi_myzkowski.html#pemrosesan-kunci",
    "title": "6. Transposisi Myzkowski",
    "section": "Pemrosesan Kunci",
    "text": "Pemrosesan Kunci\nMenghilangkan spasi pada kunci dan membuat kunci menjadi lowercase\nkey_playfair = key_playfair.replace(' ','').lower()\nprint(key_playfair)\nMenghapus huruf ‘j’ jika ada di kunci\nkey_playfair = key_playfair.replace('j', '')\nprint(key_playfair)\nMenghapus huruf yang berulang\nkey_result = []\nfor i in key_playfair:\n  if i not in key_result:\n    key_result.append(i)\nprint(key_result)\nperulangan untuk menghapus huruf yang berulang dengan menambahkan kondisi apakah huruf tersebut sudah ditambahkan ke list key_result\nMenambahkan sisa huruf alphabet yang belum ada ke dalam matrix kunci\nfor i in abjad:\n  if i != 'j' and i not in key_result:\n    key_result.append(i)\nprint(key_result)\nMembuat matrix kunci 5x5\nkey_created = []\nwhile key_result!= []:\n  key_created.append(key_result[:5])\n  key_result = key_result[5:]\nfor row in key_created:\n        print(row)",
    "crumbs": [
      "Kriptografi Klasik",
      "6. Transposisi Myzkowski"
    ]
  },
  {
    "objectID": "6_transposisi_myzkowski.html#proses-enkripsi",
    "href": "6_transposisi_myzkowski.html#proses-enkripsi",
    "title": "6. Transposisi Myzkowski",
    "section": "Proses Enkripsi",
    "text": "Proses Enkripsi\nMengganti huruf ‘j’ yang ada di plainteks menjadi huruf ‘i’\nplaintext_playfair = plaintext_playfair.replace('j', 'i')\nprint(plaintext_playfair)\nProses pembuatan plaintext menjadi bentuk bigram atau pasangan huruf\nbigram_plaintext = []\n# perulangan untuk menambahkan pasangan huruf atau bigram ke dalam list bigram_plaintext\ni = 0\nwhile i&lt;len(plaintext_playfair):\n  x = plaintext_playfair[i]\n  y = ''\n\n  # situasi jika berada di huruf terakhir di plaintext\n  if((i+1) == len(plaintext_playfair)):\n    y = 'z'\n  else:\n    y = plaintext_playfair[i+1]\n\n  # jika hurufnya keduanya sama, maka disisipkan z di tengahnya\n  if(x!=y):\n    bigram_plaintext.append(x+y)\n    i += 2\n  else:\n    bigram_plaintext.append(x+'z')\n    i += 1\nprint(bigram_plaintext)\nPenjelasan prosesnya:\n\nbigram_plaintext = [] adalah sebuah list kosong yang akan diisi dengan pasangan huruf (bigram) yang diambil dari plaintext_playfair.\nwhile loop digunakan untuk iterasi melalui teks plaintext_playfair sampai semua huruf di teks tersebut telah diproses. Loop ini akan berlanjut selama i kurang dari panjang teks plaintext_playfair. Jadi perulangan ini digunakan untuk memproses semua huruf yang ada di plaintext_playfair.\nx = plaintext_playfair[i] dan y = '' adalah variabel yang digunakan untuk menampung huruf bigram pertama dan kedua dengan inisiasi nilai awal itu nilai dari plaintext_playfair[i] dan string kosong.\nSelanjutnya untuk pengkondisian pertama itu digunakan untuk kondisi dimana sudah sampai huruf terkahir dalam plaintext_playfair.\nTerakhir untuk pengkondisian kedua itu digunakan untuk kondisi dimana kedua hurufnya itu sama.\n\nProses substitusi plainteks dengan 3 aturan yang sudah di jelaskan diatas\nbigram_ciphertext = []\n# perulangan untuk mencari bigram ciphertex\nfor bigram in bigram_plaintext:\n  flag = False\n  # cek aturan 1, apakah pasangan huruf plaintext berada di baris yang sama\n  for row in key_created:\n    # jika berada di baris yang sama maka huruf yang berada di sebelah kanannya ditambahkan ke bigram ciphertext\n    if(bigram[0] in row and bigram[1] in row):\n      x1 = row.index(bigram[0])\n      x2 = row.index(bigram[1])\n      cipher_created = row[(x1 + 1) % 5] + row[(x2 + 1) % 5]\n      bigram_ciphertext.append(cipher_created)\n      flag = True\n  if flag:\n    continue\n\n  # cek aturan 2, apakah pasangan huruf plaintext berada di kolom yang sama\n  for j in range(5):\n    col = ''.join([key_created[i][j] for i in range(5)])\n    # jika berada di kolom yang sama maka huruf yang berada di bawahnya ditambahkan ke bigram ciphertext\n    if(bigram[0] in col and bigram[1] in col):\n      y1 = col.index(bigram[0])\n      y2 = col.index(bigram[1])\n      cipher_created = col[(y1 + 1) % 5] + col[(y2 + 1) % 5]\n      bigram_ciphertext.append(cipher_created)\n      flag = True\n  if flag:\n    continue\n\n  foundOne = False\n  foundTwo = False\n\n  # cek aturan 3, apakah pasangan huruf plaintext berada di baris dan kolom yang berbeda\n  for i in range(5):\n    row = key_created[i]\n    # jika huruf pertama dalam bigram ada pada baris urutan ke 'i'\n    if(bigram[0] in row):\n      x1 = i\n      y1 = row.index(bigram[0])\n      foundOne = True\n    # jika huruf kedua dalam bigram ada pada baris urutan ke 'i'\n    if(bigram[1] in row):\n      x2 = i\n      y2 = row.index(bigram[1])\n      foundTwo = True\n    # jika kedua posisi pasangan huruf atau bigram sudah diketahui, maka pembentukan cipher sesuai aturan ketiga dilakukan\n    if foundOne and foundTwo:\n      cipher_created = key_created[x1][y2] + key_created[x2][y1]\n      bigram_ciphertext.append(cipher_created)\n      break\nprint(bigram_ciphertext)\nPenjelasan prosesnya:\n\nbigram_ciphertext adalah list kosong yang akan diisi dengan pasangan huruf (bigram) yang telah dienkripsi dari bigram_plaintext.\nfor bigram in bigram_plaintext: digunakan untuk iterasi melalui setiap bigram yang ada dalam bigram_plaintext.\nflag = False adalah variabel boolean yang digunakan untuk menandai apakah aturan tertentu sudah dipenuhi sehingga tidak perlu memeriksa aturan lainnya untuk bigram yang sama.\nPemeriksaan Aturan 1: Baris yang Sama\n\nfor row in key_created:\n    if(bigram[0] in row and bigram[1] in row):\n        x1 = row.index(bigram[0])\n        x2 = row.index(bigram[1])\n        cipher_created = row[(x1 + 1) % 5] + row[(x2 + 1) % 5]\n        bigram_ciphertext.append(cipher_created)\n        flag = True\n\nLoop ini memeriksa setiap baris (row) dalam matriks kunci (key_created).\nJika kedua huruf dalam bigram (bigram[0] dan bigram[1]) berada di baris yang sama (row), maka:\n\nIndeks masing-masing huruf dalam baris ditemukan (x1 dan x2).\nHuruf di sebelah kanan dari masing-masing huruf ditentukan dengan menggunakan (index + 1) % 5 untuk menangani kasus melingkar (huruf di ujung kanan).\nHuruf-huruf ini kemudian digabungkan menjadi cipher_created dan ditambahkan ke bigram_ciphertext.\nflag diatur ke True untuk menandai bahwa aturan ini telah diterapkan, dan loop berhenti memeriksa aturan lain untuk bigram ini.\n\nLanjut ke Bigram Berikutnya Jika Aturan 1 Terpenuhi\n\nif flag:\n    continue\n\nJika flag True, bigram ini sudah diproses, dan loop lanjut ke bigram berikutnya tanpa memeriksa aturan lainnya.\nPemeriksaan Aturan 2: Kolom yang Sama\n\nfor j in range(5):\n    col = ''.join([key_created[i][j] for i in range(5)])\n    if(bigram[0] in col and bigram[1] in col):\n        y1 = col.index(bigram[0])\n        y2 = col.index(bigram[1])\n        cipher_created = col[(y1 + 1) % 5] + col[(y2 + 1) % 5]\n        bigram_ciphertext.append(cipher_created)\n        flag = True\n\nLoop ini memeriksa setiap kolom dalam matriks kunci (key_created).\nSetiap kolom (col) dibentuk dengan menggabungkan huruf-huruf dari setiap baris pada indeks j.\nJika kedua huruf dalam bigram (bigram[0] dan bigram[1]) berada di kolom yang sama (col), maka:\n\nIndeks masing-masing huruf dalam kolom ditemukan (y1 dan y2).\nHuruf di bawah masing-masing huruf ditentukan dengan menggunakan (index + 1) % 5 untuk menangani kasus melingkar (huruf di ujung bawah).\nHuruf-huruf ini kemudian digabungkan menjadi cipher_created dan ditambahkan ke bigram_ciphertext.\nflag diatur ke True, dan loop berhenti memeriksa aturan lain untuk bigram ini.\n\nLanjut ke Bigram Berikutnya Jika Aturan 2 Terpenuhi\n\nif flag:\n    continue\n\nJika flag True, bigram ini sudah diproses, dan loop lanjut ke bigram berikutnya tanpa memeriksa aturan lainnya.\nPemeriksaan Aturan 3: Baris dan Kolom Berbeda\n\nfoundOne = False\nfoundTwo = False\n\nfor i in range(5):\n    row = key_created[i]\n    if(bigram[0] in row):\n        x1 = i\n        y1 = row.index(bigram[0])\n        foundOne = True\n    if(bigram[1] in row):\n        x2 = i\n        y2 = row.index(bigram[1])\n        foundTwo = True\n    if foundOne and foundTwo:\n        cipher_created = key_created[x1][y2] + key_created[x2][y1]\n        bigram_ciphertext.append(cipher_created)\n        break\n\nLoop ini memeriksa setiap baris dalam matriks kunci (key_created) untuk menemukan posisi huruf pertama dan kedua dari bigram.\nJika huruf pertama (bigram[0]) ditemukan dalam baris i, indeks baris (x1) dan kolom (y1) disimpan, dan foundOne diatur ke True.\nJika huruf kedua (bigram[1]) ditemukan dalam baris i, indeks baris (x2) dan kolom (y2) disimpan, dan foundTwo diatur ke True.\nJika kedua huruf ditemukan (foundOne dan foundTwo), aturan ketiga diterapkan:\n\nHuruf di posisi silang yang berlawanan diambil dari matriks kunci: key_created[x1][y2] dan key_created[x2][y1].\nHuruf-huruf ini digabungkan menjadi cipher_created dan ditambahkan ke bigram_ciphertext.\nLoop dihentikan dengan break karena bigram telah diproses.\n\n\nHasil enkripsi\nhasil_enkripsi = ''.join(bigram_ciphertext)\nprint(hasil_enkripsi)",
    "crumbs": [
      "Kriptografi Klasik",
      "6. Transposisi Myzkowski"
    ]
  },
  {
    "objectID": "6_transposisi_myzkowski.html#proses-dekripsi",
    "href": "6_transposisi_myzkowski.html#proses-dekripsi",
    "title": "6. Transposisi Myzkowski",
    "section": "Proses Dekripsi",
    "text": "Proses Dekripsi\nMemasukkan ciphertext\nciphertext_playfair = input(\"Masukkan teks yang akan di dekripsi: \")\nProses pembuatan ciphertext menjadi bentuk bigram atau pasangan huruf\nbigram_ciphertext = [ciphertext_playfair[i:i+2] for i in range(0, len(ciphertext_playfair), 2)]\nprint(bigram_ciphertext)\nProses substitusi Cipherteks dengan 3 aturan yang sudah di jelaskan diatas\nbigram_dekripsi = []\n# perulangan untuk mencari bigram decrypt text\nfor bigram in bigram_ciphertext:\n  flag = False\n  # cek aturan 1, apakah pasangan huruf ciphertext berada di baris yang sama\n  for row in key_created:\n    # jika berada di baris yang sama maka huruf yang berada di sebelah kanannya ditambahkan ke bigram decrypt text\n    if(bigram[0] in row and bigram[1] in row):\n      x1 = row.index(bigram[0])\n      x2 = row.index(bigram[1])\n      decrypt_created = row[(x1 - 1) % 5] + row[(x2 - 1) % 5]\n      bigram_dekripsi.append(decrypt_created)\n      flag = True\n  if flag:\n    continue\n\n  # cek aturan 2, apakah pasangan huruf ciphertext berada di kolom yang sama\n  for j in range(5):\n    col = ''.join([key_created[i][j] for i in range(5)])\n    # jika berada di kolom yang sama maka huruf yang berada di bawahnya ditambahkan ke bigram decrypt text\n    if(bigram[0] in col and bigram[1] in col):\n      y1 = col.index(bigram[0])\n      y2 = col.index(bigram[1])\n      decrypt_created = col[(y1 - 1) % 5] + col[(y2 - 1) % 5]\n      bigram_dekripsi.append(decrypt_created)\n      flag = True\n  if flag:\n    continue\n\n  foundOne = False\n  foundTwo = False\n\n  # cek aturan 3, apakah pasangan huruf ciphertext berada di baris dan kolom yang berbeda\n  for i in range(5):\n    row = key_created[i]\n    # jika huruf pertama dalam bigram ada pada baris urutan ke 'i'\n    if(bigram[0] in row):\n      x1 = i\n      y1 = row.index(bigram[0])\n      foundOne = True\n    # jika huruf kedua dalam bigram ada pada baris urutan ke 'i'\n    if(bigram[1] in row):\n      x2 = i\n      y2 = row.index(bigram[1])\n      foundTwo = True\n    # jika kedua posisi pasangan huruf atau bigram sudah diketahui, maka pembentukan cipher sesuai aturan ketiga dilakukan\n    if foundOne and foundTwo:\n      decrypt_created = key_created[x1][y2] + key_created[x2][y1]\n      bigram_dekripsi.append(decrypt_created)\n      break\nprint(bigram_dekripsi)\nHasil dekripsi\nhasil_dekripsi = ''.join(bigram_dekripsi)\nprint(hasil_dekripsi)",
    "crumbs": [
      "Kriptografi Klasik",
      "6. Transposisi Myzkowski"
    ]
  }
]