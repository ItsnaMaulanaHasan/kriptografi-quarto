[
  {
    "objectID": "2_monoalphabetic_random_key.html",
    "href": "2_monoalphabetic_random_key.html",
    "title": "2. Monoalphabetic Random Key",
    "section": "",
    "text": "Cara kerja",
    "crumbs": [
      "Kriptografi Klasik",
      "2. Monoalphabetic Random Key"
    ]
  },
  {
    "objectID": "2_monoalphabetic_random_key.html#implementasi-pada-python",
    "href": "2_monoalphabetic_random_key.html#implementasi-pada-python",
    "title": "2. Monoalphabetic Random Key",
    "section": "Implementasi Pada Python",
    "text": "Implementasi Pada Python\nMasukkan plaintext\nplainText = input(\"Plaintext : \")\nMasukkan kunci\nkey = input(\"masukkan kunci : \")\nMembersihkan teks dari spasi ganda\ncleanPlainTeks = plainTeks.replace(\" \", \"\")\nprint(cleanPlainTeks)\nDeklarasi urutan huruf dalam alfabet\nascii = {\n'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8, 'i': 9, 'j': 10, 'k': 11, \n'l': 12, 'm': 13, 'n': 14, 'o': 15, 'p': 16, 'q': 17, 'r': 18, 's': 19, 't': 20, 'u': 21, \n'v': 22, 'w': 23, 'x': 24, 'y': 25, 'z': 26\n}\n\nProses Enkripsi\nInisialisasi list untuk menyimpan urutan numerik dari setiap huruf alfabet\nkolom = 0\nangka_urutan = []\nMengonversi setiap huruf dalam kata kunci menjadi urutan numeriknya sesuai dengan posisi dalam alfabet\nfor huruf in key:\n    if huruf.isalpha():\n        angka_urutan.append(ascii[huruf.lower()])\n        kolom = kolom+1\n        cleanKey = angka_urutan\n\nprint(f\"Urutan kunci dari kata '{key}' adalah {angka_urutan}\")\nFor More Detail :\n\nfor huruf in key : Loop ini digunakan untuk memeriksa setiap huruf dalam variabel key, yang diharapkan merupakan kata kunci yang diberikan oleh pengguna\nif huruf.isalpha() : Kondisi ini memastikan bahwa hanya karakter alfabet yang akan diproses. Karakter non-alfabet akan dilewati\n`huruf.lower(): Mengubah huruf menjadi huruf kecil untuk konsistensi, sehingga tidak ada perbedaan antara huruf besar dan kecil\nascii[huruf.lower()] : Mengambil nilai urutan numerik dari huruf. Di sini diasumsikan ada sebuah kamus (dictionary) bernama ascii yang memetakan setiap huruf ke urutan numeriknya\nangka_urutan.append(...) : Menambahkan urutan numerik dari huruf ke dalam list angka_urutan\nkolom = kolom + 1 : Menghitung jumlah kolom dengan menambah nilai kolom setiap kali huruf diproses\ncleanKey = angka_urutan : Menyimpan hasil akhir urutan numerik ke dalam variabel cleanKey\n\nMembuat sebuah matriks kosong untuk menyimpan teks yang telah diolah dalam bentuk matriks\nmatrix = []\nMenghitung panjang dari teks yang telah dibersihkan dan disimpan dalam variabel cleanPlainTeks\npanjang = len(cleanPlainTeks)\nMencari tahu berapa kali kolom dapat digunakan untuk memuat seluruh teks, dengan membagi panjang teks dengan jumlah kolom\ntemp = panjang/kolom\nMembulatkan hasil pembagian sebelumnya ke bilangan bulat terdekat\nbulat = round(temp)\nMenghitung jumlah baris untuk memuat teks dalam matriks\nif temp - bulat == 0:\n    baris = bulat\nelse:\n    if temp - bulat &lt; 0:\n        baris = bulat\n    else:\n        baris = bulat + 1\nprint(baris)\nFor More Detail :\n\ntemp : hasil pembagian panjang teks dengan jumlah kolom\nbulat: hasil pembagian yang dibulatkan ke bilangan bulat terdekat. Jika temp adalah bilangan bulat (tidak ada sisa), jumlah baris adalah bulat. Jika ada sisa, jumlah baris adalah bulat + 1\n\nMengisi matriks dengan karakter dari teks yang telah dibersihkan (cleanPlainTeks)\nfor i in range(baris):\n    row = []\n    for j in range(kolom):\n        if i * kolom + j &lt; len(cleanPlainTeks):\n            elemen = cleanPlainTeks[i * kolom + j]\n        else:\n            elemen = \" \"\n        row.append(elemen)\n    matrix.append(row)\nFor More Detail :\n\nfor i in range(baris) : Loop untuk setiap baris dalam matriks\nrow = [] : Inisialisasi list kosong untuk setiap baris\nif i * kolom + j &lt; len(cleanPlainTeks) : Memeriksa apakah indeks saat ini berada dalam rentang panjang teks yang dibersihkan.\nelemen = cleanPlainTeks[i * kolom + j] : Jika indeks berada dalam rentang, maka ambil karakter dari cleanPlainTeks berdasarkan indeks yang dihitung.\nelse : Jika indeks melebihi panjang teks, isi elemen dengan spasi.\nrow.append(elemen) : Menambahkan elemen ke dalam baris.\nmatrix.append(row) : Menambahkan baris yang telah diisi ke dalam matriks.`\n\nMencetak matriks\nprint(\"Matriks yang Anda buat:\")\nfor row in matrix:\n    print(row)\nMentransposisikan matriks yang telah dibuat dan kemudian mencetak matriks yang telah ditransposisikan\ntransposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\nfor row in transposed_matrix:\n    print(row)\nFor More Detail :\n\nfor i in range(len(matrix[0])) : Iterasi melalui indeks kolom matriks asli\nrow[i] for row in matrix : Untuk setiap indeks kolom i, ambil elemen i dari setiap baris dalam matriks asli dan akan menghasilkan kolom baru dari elemen-elemen tersebut, membentuk baris baru di matriks yang ditransposisikan\n\nMembuat list kosong dengan panjang yang sama dengan cleanKey untuk menyimpan urutan indeks\norder = [None] * len(cleanKey)\nMengurutkan elemen-elemen dalam cleanKey berdasarkan nilai terkecil hingga terbesar\ni = 0\nwhile len(cleanKey) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, cleanKey))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = cleanKey.index(nilai_terkecil)\n\n        order[marker] = i\n        cleanKey[marker] = None \n        i = i + 1\n    else:\n        break\nprint(order)\nFor More Detail :\n\ni = 0 : Inisialisasi counter i\nwhile len(cleanKey) &gt; 0 : Loop hingga cleanKey kosong (semua elemen None)\nnon_none_values = list(filter(lambda x: x is not None, cleanKey)) : Membuat list yang hanya berisi elemen-elemen cleanKey yang bukan None\nif non_none_values : Mengecek apakah list non_none_values tidak kosong nilai_terkecil = min(non_none_values) : Mencari nilai terkecil dari non_none_values\nmarker = cleanKey.index(nilai_terkecil) : Mendapatkan indeks dari nilai terkecil dalam cleanKey Menyimpan Urutan dan Menghapus Nilai Terkecil:\norder[marker] = i : Menyimpan urutan i pada indeks marker di list order\ncleanKey[marker] = None : Menghapus nilai terkecil dari cleanKey dengan mengubahnya menjadi None\ni = i + 1 : Increment counter i.\n\nMengubah urutan kolom matriks transposed_matrix berdasarkan urutan yang telah diatur dalam order, dan kemudian mencetak matriks yang sudah diubah urutan kolomnya\nnew_matrix = []\nwhile len(order) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, order))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = order.index(nilai_terkecil)\n       \n        new_matrix.append(transposed_matrix[marker])\n        order[marker] = None\n    else:\n        break\n\nfor row in new_matrix:\n    print(row)\nFor More Detail :\n\nnew_matrix = [] : Membuat list kosong new_matrix untuk menampung baris-baris matriks yang baru diurutkan Looping untuk Mengubah Urutan Kolom:\nwhile len(order) &gt; 0 : Melakukan looping selama masih ada elemen yang tersisa dalam order\nnon_none_values = list(filter(lambda x: x is not None, order)) : Membuat list non_none_values yang hanya berisi nilai-nilai yang bukan None dari order\nif non_none_values : Memeriksa apakah non_none_values tidak kosong\nnilai_terkecil = min(non_none_values) : Menemukan nilai terkecil dari non_none_values\nmarker = order.index(nilai_terkecil) : Mencari indeks dari nilai_terkecil dalam order\nnew_matrix.append(transposed_matrix[marker]) : Menambahkan baris dari transposed_matrix yang sesuai dengan marker ke new_matrix\norder[marker] = None : Menghapus nilai yang telah diproses dengan mengubahnya menjadi None\nelse: break : Menghentikan loop jika non_none_values kosong, yang berarti semua nilai dalam order telah diproses\n\nMengonversi matriks new_matrix menjadi string tunggal dengan menggabungkan nilai-nilainya secara berurutan dan menghapus spasi ekstra di akhir string\nresult_string = \"\"\n\nfor row in new_matrix:\n    for value in row:\n        result_string += str(value)\n\nresult_string = result_string.strip()\n\nprint(result_string)\nFor More Detail :\n\nresult_string = \"\" : Inisialisasi string kosong result_string yang akan digunakan untuk menyimpan hasil akhir\nfor row in new_matrix: : Melakukan iterasi melalui setiap baris dalam new_matrix\nfor value in row: : Melakukan iterasi melalui setiap nilai dalam baris row\nresult_string += str(value) : Mengonversi nilai value menjadi string (jika belum string) dan menambahkannya ke result_string\nresult_string = result_string.strip() : Menghapus spasi ekstra di awal dan akhir string menggunakan metode strip()\n\nHasil Ciphertext : ENTKFINOKKM TIAIRA\n\n\nProses Dekripsi\ncipherTeks = input(\"masukkan kata : \")\nkey = input(\"masukkan kunci : \")\ncleanCipherTeks = cipherTeks.replace(\" \", \" \")\nprint(cleanCipherTeks)\nkolom = 0\nangka_urutan = []\nfor huruf in key:\n    if huruf.isalpha():\n        angka_urutan.append(ascii[huruf.lower()])\n        kolom = kolom+1\n        cleanKey = angka_urutan\n\nprint(f\"Urutan kunci dari kata '{key}' adalah: {angka_urutan}\")\nmatrix = []\npanjang = len(cleanCipherTeks)\ntemp = panjang/kolom\nbaris = round(temp)\nprint(baris)\nfor i in range(baris):\n    row = []\n    for j in range(kolom):\n        if i * kolom + j &lt; len(cleanCipherTeks):\n            elemen = cleanCipherTeks[i + baris * j]\n        else:\n            elemen = \"a\"\n        row.append(elemen)\n    matrix.append(row)\nprint(\"Matriks yang Anda buat:\")\nfor row in matrix:\n    print(row)\ntransposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\nfor row in transposed_matrix:\n    print(row)\norder = [None] * len(cleanKey)\ni = 0\nwhile len(cleanKey) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, cleanKey))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = cleanKey.index(nilai_terkecil)\n        order[marker] = i\n        cleanKey[marker] = None  \n        i = i + 1\n    else:\n        break\nprint(order)\ntransposed_matrix = [transposed_matrix[i] for i in order]\n\nfor row in transposed_matrix:\n    print(row)\nmatriks = [[row[i] for row in transposed_matrix] for i in range(len(transposed_matrix[0]))]\nfor row in matriks:\n    print(row)\nresult_string = \"\"\n\nfor row in matriks:\n    for value in row:\n        result_string += str(value)\n\nresult_string = result_string.strip()\n\nprint(result_string)\nHasil Dekripsi : TEKNIKINFORMATIKA\nPerbedaan Proses :\n\nEnkripsi: Teks asli diubah menjadi matriks berdasarkan kolom kunci, kemudian kolom-kolom diurutkan berdasarkan kunci. Pada enkripsi, transposed_matrix adalah matriks transposisi dari matrix awal\nDekripsi: Teks sandi diubah menjadi matriks berdasarkan kolom kunci, kemudian baris-baris diurutkan berdasarkan kunci untuk mengembalikan teks asli. Pada dekripsi, transposed_matrix diurutkan berdasarkan order untuk mengembalikan teks asli",
    "crumbs": [
      "Kriptografi Klasik",
      "2. Monoalphabetic Random Key"
    ]
  },
  {
    "objectID": "4_playfair.html",
    "href": "4_playfair.html",
    "title": "4. Playfair",
    "section": "",
    "text": "Prinsip Dasar",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Playfair"
    ]
  },
  {
    "objectID": "4_playfair.html#pengenalan-responsive-web-design",
    "href": "4_playfair.html#pengenalan-responsive-web-design",
    "title": "4. Playfair",
    "section": "",
    "text": "Responsive Web\n\n\n\n\n&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n\n\n\n\n&lt;img src=\"images.jpg\" style=\"width:100%;\"&gt;\n\n\n&lt;h1 style=\"font-size:10vw\"&gt;Hello World&lt;/h1&gt;",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Playfair"
    ]
  },
  {
    "objectID": "4_playfair.html#responsive-web-design-framework-bootstrap",
    "href": "4_playfair.html#responsive-web-design-framework-bootstrap",
    "title": "4. Playfair",
    "section": "Responsive Web Design Framework (Bootstrap)",
    "text": "Responsive Web Design Framework (Bootstrap)\nBootstrap merupakan HTML, CSS dan Javascript framework paling popular untuk mengambangkan responsive web design yang mengutamakan tampilan mobile (mobile first) Bootstrap dapat diunduh secara gratis pada laman https://getbootstrap.com/. Sampai saat modul ini dibuat versi terakhir adalah Bootstrap v5.3.\n\nMengapa menggunakan Bootstrap?\nBanyak keuntungan dan kemudahan yang diberikan Bootstrap diantaranya adalah: \nBerikut adalah beberapa penjelasan mengenai Bootstrap: \n\nResponsif: Salah satu fitur utama Bootstrap adalah kemampuannya untuk menghasilkan tampilan yang responsif secara otomatis. Dengan menggunakan class CSS yang telah disediakan oleh Bootstrap, elemen-elemen halaman web dapat menyesuaikan diri dengan baik pada berbagai perangkat dan ukuran layar, mulai dari desktop hingga perangkat mobile.\nGrid System: Bootstrap menyediakan sistem grid yang fleksibel untuk membagi layout halaman web menjadi kolom-kolom yang responsif. Grid system ini memungkinkan pengaturan layout yang mudah dan dapat diatur untuk menciptakan tampilan yang rapi dan terstruktur pada berbagai perangkat.\nKomponen Siap Pakai: Bootstrap menyediakan beragam komponen UI siap pakai seperti tombol, navigasi, formulir, jumbotron, kartu, jendela modal, dan banyak lagi. Komponen ini telah dirancang dengan baik dan dapat langsung digunakan dalam proyek tanpa perlu memikirkan desain atau gaya dasar, menghemat waktu dan usaha pengembangan.\nGaya dan Tema: Bootstrap memiliki gaya dan tema default yang estetis dan modern. Selain itu, Bootstrap juga menyediakan beragam tema kustom yang dapat diterapkan dengan mudah untuk memberikan tampilan yang unik dan sesuai dengan kebutuhan proyek Anda. Anda juga dapat menyesuaikan gaya dan tema Bootstrap sesuai dengan preferensi Anda sendiri.\nKompatibilitas Browser: Bootstrap dirancang untuk mendukung sebagian besar browser modern. Ini berarti tampilan dan fungsionalitas situs web yang dibangun dengan menggunakan Bootstrap akan konsisten dan berfungsi dengan baik di berbagai browser yang umum digunakan.\nDokumentasi dan Komunitas: Bootstrap memiliki dokumentasi yang sangat baik, lengkap dengan contoh-contoh kode dan penjelasan yang rinci. Selain itu, karena popularitasnya, Bootstrap memiliki komunitas pengembang yang besar dan aktif, yang dapat memberikan dukungan dan sumber daya yang berguna untuk menjawab pertanyaan, memecahkan masalah, dan berbagi pengalaman.\n\n\n\n\nHTML5\nPenambahan doctype dilakukan untuk menetapkan dokumen HTML sebagai HTML versi 5 (HTML5), agar dapat menggunakan elemen-elemen HTML5 dan properti CSS Bootstrap. Sebagai contohnya pada script berikut. \n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\n&lt;/html&gt;\n\nJika menggunakan Text Editor Visual Studio Code, ketika mengetikan html di awal kode maka akan muncul snippets yang memunculkan beberapa pilihan template kode \n\n\n\nSnippets\n\n\n\n\nGrid System\nPada Bootstrap menerapkan grid system dengan 12 (dua belas) kolom pada setiap halaman. Jika kita tidak menginginkan layout menggunakan ke-12 kolom, kita bisa mengelompokkan kolom bersama untuk membuat kolom yang lebih lebar. Sebagai contoh gambaran dari grid system dengan 12 kolom ditampilkan seperti pada gambar di bawah ini. \n\n\n\nContoh Grid System Bootstrap\n\n\n Sistem grid pada bootstrap dapat menyesuaikan terhadap enam keadaan atau ukuran diantaranya adalah : \n\nEkstra kecil atau extra small (xs)\nKecil atau small (sm)\nSedang atau medium (md)\nBesar atau large (lg)\nEkstra besar atau extra large (xl)\nEkstra ekstra besar atau extra extra large (xxl) \n\n\n\n\nTabel Breakpoint Grid\n\n\n\n\nFungsi Bootsrtap yang umum digunakan\n\nGrid  Seperti yang telah dijelaskan pada Grid System, bahwa pada bootstrap dapat mengelompokkan layout menjadi 12 kolom, dimana kita dapat menggunakan grid ini dengan kelas row yang didalamnya terdapat kelas col, seperti berikut:\n&lt;div class=\"row\"&gt;\n    &lt;div class=\"col\"&gt;&lt;/div&gt;\n    ...\n&lt;/div&gt;&lt;!-- row--&gt;\n Dalam kelas col ini dapat dituliskan dengan value seperti col-4, yang artinya objek yang diberikan kelas tersebut pada row atau baris akan mengisi sebanyak 4 kolom. Dalam 1 row tersebut dapat berisi dengan akumulai 12 kolom.  Selain iitu juga bisa dikombinasikan dengan class breakpoint. Pada seperti yang dijelaskan pada tabel penjelasan grid system bahwa kolom akan mengikuti ukuran breakppoint dari device yang dimasukkan. Misalkan col-md-4, maka ketika ukuran dari device yang digunakan lebih besar dari atau sama dengan 768px maka tampilan kolom akan mendatar memenuhi row, namun akan berubah tampilannya jika ukuran devicenya berkurang 1 pixel saja (kurang dari 768px).\nWarna  Terdapat beberapa template kelas warna yang disediakan oleh Bootstrap diantaranya \n\nPrimary: (Biru tua)\nSecondary: (Abu-abu)\nSuccess: (Hijau)\nDanger: (Merah)\nWarning: (Kuning)\nInfo: (Biru cerah)\nLight: (Putih atau hampir putih)\nDark: (Hitam atau hampir hitam) \n\nPemilihan warna juga merupakan hal yang sangat penting dan perlu diperhatikan.Pemilihan warna akan sangat berpengaruh pada tampilan atau UI sehingga akan mempercantik tampilan dan menarik bagi user. Selain itu dengan warna yang sesuai akan membantu menyampaikan fungsi dari fitur, misalnya merah menandakan suatu yang penting yang memerlukan perhatian lebih, hal tersebut akan memudahkan konsumen dalam menggunakan aplikasi atau disebut user experience\nTypografi  Dalam cara penulisan pada bootstrap memberikan kemudahan dalam mengatur tampilan teks, melalui beberapa class, seperti \n\nHeading, selain menggunakan tag &lt;h1&gt;,&lt;h2&gt;,..,&lt;h6&gt; pada bootstrap juga terdapat kelas heading contohnya:\n&lt;p class=\"h1\"&gt;Heading 1&lt;p&gt;\nDisplay, dengan manambahkan class display pada teks akan memberikan tampilan teks yang besar namun dengan style font yang tipis, misalnya: \n&lt;p class=\"display-1\"&gt;Display 1&lt;/p&gt;\nFont Size, class font size atau yang ditulis fs memberikan styling berupa ukuran dari teks dimana semakin besar nilai fs akan semakin kecil font yang ditampilkan: \n&lt;p class=\"fs-1\"&gt;ini teks&lt;/p&gt;\nFont Weight, melalui font weight dapat memberikan pengaturan terhadap tebal tipis dari font atau teks, dengan parameter bolder, bold, light, lighter, dan normal, berikut contoh penggunaannya: \n&lt;p class=\"fw-bold\"&gt;Ini tebal&lt;/p&gt;\nFont Style, dengan font style kita dapat merubah style dari font atau teks bold dan italic tanpa menggunakan tag html &lt;b&gt; dan &lt;i&gt;, atau sebagai berikut: \n&lt;p class=\"fst-italic\"&gt;ini font style&lt;/p&gt;\n&lt;p class=\"fst-normal\"&gt;ini font style&lt;/p&gt;\n\nSpacing & Sizing \nPengaturan Spasi dan ukuran pada Bootstrap dapat menggunakan padding dan margin, Padding merupakan bagian yang membatasi konten dengan border, sedangkan margin merupakkan bagian yang membatasi antara border dengan bagian luar dari konten. Pengaturan margin dan padding dapat dilakukan dengan mudah hanya dengan menambahkan class m untuk margin dan p untuk padding yang diikuti dengan parameter t (top), b (bottom), s (start), e (end), x (menambahkan pada kedua sis horizontal), y (menambahkan pada kedua sisi vertikal), serta diikuti oleh besar margin atau padding yang diinginkan dengan nilai mulai dari 1 hingga 5, atau seperti berikut:\n ```html\n &lt;!-- Heading --&gt;\n &lt;div class=\"item mt-5 mb-3\"&gt;item1&lt;/div&gt;\n &lt;div class=\"item ms-2 me-3\"&gt;item2&lt;/div&gt;\n &lt;div class=\"item my-5\"&gt;item3&lt;/div&gt;\n &lt;div class=\"item mx-3\"&gt;item4&lt;/div&gt;\n &lt;div class=\"item m-3\"&gt;item4&lt;/div&gt;\n\n &lt;!-- Padding --&gt;\n &lt;div class=\"item pt-5 pb-3\"&gt;item1&lt;/div&gt;\n &lt;div class=\"item ps-2 pe-3\"&gt;item2&lt;/div&gt;\n &lt;div class=\"item py-5\"&gt;item3&lt;/div&gt;\n &lt;div class=\"item px-3\"&gt;item4&lt;/div&gt;\n &lt;div class=\"item p-3\"&gt;item4&lt;/div&gt;\n ```\n\n\n\n\nMargin-Padding-Border\n\n\n\n\n\nKomponen yang umum digunakan\n\nNavbar Navbar pada bootstrap sudah memiliki kemampuan untuk responsif ketika ukuran dari perangkat yang digunakan terlalu kecil untuk menampilkan konten atau menu didalamnya akan otomatis menjadi humberger menu, berikut salah satu contoh dokumentasi navbar yang umum digunakan.\n\n\n\n\nNavbar\n\n\n\nTable Pada class yang disediakan bootstrap terdapat beberapa pilihan tampilan table dan modifikasi yang diberikan, dengan memasukkan tag table ke dalam div yang diberikan kelas dari table yang diinginkan misalnya seperti berikut :\n\n\n\n\nTable\n\n\n\nButton Tombol merupakan bagian terpenting dalam suatu tampilan website yang dapat mengirimkan input dari pengguna ke server. Dalam bootstrap terdapat beberapa variasi yang diberikan untuk penggunaan tombol atau button misalnya warna, bentuk, style, rounded dan masih banyak lagi yang bisa didalami melalui dokumentasi yang ada pada halaman bootstrap\n\n\n\n\nButton\n\n\n\nCard Pada website blog atau e-commerce biasanya menampilkan artikel-artikel mereka pada card dapat menampilkan gambar, serta deskripsi atau tombol untuk melihat lebih banyak mengenai informasi dari blog tersebut. berikut adalah contoh penggunaan card:\n\n\n\n\nCard\n\n\n\n\n\n\n\n\n\n\nResponsive design menggunakan Bootstrap\n\n\n\nBerikut penjelasan mengenai penggunaan bootstrap dan elemen-elemen yang banyak digunakan!",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Playfair"
    ]
  },
  {
    "objectID": "4_playfair.html#implementasi-pada-python",
    "href": "4_playfair.html#implementasi-pada-python",
    "title": "4. Playfair",
    "section": "Implementasi Pada Python",
    "text": "Implementasi Pada Python\nMasukkan plaintext\nplainText = input(\"Plaintext : \")\nMasukkan kunci\nkey = input(\"masukkan kunci : \")\nMembersihkan teks dari spasi ganda\ncleanPlainTeks = plainTeks.replace(\" \", \"\")\nprint(cleanPlainTeks)\nDeklarasi urutan huruf dalam alfabet\nascii = {\n'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8, 'i': 9, 'j': 10, 'k': 11, \n'l': 12, 'm': 13, 'n': 14, 'o': 15, 'p': 16, 'q': 17, 'r': 18, 's': 19, 't': 20, 'u': 21, \n'v': 22, 'w': 23, 'x': 24, 'y': 25, 'z': 26\n}\n\nProses Enkripsi\nInisialisasi list untuk menyimpan urutan numerik dari setiap huruf alfabet\nkolom = 0\nangka_urutan = []\nMengonversi setiap huruf dalam kata kunci menjadi urutan numeriknya sesuai dengan posisi dalam alfabet\nfor huruf in key:\n    if huruf.isalpha():\n        angka_urutan.append(ascii[huruf.lower()])\n        kolom = kolom+1\n        cleanKey = angka_urutan\n\nprint(f\"Urutan kunci dari kata '{key}' adalah {angka_urutan}\")\nFor More Detail :\n\nfor huruf in key : Loop ini digunakan untuk memeriksa setiap huruf dalam variabel key, yang diharapkan merupakan kata kunci yang diberikan oleh pengguna\nif huruf.isalpha() : Kondisi ini memastikan bahwa hanya karakter alfabet yang akan diproses. Karakter non-alfabet akan dilewati\n`huruf.lower(): Mengubah huruf menjadi huruf kecil untuk konsistensi, sehingga tidak ada perbedaan antara huruf besar dan kecil\nascii[huruf.lower()] : Mengambil nilai urutan numerik dari huruf. Di sini diasumsikan ada sebuah kamus (dictionary) bernama ascii yang memetakan setiap huruf ke urutan numeriknya\nangka_urutan.append(...) : Menambahkan urutan numerik dari huruf ke dalam list angka_urutan\nkolom = kolom + 1 : Menghitung jumlah kolom dengan menambah nilai kolom setiap kali huruf diproses\ncleanKey = angka_urutan : Menyimpan hasil akhir urutan numerik ke dalam variabel cleanKey\n\nMembuat sebuah matriks kosong untuk menyimpan teks yang telah diolah dalam bentuk matriks\nmatrix = []\nMenghitung panjang dari teks yang telah dibersihkan dan disimpan dalam variabel cleanPlainTeks\npanjang = len(cleanPlainTeks)\nMencari tahu berapa kali kolom dapat digunakan untuk memuat seluruh teks, dengan membagi panjang teks dengan jumlah kolom\ntemp = panjang/kolom\nMembulatkan hasil pembagian sebelumnya ke bilangan bulat terdekat\nbulat = round(temp)\nMenghitung jumlah baris untuk memuat teks dalam matriks\nif temp - bulat == 0:\n    baris = bulat\nelse:\n    if temp - bulat &lt; 0:\n        baris = bulat\n    else:\n        baris = bulat + 1\nprint(baris)\nFor More Detail :\n\ntemp : hasil pembagian panjang teks dengan jumlah kolom\nbulat: hasil pembagian yang dibulatkan ke bilangan bulat terdekat. Jika temp adalah bilangan bulat (tidak ada sisa), jumlah baris adalah bulat. Jika ada sisa, jumlah baris adalah bulat + 1\n\nMengisi matriks dengan karakter dari teks yang telah dibersihkan (cleanPlainTeks)\nfor i in range(baris):\n    row = []\n    for j in range(kolom):\n        if i * kolom + j &lt; len(cleanPlainTeks):\n            elemen = cleanPlainTeks[i * kolom + j]\n        else:\n            elemen = \" \"\n        row.append(elemen)\n    matrix.append(row)\nFor More Detail :\n\nfor i in range(baris) : Loop untuk setiap baris dalam matriks\nrow = [] : Inisialisasi list kosong untuk setiap baris\nif i * kolom + j &lt; len(cleanPlainTeks) : Memeriksa apakah indeks saat ini berada dalam rentang panjang teks yang dibersihkan.\nelemen = cleanPlainTeks[i * kolom + j] : Jika indeks berada dalam rentang, maka ambil karakter dari cleanPlainTeks berdasarkan indeks yang dihitung.\nelse : Jika indeks melebihi panjang teks, isi elemen dengan spasi.\nrow.append(elemen) : Menambahkan elemen ke dalam baris.\nmatrix.append(row) : Menambahkan baris yang telah diisi ke dalam matriks.`\n\nMencetak matriks\nprint(\"Matriks yang Anda buat:\")\nfor row in matrix:\n    print(row)\nMentransposisikan matriks yang telah dibuat dan kemudian mencetak matriks yang telah ditransposisikan\ntransposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\nfor row in transposed_matrix:\n    print(row)\nFor More Detail :\n\nfor i in range(len(matrix[0])) : Iterasi melalui indeks kolom matriks asli\nrow[i] for row in matrix : Untuk setiap indeks kolom i, ambil elemen i dari setiap baris dalam matriks asli dan akan menghasilkan kolom baru dari elemen-elemen tersebut, membentuk baris baru di matriks yang ditransposisikan\n\nMembuat list kosong dengan panjang yang sama dengan cleanKey untuk menyimpan urutan indeks\norder = [None] * len(cleanKey)\nMengurutkan elemen-elemen dalam cleanKey berdasarkan nilai terkecil hingga terbesar\ni = 0\nwhile len(cleanKey) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, cleanKey))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = cleanKey.index(nilai_terkecil)\n\n        order[marker] = i\n        cleanKey[marker] = None \n        i = i + 1\n    else:\n        break\nprint(order)\nFor More Detail :\n\ni = 0 : Inisialisasi counter i\nwhile len(cleanKey) &gt; 0 : Loop hingga cleanKey kosong (semua elemen None)\nnon_none_values = list(filter(lambda x: x is not None, cleanKey)) : Membuat list yang hanya berisi elemen-elemen cleanKey yang bukan None\nif non_none_values : Mengecek apakah list non_none_values tidak kosong nilai_terkecil = min(non_none_values) : Mencari nilai terkecil dari non_none_values\nmarker = cleanKey.index(nilai_terkecil) : Mendapatkan indeks dari nilai terkecil dalam cleanKey Menyimpan Urutan dan Menghapus Nilai Terkecil:\norder[marker] = i : Menyimpan urutan i pada indeks marker di list order\ncleanKey[marker] = None : Menghapus nilai terkecil dari cleanKey dengan mengubahnya menjadi None\ni = i + 1 : Increment counter i.\n\nMengubah urutan kolom matriks transposed_matrix berdasarkan urutan yang telah diatur dalam order, dan kemudian mencetak matriks yang sudah diubah urutan kolomnya\nnew_matrix = []\nwhile len(order) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, order))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = order.index(nilai_terkecil)\n       \n        new_matrix.append(transposed_matrix[marker])\n        order[marker] = None\n    else:\n        break\n\nfor row in new_matrix:\n    print(row)\nFor More Detail :\n\nnew_matrix = [] : Membuat list kosong new_matrix untuk menampung baris-baris matriks yang baru diurutkan Looping untuk Mengubah Urutan Kolom:\nwhile len(order) &gt; 0 : Melakukan looping selama masih ada elemen yang tersisa dalam order\nnon_none_values = list(filter(lambda x: x is not None, order)) : Membuat list non_none_values yang hanya berisi nilai-nilai yang bukan None dari order\nif non_none_values : Memeriksa apakah non_none_values tidak kosong\nnilai_terkecil = min(non_none_values) : Menemukan nilai terkecil dari non_none_values\nmarker = order.index(nilai_terkecil) : Mencari indeks dari nilai_terkecil dalam order\nnew_matrix.append(transposed_matrix[marker]) : Menambahkan baris dari transposed_matrix yang sesuai dengan marker ke new_matrix\norder[marker] = None : Menghapus nilai yang telah diproses dengan mengubahnya menjadi None\nelse: break : Menghentikan loop jika non_none_values kosong, yang berarti semua nilai dalam order telah diproses\n\nMengonversi matriks new_matrix menjadi string tunggal dengan menggabungkan nilai-nilainya secara berurutan dan menghapus spasi ekstra di akhir string\nresult_string = \"\"\n\nfor row in new_matrix:\n    for value in row:\n        result_string += str(value)\n\nresult_string = result_string.strip()\n\nprint(result_string)\nFor More Detail :\n\nresult_string = \"\" : Inisialisasi string kosong result_string yang akan digunakan untuk menyimpan hasil akhir\nfor row in new_matrix: : Melakukan iterasi melalui setiap baris dalam new_matrix\nfor value in row: : Melakukan iterasi melalui setiap nilai dalam baris row\nresult_string += str(value) : Mengonversi nilai value menjadi string (jika belum string) dan menambahkannya ke result_string\nresult_string = result_string.strip() : Menghapus spasi ekstra di awal dan akhir string menggunakan metode strip()\n\nHasil Ciphertext : ENTKFINOKKM TIAIRA\n\n\nProses Dekripsi\ncipherTeks = input(\"masukkan kata : \")\nkey = input(\"masukkan kunci : \")\ncleanCipherTeks = cipherTeks.replace(\" \", \" \")\nprint(cleanCipherTeks)\nkolom = 0\nangka_urutan = []\nfor huruf in key:\n    if huruf.isalpha():\n        angka_urutan.append(ascii[huruf.lower()])\n        kolom = kolom+1\n        cleanKey = angka_urutan\n\nprint(f\"Urutan kunci dari kata '{key}' adalah: {angka_urutan}\")\nmatrix = []\npanjang = len(cleanCipherTeks)\ntemp = panjang/kolom\nbaris = round(temp)\nprint(baris)\nfor i in range(baris):\n    row = []\n    for j in range(kolom):\n        if i * kolom + j &lt; len(cleanCipherTeks):\n            elemen = cleanCipherTeks[i + baris * j]\n        else:\n            elemen = \"a\"\n        row.append(elemen)\n    matrix.append(row)\nprint(\"Matriks yang Anda buat:\")\nfor row in matrix:\n    print(row)\ntransposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\nfor row in transposed_matrix:\n    print(row)\norder = [None] * len(cleanKey)\ni = 0\nwhile len(cleanKey) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, cleanKey))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = cleanKey.index(nilai_terkecil)\n        order[marker] = i\n        cleanKey[marker] = None  \n        i = i + 1\n    else:\n        break\nprint(order)\ntransposed_matrix = [transposed_matrix[i] for i in order]\n\nfor row in transposed_matrix:\n    print(row)\nmatriks = [[row[i] for row in transposed_matrix] for i in range(len(transposed_matrix[0]))]\nfor row in matriks:\n    print(row)\nresult_string = \"\"\n\nfor row in matriks:\n    for value in row:\n        result_string += str(value)\n\nresult_string = result_string.strip()\n\nprint(result_string)\nHasil Dekripsi : TEKNIKINFORMATIKA\nPerbedaan Proses :\n\nEnkripsi: Teks asli diubah menjadi matriks berdasarkan kolom kunci, kemudian kolom-kolom diurutkan berdasarkan kunci. Pada enkripsi, transposed_matrix adalah matriks transposisi dari matrix awal\nDekripsi: Teks sandi diubah menjadi matriks berdasarkan kolom kunci, kemudian baris-baris diurutkan berdasarkan kunci untuk mengembalikan teks asli. Pada dekripsi, transposed_matrix diurutkan berdasarkan order untuk mengembalikan teks asli",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Playfair"
    ]
  },
  {
    "objectID": "1_caesar.html",
    "href": "1_caesar.html",
    "title": "1. Caesar Cipher",
    "section": "",
    "text": "Analogi Caesar Cipher\nMisalkan kita memiliki teks “HELLO” dan kita ingin mengenkripsinya dengan kunci pergeseran 3 posisi ke kanan.",
    "crumbs": [
      "Kriptografi Klasik",
      "1. Caesar Cipher"
    ]
  },
  {
    "objectID": "1_caesar.html#lingkungan-pengembangan-web",
    "href": "1_caesar.html#lingkungan-pengembangan-web",
    "title": "1. Caesar",
    "section": "Lingkungan Pengembangan Web",
    "text": "Lingkungan Pengembangan Web\n\nEditor kode\n\n\n\nVisual Studio Code\n\n\nGunakan editor teks atau lingkungan pengembangan terintegrasi (IDE) seperti Visual Studio Code, Sublime Text, atau Atom untuk menulis kode web. \n\n\nBrowser\n\nBerbagai browser seperti Chrome, Firefox, atau Safari digunakan untuk menguji dan melihat hasil dari halaman web yang dikembangkan. \n\n\nServer lokal\nAnda dapat menginstal server web lokal seperti Apache, Nginx, atau XAMPP untuk menguji halaman web secara lokal sebelum diunggah ke server publik.\n\n\nURL (Uniform Resource Locator)\nAlamat yang digunakan untuk mengakses halaman web. URL terdiri dari protokol (misalnya http:// atau https://), nama domain, dan path halaman.\n\n\n\nHTTP (Hypertext Transfer Protocol)\nProtokol komunikasi yang digunakan untuk mentransfer data antara klien dan server. Permintaan klien dan respons server terjadi melalui metode HTTP seperti GET, POST, PUT, dan DELETE.\n\n\n\nMarkup Languages\nMarkup languages adalah bahasa yang digunakan untuk membuat struktur dan tampilan konten dalam halaman web.\n\nHTML (HyperText Markup Language) adalah markup language yang paling umum digunakan untuk membangun struktur halaman web. XML (eXtensible Markup Language) digunakan untuk menyimpan dan mengirim data secara terstruktur.\nStruktur Dasar HTML\nMerupakan bahasa markup paling popular, disusul eXtensible Markup Language (XML). XML adalah bahasa yang digunakan untuk membuat bahasa markup lain yaitu Wireless Markup Language (WML).Bahasa markup bukan bahasa pemrograman. Oleh karena itu, penyebutan bahasa pemrograman HTML adalah kurang tepat.\nFormat Dasar HTML\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Untitled Document&lt;/title&gt;\n&lt;meta http-equiv=\"Content-Type\" content=\"text/html;\ncharset=iso-8859-1\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n{ Tempat untuk coding }\n&lt;/body&gt;\n&lt;/html&gt;\n&lt; HTML &gt;\nDokumen HTML harus diawali dengan tag &lt; html &gt; dan diakhiri dengan &lt; /html &gt;memberi tahu kepada browser bahwa yang berada dalam kedua tag tersebut adalah dokumen HTML.\n&lt; HEAD &gt; Bagian header dalam dokumen HTML. Biasanya berisi judul halaman web. Bentuk secara umum:\n&lt;head&gt;\n&lt;title&gt;Judul ini akan ditampilkan pada bagian atas\nbrowser\n&lt;/title&gt;\n&lt;/head&gt;\n&lt; BODY &gt;\nBagian isi dari dokumen HTML yang dapat disisipkan teks, gambar, video maupun link. Sesuatu yang ditulis di dalam bodyakan ditampilkan pada halaman web.\nHTML Tags\nInstruksi/perintah dalam HTML disebut tag. Tag pada HTML tidak bersifat case sensitive.\n&lt;element atribut=value&gt;\nKeterangan:\n\nelement = nama tag\natribut = atribut\nvalue = nilai dari atribut Contoh:\n\n&lt;font color=red&gt;\n\nFONT merupakan element,\nCOLOR merupakan atribut,\nRED adalah value\n\n\n\n\n\n\n\nContoh HTML\n\n\n\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;\nHalaman Latihan 1\n&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;\nIni adalah latihan pemrograman web pertamaku.\n&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nCSS (Cascading Style Sheets) digunakan untuk mengatur tampilan dan gaya elemen-elemen dalam halaman web.\n\n\n\nArsitektur Klien dan Server\n\n\n\nArsitektur Klien dan Server\n\n\nPada pemrograman web, arsitektur klien dan server digunakan. Klien (misalnya browser web) mengirimkan permintaan ke server, dan server merespons dengan mengirimkan halaman web yang diminta.\nKlien menginterpretasikan halaman web menggunakan HTML, CSS, dan JavaScript, sementara server mengurus pemrosesan data dan logika di balik halaman.\n\n\n\nDatabase\n\n\n\nDatabase MySQL\n\n\nDBMS atau Database Management System digunakan untuk menyimpan dan mengelola data dalam aplikasi web. Beberapa sistem database yang umum digunakan termasuk MySQL, PostgreSQL, MongoDB, dan Oracle. Pemahaman tentang database meliputi pembuatan tabel dan relasi antar tabel, manipulasi data dengan menggunakan bahasa query seperti SQL, dan pengoptimalan kinerja database\n\n\n\nFramework\n\n\n\n\n\n\n\n\n\nLaravel\n\n\n\n\n\n\n\nBootstrap\n\n\n\n\n\nFramework adalah kerangka kerja perangkat lunak yang menyediakan struktur, komponen, dan alat bantu untuk membangun aplikasi web dengan lebih cepat dan efisien. Framework menyediakan aturan dan konvensi yang konsisten, menyederhanakan tugas umum, jika seperti routing, validasi data, interaksi dengan database, dan lainnya. Dalam pemrograman web khsusnya dengan menggunakan bahasa pemrograman php yang populer termasuk Laravel dan CodeIgniter. Dalam pemrograman web,\n\n\n\nWeb Servers\n\n\n\nApache Server\n\n\nWeb server adalah perangkat lunak yang mengelola permintaan dari browser dan mengirimkan halaman web ke pengguna melalui protokol HTTP. Beberapa server web yang umum digunakan adalah Apache, Nginx, dan IIS (Internet Information Services). Pemahaman tentang konfigurasi server web, manajemen domain, dan penanganan permintaan HTTP penting dalam pengembangan web.\n\n\n\nVersion Control\nVersion control adalah metode untuk melacak perubahan kode sumber selama pengembangan aplikasi. Git adalah sistem version control yang populer yang memungkinkan pengembang untuk bekerja secara kolaboratif, membuat cabang (branch), menggabungkan perubahan (merge), dan melakukan pemulihan (revert) jika terjadi kesalahan. Version control membantu dalam manajemen kode, pengendalian versi, dan kolaborasi tim.\n\n\n\nResposive Web Design\nResponsive web design adalah pendekatan desain web yang memastikan tampilan dan pengalaman pengguna yang optimal di berbagai perangkat dan ukuran layar. Ini melibatkan penggunaan teknik seperti media queries, flexible grids, dan CSS frameworks (seperti Bootstrap atau Foundation) untuk mengatur tata letak dan tampilan halaman web secara responsif.\n\n\n\nTesting and Debugging\nTesting dan debugging adalah proses penting dalam pengembangan web untuk memastikan aplikasi berfungsi dengan baik dan bebas dari kesalahan. Testing adalah proses verifikasi dan validasi untuk memastikan bahwa aplikasi web berfungsi sesuai dengan yang diharapkan dan memenuhi persyaratan bisnis yang telah ditetapkan. Tujuan dari testing adalah untuk menemukan bug atau kesalahan dalam aplikasi sebelum dirilis ke pengguna akhir. Debugging adalah proses untuk menemukan, mendiagnosis, dan memperbaiki bug atau kesalahan dalam kode aplikasi web.\n\n\n\nAPI (Application Programming Interface)\nAPI adalah antarmuka yang memungkinkan aplikasi web berkomunikasi dan berbagi data dengan aplikasi atau layanan lain. RESTful API adalah pendekatan populer untuk mengembangkan API yang menggunakan protokol HTTP dan standar seperti JSON atau XML untuk bertukar data.",
    "crumbs": [
      "Kriptografi Klasik",
      "1. Caesar{.unnumbered}"
    ]
  },
  {
    "objectID": "1_caesar.html#php-hypertext-preprocessor",
    "href": "1_caesar.html#php-hypertext-preprocessor",
    "title": "1. Caesar",
    "section": "PHP (Hypertext Preprocessor)",
    "text": "PHP (Hypertext Preprocessor)\nPHP adalah bahasa pemrograman server-side yang populer untuk pengembangan web. PHP digunakan untuk memproses permintaan dari klien, mengakses basis data, dan menghasilkan respons yang dikirimkan kembali ke klien.\n\nMemulai PHP\nSetiap memulai kode php selalu diawali dengan &lt;?php dan ditutup dengan ?&gt; \n&lt;?php\n    $kata = \"Hello World!\"\n    echo \"$kata\"; // Output: Hello World!\n?&gt;\nMenggunakan echo untuk print\nDalam variabel php menggunakan tanda $ ($variable) untuk inisialisasi variabel\n\n\nPHP - Kondisional\nKondisional dalam bahasa pemrograman adalah proses yang berfungsi untuk menentukan blok instruksi akan dieksekusi atau tidak, tergantung pada kondisinya sendiri seperti nilainya sudah benar (True) atau belum (False). Ada beberapa jenis percabangan yaitu if-else, switch case dll.\n$angka = -5;\nif($angka &lt; 0){\n    echo 'Angka negatif';\n} else {\n    echo'Angka positif ';\n};\n//Output : Angka Negatif\n$input = 3;\nswitch($input){\n    case \"1\":\n    echo\"Inputan adalah satu\";\n    break;\n    case \"2\":\n    echo\"Inputan adalah dua\";\n    break;\n    case \"3\":\n    echo\"Inputan adalah tiga\";\n    break;\n    default:\n    echo\"Tidak ada input yang cocok dengan pilihan anda.\";\n    }\n    /* Output: Inputan adalah tiga\n    Jika nilai dari variable `$input` bukan sama dengan `case`,\n    maka akan menampilkan pesan “Tidak ada input yang cocok\n    */\n\n\n\nPHP – isset dan empty\nFungsi isset digunakan untuk memeriksa apakah suatu variabel telah diatur atau tidak. Sintaks fungsi ini sebagai berikut:\n$nama = \"Bengkel Koding\";\nif(isset($nama)){\n    print(\"Nama telah diatur\");\n} else {\n    print(\"Nama belum diatur\")\n}\n// output : Nama telah diatur\n\nFungsi empty digunakan untuk memeriksa apakah suatu variabel kosong atau tidak. Sintaks fungsi ini sebagai berikut:\n$nama = \"\";\nif(empty($nama)) {\n    print(\"nama kosong\");\n} else {\n    print(\"nama tidak kosong\");\n}\n// output : Nama kosong\n\n\n\nPHP - Looping\nPerulangan pada php terdapat beberapa fungsi yang dapat digunakan, diantaranya adalah for, while, do while, dan foreach\n\nLooping For\nLooping For adalah salah satu looping statement pada bahasa pemrograman php, yang memiliki sintaks seperti for (expression1; expression2; expression3) {} dimana expression 1 merupakan awal dari pengulangan, expression 2 menentukan kondisi yang harus terpenuhi agar perintah d iterasi lebih lanjut, sedangkan expresion 3 mengubah nilai variable dalam setiap iterasinya.\nContoh Penggunaannya:\nfor ($i=0;$i&lt;=5;$i++){\necho \"$i \";\n}\n// Output: 0 1 2 3 4 5\nDalam contoh diatas, nilai x mulai dari angka 0 dan terus ditambah sampai batas yaitu &lt;=5. Setelah itu akan di eksekusi dengan cara mencetak isi value dari x ke layar.\n\n\nWhile\nLooping while juga ada didalam bahasa pemograman PHP, sintaksnya sama tapi bedanya hanya bisa melakukan looping selama kondisinya benar/true.\nContohnya:\n$x = 0; //awal variabel $x\nwhile($x &lt;= 5){\necho \"$x \";\n$x++;\n}\n// Output : 0 1 2 3 4 5\n\n\nDo While\nPerulangan do-while adalah perintah yang digunakan untuk mengulang suatu proses terhadap nilai kondisional (expression) saat awal loop dilanjutkan dengan evaluasi ulang pada akhir setiap iterasi.\nSintaks nya adalah sebagai berikut:\n$i = 1;\ndo{\n    echo $i;\n    $i++;\n} while ($i &lt;= 5);\n// Output : 0 1 2 3 4 5\n\n\nForeach\nForeach merupakan perintah yang digunakan untuk mengiterasi set data array dalam bahasa pemrograman php. Sintaks nya seperti ini:\n$buah = array(\"Apel\", \"Jeruk\", \"Mangga\", \"Pisang\");\nforeach ($buah as $item) :\n    echo $item . \"\\n\";\nendforeach;\n/* output : \napel\njeruk\nmangga\npisang\n*/\nSelain menggnakan endforeach bisa juga menggunakan kurung kurawal {}\n$buah = array(\"Apel\", \"Jeruk\", \"Mangga\", \"Pisang\");\nforeach ($buah as $item) {\n    echo $item . \"\\n\";\n}\n/* output : \napel\njeruk\nmangga\npisang\n*/\n\n\n\nInclude - Require\nFungsi-fungsi ini digunakan untuk menyisipkan (include) atau memasukkan (require) file PHP eksternal ke dalam file PHP yang sedang aktif. Berguna untuk mengorganisir kode secara modular.",
    "crumbs": [
      "Kriptografi Klasik",
      "1. Caesar{.unnumbered}"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Kriptografi",
    "section": "",
    "text": "Pengantar\nKriptografi adalah ilmu dan praktik untuk menjaga keamanan informasi dengan cara mengubah teks biasa menjadi bentuk yang tidak mudah dibaca atau dimengerti oleh pihak yang tidak berwenang.\nMetode kriptografi melibatkan penggunaan algoritma matematika yang kompleks untuk mengubah teks biasa (plaintext) menjadi teks terenkripsi (ciphertext), yang kemudian dapat didekripsi kembali menjadi plaintext dengan menggunakan kunci yang sesuai.",
    "crumbs": [
      "**Pengantar**"
    ]
  },
  {
    "objectID": "index.html#materi-junior-web-developer",
    "href": "index.html#materi-junior-web-developer",
    "title": "Kriptografi",
    "section": "Materi Junior Web Developer",
    "text": "Materi Junior Web Developer\nTerdapat topik-topik dan materi-materi yang akan diajarkan, diantaranya sebagai berikut:\n\n\nTopik dan Materi Junior Web Developer\n\n\n\n\n\n\n\nTopik\nMateri\nOutcome\n\n\n\n\nWeb Developments Fundamentals \n1. Konsep Dasar Pemrograman Berbasis Web  2. Pengenalan Tools (J.620100.001.01), Library, komponen dan Framework pemrograman berbasis web (J.620100.003.01) \nPeserta memahami konsep dasar pemrograman berbasis web, mengenal tools, library, framework yang diperlukan untuk mengembangkan aplikasi berbasis web \n\n\nMelakukan Migrasi ke Teknologi Baru (J.620100.024.02) \n1. Pengenalan Responsive Web Design (Mobile First),  2. Praktek Instalasi Bootstrap Framework \nPeserta memiliki pengetahuan mengenai teknologi terkini dalam pembangunan aplikasi berbasis web dan cara menggunakannya \n\n\nMenerapkan Rancangan User Interface / User Experience (UI/UX) (J.620100.006.01) dan alert notification jika terdapat suatu permasalahan pada aplikasi (J.620100.044.01) \nPraktek mengimplementasikan design UI halaman depan (front page) aplikasi To Do List menggunakan Bootstrap \nPeserta dapat menerapkan rancangan UI/UX dan alert notification dari project yang diberikan \n\n\nKonsep Basis Data Dan Menggunakan SQL (J.620100.020.02)\n1. Review Konsep Basis Data  2. Query SQL: DDL, DML  3. Praktek membuat database dan tabel aplikasi To Do List \nPeserta memiliki pengetahuan mengenai konsep Basis Data dan menggunakan Database Management System (DBMS) berbasis SQL \n\n\nMenerapkan Pemrograman Terstruktur (J.620100.017.02) Dan Akses Basis Data (J.620100.021.02) \nPraktek pembuatan Aplikasi To Do List  Praktek Studi Kasus aplikasi Poliklinik (langkah-langkah pembuatan) \nPeserta mampu menerapkan konsep dasar pemrograman terstruktur dan mengakses basis data menggunakan kode program \n\n\nDebugging, Pengujian Program dan Code Review (J.620100.025.02, J.620100.036.02, J.620100.032.01) \nPengenalan Tool untuk melakukan pengujian aplikasi berbasis web   Praktek software testing aplikasi Poliklinik \nPeserta mampu melakukan debugging, pengujian program, meninjau dan memeriksa kode program yang telah dibuat \n\n\nPembaruan Perangkat Lunak pada Web Dasar (J.620100.047.01)\nPraktek mengembangkan aplikasi Poliklinik  Penilaian final project \nPeserta dapat menambahkan fitur tambahan dari project web yang diberikan",
    "crumbs": [
      "**Pengantar**"
    ]
  },
  {
    "objectID": "5_transposisi_kolom.html",
    "href": "5_transposisi_kolom.html",
    "title": "5. Transposisi Kolom",
    "section": "",
    "text": "Analogi Transposisi Kolom\nBayangkan Kita memiliki rak buku dengan beberapa kolom dan setiap kolom berisi tumpukan buku.\nDengan kata lain, transposisi kolom mengubah urutan kolom tanpa mengubah isi kolom. Dalam kriptografi, ini dilakukan untuk mengacak data agar lebih sulit ditebak oleh pihak yang tidak berwenang.",
    "crumbs": [
      "Kriptografi Klasik",
      "5. Transposisi Kolom"
    ]
  },
  {
    "objectID": "5_transposisi_kolom.html#implementasi-pada-python",
    "href": "5_transposisi_kolom.html#implementasi-pada-python",
    "title": "5. Transposisi Kolom",
    "section": "Implementasi Pada Python",
    "text": "Implementasi Pada Python\nMasukkan plaintext\nCONTOH : TEKNIK INFORMATIKA\nplainText = input(\"Plaintext : \")\nMasukkan kunci\nCONTOH : UDINUS\nkey = input(\"masukkan kunci : \")\nMembersihkan teks dari spasi ganda\ncleanPlainTeks = plainTeks.replace(\" \", \"\")\nprint(cleanPlainTeks)\nDeklarasi urutan huruf dalam alfabet\nascii = {\n'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8, 'i': 9, 'j': 10, 'k': 11, \n'l': 12, 'm': 13, 'n': 14, 'o': 15, 'p': 16, 'q': 17, 'r': 18, 's': 19, 't': 20, 'u': 21, \n'v': 22, 'w': 23, 'x': 24, 'y': 25, 'z': 26\n}",
    "crumbs": [
      "Kriptografi Klasik",
      "5. Transposisi Kolom"
    ]
  },
  {
    "objectID": "1_caesar.html#implementasi-pada-python",
    "href": "1_caesar.html#implementasi-pada-python",
    "title": "1. Caesar Cipher",
    "section": "Implementasi Pada Python",
    "text": "Implementasi Pada Python\nLANGKAH 1 :  Deklarasi kamus (dictionary) abjad_indeks -&gt; Kamus ini memetakan setiap huruf alfabet ke sebuah indeks numerik.\nabjad_indeks = {\n    'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5,\n    'f': 6, 'g': 7, 'h': 8, 'i': 9, 'j': 10,\n    'k': 11, 'l': 12, 'm': 13, 'n': 14, 'o': 15,\n    'p': 16, 'q': 17, 'r': 18, 's': 19, 't': 20,\n    'u': 21, 'v': 22, 'w': 23, 'x': 24, 'y': 25, 'z': 26\n}\nLANGKAH 2 :  Deklarasi variabel key -&gt; Nilai key ditetapkan ke 3, yang berarti setiap huruf dalam pesan akan digeser sebanyak 3 posisi dalam alfabet untuk enkripsi. Selanjutnya Input variabel pesan -&gt; Pesan yang akan dienkripsi.\n# Key untuk pergeseran\nkey = 3\n# Deklarasi variabel pesan: Pesan yang akan dienkripsi.\npesan = input(\"Masukkan pesan     : \")\ncleanPesan = pesan.replace(\" \", \"\")\nprint(\"Pesan Anda         :\",cleanPesan)\nPesan Anda : udinus\n\nProses Enkripsi\nLANGKAH 3 :  Inisialisasi pesan_terenkripsi: String kosong untuk menyimpan hasil enkripsi.\n\nIterasi melalui setiap huruf dalam pesan: Menggunakan loop for. Cek apakah huruf ada di abjad_indeks:\nJika Ya Hitung indeks baru dengan formula (abjad_indeks[huruf] + key) % 26. Ini menggeser posisi huruf dalam alfabet.\nCari huruf baru yang sesuai dengan indeks baru dari daftar kunci abjad_indeks dan tambahkan ke pesan_terenkripsi.\nJika Tidak (misalnya angka atau simbol): Tambahkan huruf tersebut langsung kepesan_terenkripsi tanpa perubahan.\n\n\npesan_terenkripsi = ''\nfor huruf in cleanPesan:\n    if huruf in abjad_indeks:\n        indeks = (abjad_indeks[huruf] + key) % 26\n        pesan_terenkripsi += list(abjad_indeks.keys())[indeks - 1]\n    else:\n        pesan_terenkripsi += huruf\n\nprint(\"Pesan terenkripsi:\", pesan_terenkripsi)\nPesan terenkripsi: xglqxv\n\n\nProses Dekripsi\nLANGKAH 4 :  Inisialisasi pesan_terdekripsi: String kosong untuk menyimpan hasil dekripsi.\n\nIterasi melalui setiap huruf dalam pesan: Menggunakan loop for. Cek apakah huruf ada di abjad_indeks:\nJika Ya Hitung indeks baru dengan formula (abjad_indeks[huruf] - key) % 26. Ini menggeser posisi huruf dalam alfabet.\nCari huruf baru yang sesuai dengan indeks baru dari daftar kunci abjad_indeks dan tambahkan ke pesan_terenkripsi.\nJika Tidak (misalnya angka atau simbol): Tambahkan huruf tersebut langsung kepesan_terenkripsi tanpa perubahan.\n\npesan_terdekripsi = ''\nfor huruf in pesan_terenkripsi:\n    if huruf in abjad_indeks:\n        indeks = (abjad_indeks[huruf] - key) % 26\n        pesan_terdekripsi += list(abjad_indeks.keys())[indeks - 1]\n    else:\n        pesan_terdekripsi += huruf\n\nprint(\"Pesan terdekripsi:\", pesan_terdekripsi)\nPesan terdekripsi:: udinus",
    "crumbs": [
      "Kriptografi Klasik",
      "1. Caesar Cipher"
    ]
  },
  {
    "objectID": "3_vigenere_cipher.html",
    "href": "3_vigenere_cipher.html",
    "title": "3. Vigenere Cipher",
    "section": "",
    "text": "Analogi Vigenere Cipher\nMisalnya, jika kita memiliki teks “HELLO” dan kunci “KEY”, kita akan menggeser huruf-huruf dalam teks “HELLO” sesuai dengan urutan huruf dalam kata kunci “KEY”.",
    "crumbs": [
      "Kriptografi Klasik",
      "3. Vigenere Cipher"
    ]
  },
  {
    "objectID": "3_vigenere_cipher.html#teks-editor",
    "href": "3_vigenere_cipher.html#teks-editor",
    "title": "3. Vigenere Cipher",
    "section": "",
    "text": "Silahkan download file installer dari Visual Studio Code. Klik download pada halaman web Visual Studio Code sesuai dengan sistem operasi yang digunakan.\n\n\n\n\nLaman VSCode\n\n\n\nSetelah selesai download, klik dua kali pada file installer.\nJika muncul peringatan Run as Administrator, klik Yes.\nKemudian akan tampil window Installer Microsoft Visual Studio Code. Untuk menyetujui License Agreement, pilih “I accept the agreement” lalu next.\n\n\n\n\nLicense Agreement VS Code\n\n\n\nLalu pilih lokasi instalasinya. Jika ingin menggunakan lokasi default dapat langsung klik next.\n\n\n\n\nLokasi instalasi VS Code\n\n\n\nMemilih lokasi shortcuts program. Jika ingin menggunakan default dapat langsung klik next.\nPada bagian Select Additional Tasks, terdapat beberapa tasks yang bisa diinstall atau tidak. Untuk memudahkan ketika membuka file melalui berkas atau explorer dapat dipilih semua dan klik next.\nKlik install dan jalankan Visual Studio Code\n\n\n\n\nvscode\n\n\n\n\n\n\n\n\nIntalasi Visual Studio Code",
    "crumbs": [
      "Kriptografi Klasik",
      "3. Vigenere Cipher"
    ]
  },
  {
    "objectID": "3_vigenere_cipher.html#web-browser",
    "href": "3_vigenere_cipher.html#web-browser",
    "title": "3. Vigenere Cipher",
    "section": "Web Browser",
    "text": "Web Browser\nWeb browser adalah perangkat lunak yang awalnya dirancang untuk menampilkan dokumen web/HTML. Namun, pada saat ini, web browser harus memiliki kemampuan untuk menginterpretasikan dan menjalankan JavaScript atau VBScript, menjalankan Java Applet, memahami dokumen XML, dan menjalankan dokumen khusus dengan menggunakan fasilitas plugin seperti file .swf Macromedia Flash, dan lain sebagainya. \nBanyak web browser yang dapat digunakan, dan paling umum digunakan adalah Google Chrome dan Mozilla Firefox atau dapat menggunakan web browser yang tersedia pada laptop atau pc yang digunakan seperti safari atau microsoft edge. \n\n\n\n\n\n\n\n\n\nChrome\n\n\n\n\n \n\n\n\n\n\nMozilla Firefox",
    "crumbs": [
      "Kriptografi Klasik",
      "3. Vigenere Cipher"
    ]
  },
  {
    "objectID": "3_vigenere_cipher.html#web-server",
    "href": "3_vigenere_cipher.html#web-server",
    "title": "3. Vigenere Cipher",
    "section": "Web Server",
    "text": "Web Server\nWeb Server adalah server HTTP yang bertugas menyediakan dokumen yang diminta oleh web browser. Saat ini, web server telah berkembang menjadi lebih kompleks karena harus melayani banyak fungsi dan bahkan menjadi pusat layanan-layanan lain. \nWeb server juga menjadi komponen yang sangat penting dalam application server. Sebagai server HTTP, web server harus dapat menangani permintaan dokumen yang diberikan oleh web browser dan juga harus bisa dikonfigurasi untuk berinteraksi dengan program-program seperti JSP, ASP, PHP, melalui CGI, dan sebagainya. Contoh-contoh web server yang populer antara lain Apache dan IIS (Internet Information Service). \nXAMPP \nXAMPP adalah sebuah web server open source yang dapat berjalan diberbagai sistem operasi seperti Windows, Linux, dan MacOS. \nXAMPP menyediakan semua komponen yang diperlukan untuk mengelola sebuah website, termasuk Apache, MySQL/MariaDB, PHP, dan Perl. XAMPP dapat digunakan untuk membuat web server lokal di komputer. \nUntuk menginstall XAMPP ikuti langkah-langkah berikut: \n\nUnduh file installer dari website XAMPP. Unduh sesuai dengan sistem operasi atau komputer yang digunakan. \n\n\n\n\nWeb XAMPP\n\n\n\nLakukan instalasi XAMPP sesuai panduan (wizard) yang ditampilkan dan pilih Yes untuk melanjutkan instalasi. Bila ada pesan error biarkan saja. \n\n\n\n\nPesan error\n\n\n\nPilih komponen yang Anda butuhkan dalam instalasi tersebut. Sebagai contoh, centang MySQL dan phpMyAdmin.\nTentukan direktori instalasi yang tepat, misalnya C:\\xampp.\nLanjutkan tahapan dan klik install.\n\n Untuk melihat konfigurasi php dapat membuka config pada baris apache lalu membuka php.ini \n\n\n\nApache Config\n\n\nCek versi php dan ekstensi lain dengan cara membuat file “info.php” yang isinya &lt;?php phpinfo(); ?&gt;, letakkan pada C:\\xampp\\htdocs. Lalu buka localhost/info.php pada browser\n\n\n\n\n\n\nInstalasi Xampp",
    "crumbs": [
      "Kriptografi Klasik",
      "3. Vigenere Cipher"
    ]
  },
  {
    "objectID": "3_vigenere_cipher.html#bootstrap",
    "href": "3_vigenere_cipher.html#bootstrap",
    "title": "3. Vigenere Cipher",
    "section": "Bootstrap",
    "text": "Bootstrap\nBootstrap adalah sebuah kerangka kerja (framework) front-end yang populer untuk pengembangan desain web responsif (responsive web design). Dikembangkan oleh tim Twitter, Bootstrap menyediakan serangkaian komponen dan gaya CSS yang dapat digunakan untuk membangun tampilan web yang konsisten, menarik, dan responsif secara cepat. Sampai dengan modul ini dibuat, Bootstrap telah mengalami pembaruan Bootstrap versi 5.\n\n\n\n\nBootstrap\n\n\n\nCara instalasi Bootstrap \n\nBuka halaman resmi Bootstrap di https://getbootstrap.com.\nDi halaman utama, Anda akan melihat tombol “Download” di bagian bawah. Klik tombol tersebut untuk mengunduh file Bootstrap. \n\n\n\n\n\n\n\n\n\n\nTampilan Halaman Bootstrap\n\n\n\n\n \n\n\n\n\n\nDownload Paket Bootstrap\n\n\n\n\n\n\nSetelah selesai mengunduh, ekstrak file zip Bootstrap yang telah diunduh ke direktori proyek web Anda. \n\n\n\n\nEkstrak File\n\n\n\nDi dalam direktori proyek, buatlah folder baru (misalnya “css” dan “js”) untuk menyimpan file CSS dan JavaScript Bootstrap. \n\n\n\n\nEkstrak File\n\n\n\nSalin file bootstrap.min.css yang ada di dalam direktori “dist/css” dalam file Bootstrap yang telah diekstrak, ke dalam folder “css” di dalam direktori proyek Anda.\nSalin file bootstrap.min.js yang ada di dalam direktori “dist/js” dalam file Bootstrap yang telah diekstrak, ke dalam folder “js” di dalam direktori proyek Anda.\nSetelah itu, Anda dapat menggunakan Bootstrap dengan menautkan file CSS dan JavaScript ke dalam halaman HTML Anda. Dalam elemen &lt;head&gt; dari file HTML, tambahkan tag link berikut untuk menautkan file CSS Bootstrap: \n\n&lt;link rel=\"stylesheet\" href=\"css/bootstrap.min.css\"&gt;\n\nJuga di dalam elemen &lt;body&gt; atau sebelum penutup tag &lt;/body&gt; dalam file HTML, tambahkan tag script berikut untuk menautkan file JavaScript Bootstrap: \n\n&lt;script src=\"js/bootstrap.min.js\"&gt;&lt;/script&gt; \n\nSekarang, Anda dapat menggunakan kelas-kelas, komponen, dan gaya Bootstrap dalam halaman web Anda.Sekarang, Anda dapat menggunakan kelas-kelas, komponen, dan gaya Bootstrap dalam halaman web Anda.\n\n\n\n\n\n\n\nInstalasi Bootstrap\n\n\n\nBerikut adalah penjelasan mengenai instalasi bootstrap!",
    "crumbs": [
      "Kriptografi Klasik",
      "3. Vigenere Cipher"
    ]
  },
  {
    "objectID": "3_vigenere_cipher.html#implementasi-pada-python",
    "href": "3_vigenere_cipher.html#implementasi-pada-python",
    "title": "3. Vigenere Cipher",
    "section": "Implementasi Pada Python",
    "text": "Implementasi Pada Python\nLANGKAH 1 :  Deklarasi kamus (dictionary) abjad -&gt; Kamus ini memetakan setiap huruf alfabet ke sebuah indeks numerik.\nabjad = {\n    'A': 1, 'B': 2, 'C': 3, 'D': 4, 'E': 5,\n    'F': 6, 'G': 7, 'H': 8, 'I': 9, 'J': 10,\n    'K': 11, 'L': 12, 'M': 13, 'N': 14, 'O': 15,\n    'P': 16, 'Q': 17, 'R': 18, 'S': 19, 'T': 20,\n    'U': 21, 'V': 22, 'W': 23, 'X': 24, 'Y': 25, 'Z': 26\n}\nLANGKAH 2 :  Masukkan Plaintext dan Kunci\n# Input teks asli dan kunci\nteks = input(\"Masukkan Plaintext : \")\nkunci = \"key\"\nteks = teks.upper()\nkunci = kunci.upper()\nMasukkan Plaintext : udinus24\n\nProses Enkripsi\nLANGKAH 3 :  Melakukan Enkripsi\n# Inisialisasi variabel hasil\npesan_terenkripsi = ''\npanjang_kunci = len(kunci)\nindeks_kunci = 0\n\n# Iterasi melalui setiap karakter di teks asli\nfor huruf in teks:\n    # Periksa apakah karakter adalah huruf alfabet\n    if huruf in abjad:\n        # Temukan indeks dari teks asli dan kunci\n        indeks_teks = abjad[huruf]\n        huruf_kunci = kunci[indeks_kunci % panjang_kunci]\n        indeks_huruf_kunci = abjad[huruf_kunci]\n\n        # Hitung indeks hasil menggunakan rumus Vigenere cipher\n        indeks_hasil = (indeks_teks + indeks_huruf_kunci - 1) % 26 + 1\n\n        # Temukan karakter hasil berdasarkan indeks\n        for k, v in abjad.items():\n            if v == indeks_hasil:\n                pesan_terenkripsi += k\n                break\n\n        # Pindah ke karakter berikutnya dalam kunci\n        indeks_kunci += 1\n    else:\n        # Jika karakter bukan alfabet, tambahkan tanpa perubahan\n        pesan_terenkripsi += huruf\nCETAK HASIL ENKRIPSI : \nteks_per_huruf = ', '.join(f\"'{char}'\" for char in teks)\n# Menyusun kunci berulang sesuai panjang teks asli\nkunci_berulang = (kunci * (len(teks) // panjang_kunci)) + kunci[:len(teks) % panjang_kunci]\nkunci_per_huruf = ', '.join(f\"'{char}'\" for char in kunci_berulang)\n# output\nhasil_encrypt = ', '.join(f\"'{char}'\" for char in pesan_terenkripsi)\n\nprint(f\"Plaintext     : {teks_per_huruf}\")\nprint(\"\")\nprint(f\"Kunci         : {kunci_per_huruf}\")\nprint(\"\")\nprint(f\"Hasil Encrypt : {hasil_encrypt}\")\nPlaintext     : 'U', 'D', 'I', 'N', 'U', 'S', '2', '4' \nKunci         : 'K', 'E', 'Y', 'K', 'E', 'Y', 'K', 'E' \nHasil Encrypt : 'F', 'I', 'H', 'Y', 'Z', 'R', '2', '4' \n\n\nProses Dekripsi\nLANGKAH 4 :  Melakukan Dekripsi\n# Inisialisasi variabel hasil\npesan_terdekripsi = ''\npanjang_kunci = len(kunci)\nindeks_kunci = 0\n\n# Iterasi melalui setiap karakter di teks asli\nfor huruf in pesan_terenkripsi:\n    # Periksa apakah karakter adalah huruf alfabet\n    if huruf in abjad:\n        # Temukan indeks dari teks asli dan kunci\n        indeks_teks = abjad[huruf]\n        huruf_kunci = kunci[indeks_kunci % panjang_kunci]\n        indeks_huruf_kunci = abjad[huruf_kunci]\n\n        # Hitung indeks hasil menggunakan rumus Vigenere cipher\n        indeks_hasil = (indeks_teks - indeks_huruf_kunci - 1) % 26 + 1\n\n        # Temukan karakter hasil berdasarkan indeks\n        for k, v in abjad.items():\n            if v == indeks_hasil:\n                pesan_terdekripsi += k\n                break\n\n        # Pindah ke karakter berikutnya dalam kunci\n        indeks_kunci += 1\n    else:\n        # Jika karakter bukan alfabet, tambahkan tanpa perubahan\n        pesan_terdekripsi += huruf\nCETAK HASIL DEKRIPSI : \nhasil_decrypt = ', '.join(f\"'{char}'\" for char in pesan_terdekripsi)\nprint(f\"Ciphertext    : {hasil_encrypt}\")\nprint(\"\")\nprint(f\"Kunci         : {kunci_per_huruf}\")\nprint(\"\")\nprint(f\"Hasil Decrypt : {hasil_decrypt}\")\nCiphertext    : 'F', 'I', 'H', 'Y', 'Z', 'R', '2', '4'\nKunci         : 'K', 'E', 'Y', 'K', 'E', 'Y', 'K', 'E'\nHasil Decrypt : 'U', 'D', 'I', 'N', 'U', 'S', '2', '4'",
    "crumbs": [
      "Kriptografi Klasik",
      "3. Vigenere Cipher"
    ]
  },
  {
    "objectID": "4_playfair.html#penjelasan-prosesnya",
    "href": "4_playfair.html#penjelasan-prosesnya",
    "title": "4. Playfair",
    "section": "Penjelasan prosesnya:",
    "text": "Penjelasan prosesnya:\nMenghitung jumlah baris untuk memuat teks dalam matriks\nif temp - bulat == 0:\n    baris = bulat\nelse:\n    if temp - bulat &lt; 0:\n        baris = bulat\n    else:\n        baris = bulat + 1\nprint(baris)\nFor More Detail :\n\ntemp : hasil pembagian panjang teks dengan jumlah kolom\nbulat: hasil pembagian yang dibulatkan ke bilangan bulat terdekat. Jika temp adalah bilangan bulat (tidak ada sisa), jumlah baris adalah bulat. Jika ada sisa, jumlah baris adalah bulat + 1\n\nMengisi matriks dengan karakter dari teks yang telah dibersihkan (cleanPlainTeks)\nfor i in range(baris):\n    row = []\n    for j in range(kolom):\n        if i * kolom + j &lt; len(cleanPlainTeks):\n            elemen = cleanPlainTeks[i * kolom + j]\n        else:\n            elemen = \" \"\n        row.append(elemen)\n    matrix.append(row)\nFor More Detail :\n\nfor i in range(baris) : Loop untuk setiap baris dalam matriks\nrow = [] : Inisialisasi list kosong untuk setiap baris\nif i * kolom + j &lt; len(cleanPlainTeks) : Memeriksa apakah indeks saat ini berada dalam rentang panjang teks yang dibersihkan.\nelemen = cleanPlainTeks[i * kolom + j] : Jika indeks berada dalam rentang, maka ambil karakter dari cleanPlainTeks berdasarkan indeks yang dihitung.\nelse : Jika indeks melebihi panjang teks, isi elemen dengan spasi.\nrow.append(elemen) : Menambahkan elemen ke dalam baris.\nmatrix.append(row) : Menambahkan baris yang telah diisi ke dalam matriks.`\n\nMencetak matriks\nprint(\"Matriks yang Anda buat:\")\nfor row in matrix:\n    print(row)\nMentransposisikan matriks yang telah dibuat dan kemudian mencetak matriks yang telah ditransposisikan\ntransposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\nfor row in transposed_matrix:\n    print(row)\nFor More Detail :\n\nfor i in range(len(matrix[0])) : Iterasi melalui indeks kolom matriks asli\nrow[i] for row in matrix : Untuk setiap indeks kolom i, ambil elemen i dari setiap baris dalam matriks asli dan akan menghasilkan kolom baru dari elemen-elemen tersebut, membentuk baris baru di matriks yang ditransposisikan\n\nMembuat list kosong dengan panjang yang sama dengan cleanKey untuk menyimpan urutan indeks\norder = [None] * len(cleanKey)\nMengurutkan elemen-elemen dalam cleanKey berdasarkan nilai terkecil hingga terbesar\ni = 0\nwhile len(cleanKey) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, cleanKey))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = cleanKey.index(nilai_terkecil)\n\n        order[marker] = i\n        cleanKey[marker] = None \n        i = i + 1\n    else:\n        break\nprint(order)\nFor More Detail :\n\ni = 0 : Inisialisasi counter i\nwhile len(cleanKey) &gt; 0 : Loop hingga cleanKey kosong (semua elemen None)\nnon_none_values = list(filter(lambda x: x is not None, cleanKey)) : Membuat list yang hanya berisi elemen-elemen cleanKey yang bukan None\nif non_none_values : Mengecek apakah list non_none_values tidak kosong nilai_terkecil = min(non_none_values) : Mencari nilai terkecil dari non_none_values\nmarker = cleanKey.index(nilai_terkecil) : Mendapatkan indeks dari nilai terkecil dalam cleanKey Menyimpan Urutan dan Menghapus Nilai Terkecil:\norder[marker] = i : Menyimpan urutan i pada indeks marker di list order\ncleanKey[marker] = None : Menghapus nilai terkecil dari cleanKey dengan mengubahnya menjadi None\ni = i + 1 : Increment counter i.\n\nMengubah urutan kolom matriks transposed_matrix berdasarkan urutan yang telah diatur dalam order, dan kemudian mencetak matriks yang sudah diubah urutan kolomnya\nnew_matrix = []\nwhile len(order) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, order))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = order.index(nilai_terkecil)\n       \n        new_matrix.append(transposed_matrix[marker])\n        order[marker] = None\n    else:\n        break\n\nfor row in new_matrix:\n    print(row)\nFor More Detail :\n\nnew_matrix = [] : Membuat list kosong new_matrix untuk menampung baris-baris matriks yang baru diurutkan Looping untuk Mengubah Urutan Kolom:\nwhile len(order) &gt; 0 : Melakukan looping selama masih ada elemen yang tersisa dalam order\nnon_none_values = list(filter(lambda x: x is not None, order)) : Membuat list non_none_values yang hanya berisi nilai-nilai yang bukan None dari order\nif non_none_values : Memeriksa apakah non_none_values tidak kosong\nnilai_terkecil = min(non_none_values) : Menemukan nilai terkecil dari non_none_values\nmarker = order.index(nilai_terkecil) : Mencari indeks dari nilai_terkecil dalam order\nnew_matrix.append(transposed_matrix[marker]) : Menambahkan baris dari transposed_matrix yang sesuai dengan marker ke new_matrix\norder[marker] = None : Menghapus nilai yang telah diproses dengan mengubahnya menjadi None\nelse: break : Menghentikan loop jika non_none_values kosong, yang berarti semua nilai dalam order telah diproses\n\nMengonversi matriks new_matrix menjadi string tunggal dengan menggabungkan nilai-nilainya secara berurutan dan menghapus spasi ekstra di akhir string\nresult_string = \"\"\n\nfor row in new_matrix:\n    for value in row:\n        result_string += str(value)\n\nresult_string = result_string.strip()\n\nprint(result_string)\nFor More Detail :\n\nresult_string = \"\" : Inisialisasi string kosong result_string yang akan digunakan untuk menyimpan hasil akhir\nfor row in new_matrix: : Melakukan iterasi melalui setiap baris dalam new_matrix\nfor value in row: : Melakukan iterasi melalui setiap nilai dalam baris row\nresult_string += str(value) : Mengonversi nilai value menjadi string (jika belum string) dan menambahkannya ke result_string\nresult_string = result_string.strip() : Menghapus spasi ekstra di awal dan akhir string menggunakan metode strip()\n\nHasil Ciphertext : ENTKFINOKKM TIAIRA\n\nProses Dekripsi\ncipherTeks = input(\"masukkan kata : \")\nkey = input(\"masukkan kunci : \")\ncleanCipherTeks = cipherTeks.replace(\" \", \" \")\nprint(cleanCipherTeks)\nkolom = 0\nangka_urutan = []\nfor huruf in key:\n    if huruf.isalpha():\n        angka_urutan.append(ascii[huruf.lower()])\n        kolom = kolom+1\n        cleanKey = angka_urutan\n\nprint(f\"Urutan kunci dari kata '{key}' adalah: {angka_urutan}\")\nmatrix = []\npanjang = len(cleanCipherTeks)\ntemp = panjang/kolom\nbaris = round(temp)\nprint(baris)\nfor i in range(baris):\n    row = []\n    for j in range(kolom):\n        if i * kolom + j &lt; len(cleanCipherTeks):\n            elemen = cleanCipherTeks[i + baris * j]\n        else:\n            elemen = \"a\"\n        row.append(elemen)\n    matrix.append(row)\nprint(\"Matriks yang Anda buat:\")\nfor row in matrix:\n    print(row)\ntransposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\nfor row in transposed_matrix:\n    print(row)\norder = [None] * len(cleanKey)\ni = 0\nwhile len(cleanKey) &gt; 0:\n    non_none_values = list(filter(lambda x: x is not None, cleanKey))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        marker = cleanKey.index(nilai_terkecil)\n        order[marker] = i\n        cleanKey[marker] = None  \n        i = i + 1\n    else:\n        break\nprint(order)\ntransposed_matrix = [transposed_matrix[i] for i in order]\n\nfor row in transposed_matrix:\n    print(row)\nmatriks = [[row[i] for row in transposed_matrix] for i in range(len(transposed_matrix[0]))]\nfor row in matriks:\n    print(row)\nresult_string = \"\"\n\nfor row in matriks:\n    for value in row:\n        result_string += str(value)\n\nresult_string = result_string.strip()\n\nprint(result_string)\nHasil Dekripsi : TEKNIKINFORMATIKA\nPerbedaan Proses :\n\nEnkripsi: Teks asli diubah menjadi matriks berdasarkan kolom kunci, kemudian kolom-kolom diurutkan berdasarkan kunci. Pada enkripsi, transposed_matrix adalah matriks transposisi dari matrix awal\nDekripsi: Teks sandi diubah menjadi matriks berdasarkan kolom kunci, kemudian baris-baris diurutkan berdasarkan kunci untuk mengembalikan teks asli. Pada dekripsi, transposed_matrix diurutkan berdasarkan order untuk mengembalikan teks asli",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Playfair"
    ]
  },
  {
    "objectID": "4_playfair.html#pemrosesan-kunci",
    "href": "4_playfair.html#pemrosesan-kunci",
    "title": "4. Playfair",
    "section": "Pemrosesan Kunci",
    "text": "Pemrosesan Kunci\nMenghilangkan spasi pada kunci dan membuat kunci menjadi lowercase\nkey_playfair = key_playfair.replace(' ','').lower()\nprint(key_playfair)\nMenghapus huruf ‘j’ jika ada di kunci\nkey_playfair = key_playfair.replace('j', '')\nprint(key_playfair)\nMenghapus huruf yang berulang\nkey_result = []\nfor i in key_playfair:\n  if i not in key_result:\n    key_result.append(i)\nprint(key_result)\nperulangan untuk menghapus huruf yang berulang dengan menambahkan kondisi apakah huruf tersebut sudah ditambahkan ke list key_result\nMenambahkan sisa huruf alphabet yang belum ada ke dalam matrix kunci\nfor i in abjad:\n  if i != 'j' and i not in key_result:\n    key_result.append(i)\nprint(key_result)\nMembuat matrix kunci 5x5\nkey_created = []\nwhile key_result!= []:\n  key_created.append(key_result[:5])\n  key_result = key_result[5:]\nfor row in key_created:\n        print(row)",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Playfair"
    ]
  },
  {
    "objectID": "4_playfair.html#proses-enkripsi",
    "href": "4_playfair.html#proses-enkripsi",
    "title": "4. Playfair",
    "section": "Proses Enkripsi",
    "text": "Proses Enkripsi\nMengganti huruf ‘j’ yang ada di plainteks menjadi huruf ‘i’\nplaintext_playfair = plaintext_playfair.replace('j', 'i')\nprint(plaintext_playfair)\nProses pembuatan plaintext menjadi bentuk bigram atau pasangan huruf\nbigram_plaintext = []\n# perulangan untuk menambahkan pasangan huruf atau bigram ke dalam list bigram_plaintext\ni = 0\nwhile i&lt;len(plaintext_playfair):\n  x = plaintext_playfair[i]\n  y = ''\n\n  # situasi jika berada di huruf terakhir di plaintext\n  if((i+1) == len(plaintext_playfair)):\n    y = 'z'\n  else:\n    y = plaintext_playfair[i+1]\n\n  # jika hurufnya keduanya sama, maka disisipkan z di tengahnya\n  if(x!=y):\n    bigram_plaintext.append(x+y)\n    i += 2\n  else:\n    bigram_plaintext.append(x+'z')\n    i += 1\nprint(bigram_plaintext)\nPenjelasan prosesnya:\n\nbigram_plaintext = [] adalah sebuah list kosong yang akan diisi dengan pasangan huruf (bigram) yang diambil dari plaintext_playfair.\nwhile loop digunakan untuk iterasi melalui teks plaintext_playfair sampai semua huruf di teks tersebut telah diproses. Loop ini akan berlanjut selama i kurang dari panjang teks plaintext_playfair. Jadi perulangan ini digunakan untuk memproses semua huruf yang ada di plaintext_playfair.\nx = plaintext_playfair[i] dan y = '' adalah variabel yang digunakan untuk menampung huruf bigram pertama dan kedua dengan inisiasi nilai awal itu nilai dari plaintext_playfair[i] dan string kosong.\nSelanjutnya untuk pengkondisian pertama itu digunakan untuk kondisi dimana sudah sampai huruf terkahir dalam plaintext_playfair.\nTerakhir untuk pengkondisian kedua itu digunakan untuk kondisi dimana kedua hurufnya itu sama.\n\nProses substitusi plainteks dengan 3 aturan yang sudah di jelaskan diatas\nbigram_ciphertext = []\n# perulangan untuk mencari bigram ciphertex\nfor bigram in bigram_plaintext:\n  flag = False\n  # cek aturan 1, apakah pasangan huruf plaintext berada di baris yang sama\n  for row in key_created:\n    # jika berada di baris yang sama maka huruf yang berada di sebelah kanannya ditambahkan ke bigram ciphertext\n    if(bigram[0] in row and bigram[1] in row):\n      x1 = row.index(bigram[0])\n      x2 = row.index(bigram[1])\n      cipher_created = row[(x1 + 1) % 5] + row[(x2 + 1) % 5]\n      bigram_ciphertext.append(cipher_created)\n      flag = True\n  if flag:\n    continue\n\n  # cek aturan 2, apakah pasangan huruf plaintext berada di kolom yang sama\n  for j in range(5):\n    col = ''.join([key_created[i][j] for i in range(5)])\n    # jika berada di kolom yang sama maka huruf yang berada di bawahnya ditambahkan ke bigram ciphertext\n    if(bigram[0] in col and bigram[1] in col):\n      y1 = col.index(bigram[0])\n      y2 = col.index(bigram[1])\n      cipher_created = col[(y1 + 1) % 5] + col[(y2 + 1) % 5]\n      bigram_ciphertext.append(cipher_created)\n      flag = True\n  if flag:\n    continue\n\n  foundOne = False\n  foundTwo = False\n\n  # cek aturan 3, apakah pasangan huruf plaintext berada di baris dan kolom yang berbeda\n  for i in range(5):\n    row = key_created[i]\n    # jika huruf pertama dalam bigram ada pada baris urutan ke 'i'\n    if(bigram[0] in row):\n      x1 = i\n      y1 = row.index(bigram[0])\n      foundOne = True\n    # jika huruf kedua dalam bigram ada pada baris urutan ke 'i'\n    if(bigram[1] in row):\n      x2 = i\n      y2 = row.index(bigram[1])\n      foundTwo = True\n    # jika kedua posisi pasangan huruf atau bigram sudah diketahui, maka pembentukan cipher sesuai aturan ketiga dilakukan\n    if foundOne and foundTwo:\n      cipher_created = key_created[x1][y2] + key_created[x2][y1]\n      bigram_ciphertext.append(cipher_created)\n      break\nprint(bigram_ciphertext)\nPenjelasan prosesnya:\n\nbigram_ciphertext adalah list kosong yang akan diisi dengan pasangan huruf (bigram) yang telah dienkripsi dari bigram_plaintext.\nfor bigram in bigram_plaintext: digunakan untuk iterasi melalui setiap bigram yang ada dalam bigram_plaintext.\nflag = False adalah variabel boolean yang digunakan untuk menandai apakah aturan tertentu sudah dipenuhi sehingga tidak perlu memeriksa aturan lainnya untuk bigram yang sama.\nPemeriksaan Aturan 1: Baris yang Sama\n\nfor row in key_created:\n    if(bigram[0] in row and bigram[1] in row):\n        x1 = row.index(bigram[0])\n        x2 = row.index(bigram[1])\n        cipher_created = row[(x1 + 1) % 5] + row[(x2 + 1) % 5]\n        bigram_ciphertext.append(cipher_created)\n        flag = True\n\nLoop ini memeriksa setiap baris (row) dalam matriks kunci (key_created).\nJika kedua huruf dalam bigram (bigram[0] dan bigram[1]) berada di baris yang sama (row), maka:\n\nIndeks masing-masing huruf dalam baris ditemukan (x1 dan x2).\nHuruf di sebelah kanan dari masing-masing huruf ditentukan dengan menggunakan (index + 1) % 5 untuk menangani kasus melingkar (huruf di ujung kanan).\nHuruf-huruf ini kemudian digabungkan menjadi cipher_created dan ditambahkan ke bigram_ciphertext.\nflag diatur ke True untuk menandai bahwa aturan ini telah diterapkan, dan loop berhenti memeriksa aturan lain untuk bigram ini.\n\nLanjut ke Bigram Berikutnya Jika Aturan 1 Terpenuhi\n\nif flag:\n    continue\n\nJika flag True, bigram ini sudah diproses, dan loop lanjut ke bigram berikutnya tanpa memeriksa aturan lainnya.\nPemeriksaan Aturan 2: Kolom yang Sama\n\nfor j in range(5):\n    col = ''.join([key_created[i][j] for i in range(5)])\n    if(bigram[0] in col and bigram[1] in col):\n        y1 = col.index(bigram[0])\n        y2 = col.index(bigram[1])\n        cipher_created = col[(y1 + 1) % 5] + col[(y2 + 1) % 5]\n        bigram_ciphertext.append(cipher_created)\n        flag = True\n\nLoop ini memeriksa setiap kolom dalam matriks kunci (key_created).\nSetiap kolom (col) dibentuk dengan menggabungkan huruf-huruf dari setiap baris pada indeks j.\nJika kedua huruf dalam bigram (bigram[0] dan bigram[1]) berada di kolom yang sama (col), maka:\n\nIndeks masing-masing huruf dalam kolom ditemukan (y1 dan y2).\nHuruf di bawah masing-masing huruf ditentukan dengan menggunakan (index + 1) % 5 untuk menangani kasus melingkar (huruf di ujung bawah).\nHuruf-huruf ini kemudian digabungkan menjadi cipher_created dan ditambahkan ke bigram_ciphertext.\nflag diatur ke True, dan loop berhenti memeriksa aturan lain untuk bigram ini.\n\nLanjut ke Bigram Berikutnya Jika Aturan 2 Terpenuhi\n\nif flag:\n    continue\n\nJika flag True, bigram ini sudah diproses, dan loop lanjut ke bigram berikutnya tanpa memeriksa aturan lainnya.\nPemeriksaan Aturan 3: Baris dan Kolom Berbeda\n\nfoundOne = False\nfoundTwo = False\n\nfor i in range(5):\n    row = key_created[i]\n    if(bigram[0] in row):\n        x1 = i\n        y1 = row.index(bigram[0])\n        foundOne = True\n    if(bigram[1] in row):\n        x2 = i\n        y2 = row.index(bigram[1])\n        foundTwo = True\n    if foundOne and foundTwo:\n        cipher_created = key_created[x1][y2] + key_created[x2][y1]\n        bigram_ciphertext.append(cipher_created)\n        break\n\nLoop ini memeriksa setiap baris dalam matriks kunci (key_created) untuk menemukan posisi huruf pertama dan kedua dari bigram.\nJika huruf pertama (bigram[0]) ditemukan dalam baris i, indeks baris (x1) dan kolom (y1) disimpan, dan foundOne diatur ke True.\nJika huruf kedua (bigram[1]) ditemukan dalam baris i, indeks baris (x2) dan kolom (y2) disimpan, dan foundTwo diatur ke True.\nJika kedua huruf ditemukan (foundOne dan foundTwo), aturan ketiga diterapkan:\n\nHuruf di posisi silang yang berlawanan diambil dari matriks kunci: key_created[x1][y2] dan key_created[x2][y1].\nHuruf-huruf ini digabungkan menjadi cipher_created dan ditambahkan ke bigram_ciphertext.\nLoop dihentikan dengan break karena bigram telah diproses.\n\n\nHasil enkripsi\nhasil_enkripsi = ''.join(bigram_ciphertext)\nprint(hasil_enkripsi)",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Playfair"
    ]
  },
  {
    "objectID": "4_playfair.html#proses-dekripsi",
    "href": "4_playfair.html#proses-dekripsi",
    "title": "4. Playfair",
    "section": "Proses Dekripsi",
    "text": "Proses Dekripsi\nMemasukkan ciphertext\nciphertext_playfair = input(\"Masukkan teks yang akan di dekripsi: \")\nProses pembuatan ciphertext menjadi bentuk bigram atau pasangan huruf\nbigram_ciphertext = [ciphertext_playfair[i:i+2] for i in range(0, len(ciphertext_playfair), 2)]\nprint(bigram_ciphertext)\nProses substitusi Cipherteks dengan 3 aturan yang sudah di jelaskan diatas\nbigram_dekripsi = []\n# perulangan untuk mencari bigram decrypt text\nfor bigram in bigram_ciphertext:\n  flag = False\n  # cek aturan 1, apakah pasangan huruf ciphertext berada di baris yang sama\n  for row in key_created:\n    # jika berada di baris yang sama maka huruf yang berada di sebelah kanannya ditambahkan ke bigram decrypt text\n    if(bigram[0] in row and bigram[1] in row):\n      x1 = row.index(bigram[0])\n      x2 = row.index(bigram[1])\n      decrypt_created = row[(x1 - 1) % 5] + row[(x2 - 1) % 5]\n      bigram_dekripsi.append(decrypt_created)\n      flag = True\n  if flag:\n    continue\n\n  # cek aturan 2, apakah pasangan huruf ciphertext berada di kolom yang sama\n  for j in range(5):\n    col = ''.join([key_created[i][j] for i in range(5)])\n    # jika berada di kolom yang sama maka huruf yang berada di bawahnya ditambahkan ke bigram decrypt text\n    if(bigram[0] in col and bigram[1] in col):\n      y1 = col.index(bigram[0])\n      y2 = col.index(bigram[1])\n      decrypt_created = col[(y1 - 1) % 5] + col[(y2 - 1) % 5]\n      bigram_dekripsi.append(decrypt_created)\n      flag = True\n  if flag:\n    continue\n\n  foundOne = False\n  foundTwo = False\n\n  # cek aturan 3, apakah pasangan huruf ciphertext berada di baris dan kolom yang berbeda\n  for i in range(5):\n    row = key_created[i]\n    # jika huruf pertama dalam bigram ada pada baris urutan ke 'i'\n    if(bigram[0] in row):\n      x1 = i\n      y1 = row.index(bigram[0])\n      foundOne = True\n    # jika huruf kedua dalam bigram ada pada baris urutan ke 'i'\n    if(bigram[1] in row):\n      x2 = i\n      y2 = row.index(bigram[1])\n      foundTwo = True\n    # jika kedua posisi pasangan huruf atau bigram sudah diketahui, maka pembentukan cipher sesuai aturan ketiga dilakukan\n    if foundOne and foundTwo:\n      decrypt_created = key_created[x1][y2] + key_created[x2][y1]\n      bigram_dekripsi.append(decrypt_created)\n      break\nprint(bigram_dekripsi)\nHasil dekripsi\nhasil_dekripsi = ''.join(bigram_dekripsi)\nprint(hasil_dekripsi)",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Playfair"
    ]
  },
  {
    "objectID": "6_transposisi_myzkowski.html",
    "href": "6_transposisi_myzkowski.html",
    "title": "6. Transposisi Myzkowski",
    "section": "",
    "text": "Cara Kerja\nMisalkan kita memiliki teks “TENTUKAN PRIORITAS ANDA SEBAB KITA TIDAK DAPAT MENGERJAKAN SEMUANYA X” dengan kunci “BOROBUDUR”, maka proses pengenkripsiannya adalah sebagai berikut",
    "crumbs": [
      "Kriptografi Klasik",
      "6. Transposisi Myzkowski"
    ]
  },
  {
    "objectID": "6_transposisi_myzkowski.html#tipe-data",
    "href": "6_transposisi_myzkowski.html#tipe-data",
    "title": "6. Transposisi Myzkowski",
    "section": "Tipe Data",
    "text": "Tipe Data\nTipe Data dalam ilmu komputer erat kaitannya dengan pemrgoraman dan database. Didalam pemrograman tipe data biasa digunakan untuk mendefinisikan (menetapkan) isi dari sebuah variabel.\nPerbedaannya dalam database, tipe data ini digunakan untuk menentukan isi dari sebuah data yang akan disimpan.\nTipe data ini berbeda-beda tergantung dari bahasa pemgrograman atau jenis database yang kita gunakan.\nTipe data ini akan dikelompokan menjadi 5 bagian utama. Pada tipe data dalam MySQL dibagi menjadi 3, yaitu :\n\nTipe Data Numerik,\nTipe Data String, dan\nTipe Data Date/Time.\n\n\nTipe Data Numerik\nAdalah tipe data numerik untuk mengukur nilai secara matematik, misalnya mata uang, angka desimal, dll.\n\n\nTabel Tipe Data Numerik\n\n\n\n\n\n\n\n\nNo\nTipe\nKeterangan\nPenerapan\n\n\n\n\n1.\nINTEGER(size)\nTipe data yang berisi kumpulan bilangan bulat, baik dalam bentuk bilangan positif maupun negatif\nAngka secara umum\n\n\n2.\nFLOAT(size)\nBilangan desimal dengan presisi tunggal (single-precision)\nπ, desimal dengan fokus pada nilai input contoh : 3.14159265359\n\n\n3.\nDOUBLE(size, d)\nBilangan desimal dengan presisi ganda (double-precision). Jumlah total digit ditentukan oleh size, jumlah digit setelah titik decimal ditentukan oleh d\nUang, dengan fokus jumlah desimal 2 angka di belakang koma  contoh: 2.500,00\n\n\n\n\n\n\nTipe Data String\nMerupakan suatu teks dengan panjang variabel dimana setiap huruf dapat memiliki ukuran lebih kecil atau besar daripada satuan lainnya. Misalkan nama depan, nama belakang, alamat, nomor telepon, website, serta informasi lainnya.\n\n\nTabel Tipe Data String\n\n\n\n\n\n\n\n\nNo\nTipe\nKeterangan\nPenerapan\n\n\n\n\n1.\nCHAR(size)\nMenyatakan deretan karakter (String) yang lebarnya tetap.  Size : 0 hingga 255 karakter\nJenis_kelamin (L/P)  contoh : L\n\n\n2.\nVARCHAR(size)\nMenyatakan data String yang lebarnya bervariasi.  Size : 0 hingga 255 karakter\nNama pengguna  contoh : Amanda\n\n\n3.\nTEXT(size, d)\nMenampung string Panjang yang lebarnya tidak dapat diprediksi.\n\n\n\n\n\n\n\nTipe Data Date\nMenyimpan tanggal dan waktu dalam format tertentu seperti tahun, bulan, dan hari, jam, menit, dan detik. Tipe data date bisa digunakan untuk mengatur kronologis dari peristiwa.\n\n\nTabel Tipe Data Date\n\n\n\n\n\n\n\n\nNo\nTipe\nKeterangan\nPenerapan\n\n\n\n\n1.\nDATE(size)\nDigunakan dengan tanggal dengan format “YYYY-MM-DD”\n2004-09-21\n\n\n2.\nTIME(size)\nDigunakan untuk waktu dengan format “hh:mm:ss”\n12:33:12\n\n\n3.\nDATETIME(size, d)\nDigunakan untuk tanggal dan waktu dengan format “YYYY-MM-DD hh:mm:ss”\n2012-11-29 11:55:23",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Transposisi Myzkowski"
    ]
  },
  {
    "objectID": "6_transposisi_myzkowski.html#constraint-kekangan-nilai",
    "href": "6_transposisi_myzkowski.html#constraint-kekangan-nilai",
    "title": "6. Transposisi Myzkowski",
    "section": "Constraint / Kekangan Nilai",
    "text": "Constraint / Kekangan Nilai\nConstraint atau kekangan nilai digunakan untuk menentukan aturan yang mengizinkan atau membatasi nilai yang akan dimasukkan dalam tabel. Kekangan Nilai Menyediakan Metode Yang sesuai untuk memastikan akurasi dan integritas data di dalam table.\nContoh constraint, yaitu :\n\nMembuat Nilai Tidak Kosong(NOT NULL)\nMembuat Nilai Unik(UNIQUE)\nMembuat kenaikan nilai secara otomatis(AUTO INCREMENT)\nMembuat Kunci tamu(FOREIGN KEY)\nMenggunakan Alias table dan query antartable (INNER JOIN)\n\n\nConstraint NOT NULL\nConstraint NOT NULL mengatur agar data tertentu harus terisi atau tidak kosong. Ada kolom tertentu dari suatu table harus terisi dengan nilai valid. Contoh case :\nCREATE TABLE `mahasiswa`(\n    `nama` VARCHAR(50), NOT NULL,\n    `nim` VARCHAR(30) NOT NULL  \n)\nUntuk case di atas maka nama dan nim yang diinputkan ke dalam database tidak boleh kosong.\n\n\nConstraint UNIQUE\nConstraint UNIQUE ditujukan untuk memastikan bahwa nilai dalam kolom unik, artinya kolom tidak dapat menyimpan nilai duplikat. Contoh case:\nCREATE TABLE `mahasiswa`(\n    `nama` VARCHAR(50) NOT NULL,\n    `nim` VARCHAR(50) NOT NULL UNIQUE\n)\nUntuk case di atas nama mahasiswa bisa saja sama, tapi NIM mahasiswa tidak akan pernah sama maka diberi Constraint UNIQUE\n\n\nConstraint AUTO INCREMENT\nAuto increment digunakan untuk menaikkan nilai secara otomatis pada field numerik. Ada beberapa hal yang harus diperhatikan dalam menggunakan auto increment:\n\nHanya Dapat Digunakan Pada field numerik\nField harus bersifat primary key atau unik\nField tidak boleh bersifat null\nDalam Satu Tabel hanya ada satu field yang menggunakan auto increment\n\nCREATE TABLE `mahasiswa`(\n    `id` VARCHAR(11) NOT NULL AUTO_INCREMENT,\n    `nama` VARCHAR(50) NOT NULL,\n    `nim` VARCHAR(50) NOT NULL UNIQUE\n)",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Transposisi Myzkowski"
    ]
  },
  {
    "objectID": "6_transposisi_myzkowski.html#pembuatan-database",
    "href": "6_transposisi_myzkowski.html#pembuatan-database",
    "title": "6. Transposisi Myzkowski",
    "section": "Pembuatan Database",
    "text": "Pembuatan Database\nDalam pembuatan database dapat dibuat dalam 2 cara, yaitu menggunakan platform dan menggunakan scripting\n\n\n\n\n\n\n\n\n\nMenggunakan Platform\n\n\n\n\n\n\n\nMenggunakan scripting",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Transposisi Myzkowski"
    ]
  },
  {
    "objectID": "6_transposisi_myzkowski.html#perintah-mysql-ddl-dml-dcl",
    "href": "6_transposisi_myzkowski.html#perintah-mysql-ddl-dml-dcl",
    "title": "6. Transposisi Myzkowski",
    "section": "Perintah MySQL (DDL, DML, DCL)",
    "text": "Perintah MySQL (DDL, DML, DCL)\nSecara umum perintah fungsi MySQL dibagi menjadi 3, yaitu :\n\nDDL (Data Definition Language),\nDML(Data Manipulation), dan\nDCL (Data Control Language).\n\nPada modul ini akan dibatasi pada DDL dan DML untuk praktek.\n\n\n\nDDL, DML, DCL\n\n\n\nData Definition Language (DDL)\nData Definition Language (DDL) adalah bagian dari SQL (Structured Query Language) yang digunakan untuk mendefinisikan struktur database dan objeknya, seperti tabel, tampilan, indeks, dan prosedur dalam sebuah database. Pernyataan DDL digunakan untuk membuat, mengubah, dan menghapus objek database, termasuk tabel, tampilan, indeks, dan prosedur tersimpan. Beberapa pernyataan DDL yang paling umum meliputi:\n\nCREATE\nPernyataan ini membuat objek database baru, seperti tabel, tampilan, atau indeks. Misalnya, pernyataan SQL berikut membuat tabel yang disebut “pelanggan”:\nCREATE TABLE pelanggan ( id INT PRIMARY KEY, name VARCHAR(255), address VARCHAR(255));\n\n\nALTER\nPernyataan ini digunakan untuk memodifikasi objek database yang sudah ada. Misalnya, pernyataan SQL berikut menambahkan kolom baru bernama ” email ” ke tabel ” customers “:\npelanggan ALTER TABLE ADD email VARCHAR(255);\n\n\nDROP\nPernyataan ini digunakan untuk menghapus objek database yang sudah ada. Misalnya, pernyataan SQL berikut menghapus tabel “pelanggan”:\npelanggan DROP TABLE;\n\n\nTRUNCATE\nPernyataan ini digunakan untuk menghapus semua baris dalam tabel, tetapi tidak seperti pernyataan DROP, pernyataan ini mempertahankan struktur dan indeks tabel. \n\n\nRENAME\nPernyataan ini digunakan untuk mengganti nama objek database yang sudah ada. Misalnya, pernyataan SQL berikut mengganti nama tabel “pelanggan” menjadi “klien”:\nRENAME TABLE pelanggan TO klien;\nPenting untuk dicatat bahwa pernyataan DDL dieksekusi segera dan bersifat permanen, artinya setelah objek dibuat, diubah, atau dihapus, perubahan tidak dapat diurungkan. Oleh karena itu, sangat penting untuk berhati-hati dan memastikan bahwa Anda memiliki cadangan basis data sebelum menjalankan pernyataan DDL apa pun. Selain itu, pernyataan DDL biasanya dijalankan oleh administrator database atau pengembang dengan hak istimewa dan izin yang sesuai untuk mengubah struktur database. \n\n\nSHOW\nPerintah DDL ini digunakan untuk menampilkan daftar database atau tabel yang ada.\nPenerapan :\nSHOW TABLES;\n\n\n\n\n\n\n\nLatihan DDL\n\n\n\n\nCreate Database Mahasiswa dan Table identitas \nCREATE DATABASE mahasiswa;\nCREATE TABLE identitas (`Nama` VARCHAR(250) NOT NULL PRIMARY KEY);\nAlter Table \nALTER TABLE identitas ADD NIM VARCHAR(15) UNIQUE\nRename Table \nRENAME TABLE identitas TO id_mahasiswa\nShow Table \nSHOW TABLES;\nDrop Table \nDROP TABLE id_mahasiswa\nCoba kreasikan Database kalian dengan perintah DDL! Buatlah Database kuliah berisi 2 table yaitu id_dosen dan id_mahasiswa Table id_dosen berisi kolom : nama, NIDN, Jabatan Table id_mahasiswa berisi kolom : nama, NIM, Prodi\n\n\n\n\n\n\nData Manipulation Language (DML)\nData Manipulation Language (DML) adalah bagian dari SQL (Structured Query Language) yang digunakan untuk memanipulasi data dalam database. Sehingga pernyataan DML ini dapat digunakan ketika database dan tabel telah dibuat. Pernyataan DML digunakan untuk menyisipkan, memperbarui, dan menghapus data dalam database. Beberapa pernyataan DML yang paling umum meliputi:\n\nINSERT\nPernyataan ini digunakan untuk memasukkan data baru ke dalam tabel. Sebagai ilustrasi, pernyataan SQL berikut menyisipkan baris baru ke dalam tabel “pelanggan”:\nINSERT INTO pelanggan (id, nama, alamat) VALUES (1, 'John Smith,' '123 Main St');\n\n\nSELECT\nPernyataan ini digunakan untuk mengambil data dari satu atau lebih tabel dalam database. Sebagai contoh, kueri SQL berikut mengambil semua rekaman dari tabel “pelanggan”:\nSELECT * FROM pelanggan;\n\n\nUPDATE\nPernyataan ini digunakan untuk memodifikasi data yang ada dalam sebuah tabel. Misalnya, pernyataan SQL berikut memperbarui alamat pelanggan dengan ID 1 di tabel “pelanggan”:\nUPDATE pelanggan SET address = '456 Park Ave' WHERE id = 1;\n\n\nDELETE\nPernyataan ini digunakan untuk menghapus data dari tabel. Misalnya, pernyataan SQL berikut menghapus pelanggan dengan ID 1 dari tabel “pelanggan”:\nDELETE FROM pelanggan WHERE id = 1;\n\n\n\n\n\n\nLatihan DML\n\n\n\nGunakan Database yang telah kalian kerjakan pada Latihan DDL sebelumnya!\n\nInsert Data\nINSERT INTO id_mahasiswa VALUES ('Amanda', 'A11.2020.54321',);\nSelect Data\nSELECT Nama, NIM FROM id_mahasiswa;\nUpdate Data\nUPDATE id_mahasiswa SET `Prodi`='Ilmu Komunikasi' WHERE `Prodi`='';\nDelete Data\nDELETE FROM id_mahasiswa WHERE `NIM`='A11.2020.54321';\nKreasikan database kalian dengan perintah dari DDL dan DML !\n\n\n\n\n\n\n\n\n\nKonsep Database\n\n\n\nBerikut merupakan penjelasan dari konsep database!",
    "crumbs": [
      "Kriptografi Klasik",
      "4. Transposisi Myzkowski"
    ]
  },
  {
    "objectID": "6_transposisi_myzkowski.html#pemrosesan-kunci",
    "href": "6_transposisi_myzkowski.html#pemrosesan-kunci",
    "title": "6. Transposisi Myzkowski",
    "section": "Pemrosesan Kunci",
    "text": "Pemrosesan Kunci\nMembuat urutan dari tiap huruf di kunci\nsortkey = []\nkolom = 0\n# Perulangan untuk menambahkan urutan huruf kunci ke list sortkey\nfor huruf in key_myzkowski:\n    # Periksa apakah karakter saat ini adalah huruf alfabet\n    if huruf.isalpha():\n        sortkey.append(abjad[huruf.lower()])\n        kolom = kolom+1\nprint(f\"Urutan kunci dari kata '{key_myzkowski}' adalah: {sortkey}\")\nMenghitung jumlah kemunculan tiap huruf di kunci\n# Membuat dictionary untuk melacak jumlah kemunculan setiap nilai\ncount_key = {}\nfor nilai in sortkey:\n    # Jika nilai sudah ada dalam dictionary, tambahkan 1 ke jumlahnya\n    if nilai in count_key:\n        count_key[nilai] += 1\n    # Jika nilai belum ada dalam dictionary, tambahkan ke dictionary dengan jumlah 1\n    else:\n        count_key[nilai] = 1\nprint(count_key)\nMembuat urutan kolom dalam kunci\nhasil_kunci = [None] * len(key_myzkowski)\ni = 0\nn = 1\nwhile i&lt;len(key_myzkowski):\n    non_none_values = list(filter(lambda x: x is not None, sortkey))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        if count_key[nilai_terkecil]&gt;1:\n            for j in range(count_key[nilai_terkecil]):\n                marker = sortkey.index(nilai_terkecil)\n                hasil_kunci[marker] = n\n                sortkey[marker] = None\n                nilai_terkecil = min(non_none_values)\n        else:\n          marker = sortkey.index(nilai_terkecil)\n          hasil_kunci[marker] = n\n          sortkey[marker] = None\n    else:\n        break\n    n+=1\n    i+=1\nprint(hasil_kunci)\nPenjelasan prosesnya - hasil_kunci adalah list yang panjangnya sama dengan key_myzkowski dan diisi dengan None. List ini akan diisi dengan nomor urut sesuai urutan karakter dalam key_myzkowski.\nwhile i &lt; len(key_myzkowski):\n    non_none_values = list(filter(lambda x: x is not None, sortkey))\n\nwhile i &lt; len(key_myzkowski): Loop ini akan berjalan hingga semua karakter dalam key_myzkowski diproses.\nnon_none_values: List yang berisi nilai dari sortkey yang tidak None. sortkey adalah list yang berisi urutan karakter key_myzkowski yang telah diurutkan. filter(lambda x: x is not None, sortkey) digunakan untuk mendapatkan nilai yang valid (bukan None).\n\nif non_none_values:\n    nilai_terkecil = min(non_none_values)\n\nJika non_none_values tidak kosong, berarti masih ada karakter yang perlu diproses.\nnilai_terkecil adalah nilai terkecil dalam non_none_values. Ini digunakan untuk menentukan urutan karakter yang akan diberi nomor.\n\nif count_key[nilai_terkecil] &gt; 1:\n    for j in range(count_key[nilai_terkecil]):\n        marker = sortkey.index(nilai_terkecil)\n        hasil_kunci[marker] = n\n        sortkey[marker] = None\n        nilai_terkecil = min(non_none_values)\n\nif count_key[nilai_terkecil] &gt; 1: Jika nilai_terkecil memiliki pengulangan (count_key[nilai_terkecil] adalah jumlah pengulangan karakter tersebut dalam key_myzkowski).\nfor j in range(count_key[nilai_terkecil]): Loop untuk memproses setiap pengulangan karakter.\nmarker = sortkey.index(nilai_terkecil): Temukan indeks dari nilai_terkecil di sortkey.\nhasil_kunci[marker] = n: Beri nomor urut n pada posisi yang sesuai di hasil_kunci.\nsortkey[marker] = None: Tandai posisi yang telah diproses dengan None agar tidak diproses lagi di iterasi berikutnya.\nnilai_terkecil = min(non_none_values): Update nilai_terkecil dengan nilai terkecil berikutnya dari non_none_values.\n\nelse:\n    marker = sortkey.index(nilai_terkecil)\n    hasil_kunci[marker] = n\n    sortkey[marker] = None\n\nJika nilai_terkecil tidak memiliki pengulangan (count_key[nilai_terkecil] adalah 1), cukup tandai posisi marker di hasil_kunci dengan n, dan ubah nilai di sortkey menjadi None.",
    "crumbs": [
      "Kriptografi Klasik",
      "6. Transposisi Myzkowski"
    ]
  },
  {
    "objectID": "6_transposisi_myzkowski.html#proses-enkripsi",
    "href": "6_transposisi_myzkowski.html#proses-enkripsi",
    "title": "6. Transposisi Myzkowski",
    "section": "Proses Enkripsi",
    "text": "Proses Enkripsi\nMembuat susunan plaintext sesuai dengan panjang kunci\n# membuat variabel list kosong\nenkripsi = []\n# perulangan untuk membagi plaintext menjadi potongan-potongan sepanjang panjang kunci dan menyimpan potongan-potongan tersebut ke dalam list\nfor i in range (0, len(plaintext_myzkowski), len(key_myzkowski)):\n    x = plaintext_myzkowski[i:i+len(key_myzkowski)]\n    x = list(x)\n    enkripsi.append(x)\n# perulangan untuk menambahkan # ke dalam list enkripsi index terakhir jika panjangnya kurang dari panjang kunci\nwhile len(enkripsi[len(enkripsi)-1])&lt;len(key_myzkowski):\n    enkripsi[len(enkripsi)-1].append(\" \")\nprint(hasil_kunci)\nfor row in enkripsi:\n        print(row)\nMenghitung jumlah kemunculan tiap angka dalam kunci\n# Membuat dictionary untuk melacak jumlah kemunculan setiap nilai\ncount_hasil_kunci = {}\n# Loop melalui setiap nilai dalam list\nfor nilai in hasil_kunci:\n    # Jika nilai sudah ada dalam dictionary, tambahkan 1 ke jumlahnya\n    if nilai in count_hasil_kunci:\n        count_hasil_kunci[nilai] += 1\n    # Jika nilai belum ada dalam dictionary, tambahkan ke dictionary dengan jumlah 1\n    else:\n        count_hasil_kunci[nilai] = 1\n# Cetak dictionary yang berisi jumlah kemunculan setiap nilai\nprint(count_hasil_kunci)\nProses pengenkripsian susuna plainteks\nhasil_enkripsi = []\n# perulangan untuk menentukan hasil enkripsi\ni = 0\nwhile i &lt; len(key_myzkowski):\n    non_none_values = list(filter(lambda x: x is not None, hasil_kunci))\n    if non_none_values:\n        nilai_terkecil = min(non_none_values)\n        if count_hasil_kunci[nilai_terkecil] == 1:\n            marker = hasil_kunci.index(nilai_terkecil)\n            for j in range(len(enkripsi)):\n                hasil_enkripsi.append(enkripsi[j][marker])\n            hasil_kunci[marker] = None\n        else:\n            temp = []\n            for k in range(i, count_hasil_kunci[nilai_terkecil] + i):\n                marker = hasil_kunci.index(nilai_terkecil)\n                temp.append(marker)\n                hasil_kunci[marker] = None\n                nilai_terkecil = min(non_none_values)\n            for j in range(len(enkripsi)):\n                for indeks in temp:\n                    hasil_enkripsi.append(enkripsi[j][indeks])\n    i += 1\nhasil_enkripsi = ''.join(hasil_enkripsi)\nprint(\"Hasil Enkripsi = \", hasil_enkripsi)\nPenjelasan prosesnya:\nwhile i &lt; len(key_myzkowski):\n    non_none_values = list(filter(lambda x: x is not None, hasil_kunci))\n\nwhile i &lt; len(key_myzkowski): Loop ini berjalan selama i kurang dari panjang key_myzkowski.\nnon_none_values: List ini berisi nilai-nilai dari hasil_kunci yang bukan None, yang menandakan kolom yang belum diproses.\n\nif count_hasil_kunci[nilai_terkecil] == 1:\n    marker = hasil_kunci.index(nilai_terkecil)\n    for j in range(len(enkripsi)):\n        hasil_enkripsi.append(enkripsi[j][marker])\n    hasil_kunci[marker] = None\n\nif count_hasil_kunci[nilai_terkecil] == 1: Jika nilai_terkecil hanya muncul sekali (tidak ada pengulangan).\nmarker = hasil_kunci.index(nilai_terkecil): Temukan indeks dari nilai_terkecil di hasil_kunci.\nfor j in range(len(enkripsi)): Loop melalui setiap baris dalam matriks enkripsi.\nhasil_enkripsi.append(enkripsi[j][marker]): Tambahkan karakter di kolom marker dari setiap baris ke hasil_enkripsi.\nhasil_kunci[marker] = None: Tandai kolom ini sebagai sudah diproses dengan mengubah nilai di hasil_kunci menjadi None.\n\nelse:\n    temp = []\n    for k in range(i, count_hasil_kunci[nilai_terkecil] + i):\n        marker = hasil_kunci.index(nilai_terkecil)\n        temp.append(marker)\n        hasil_kunci[marker] = None\n        nilai_terkecil = min(non_none_values)\n    for j in range(len(enkripsi)):\n        for indeks in temp:\n            hasil_enkripsi.append(enkripsi[j][indeks])\n\nelse: Jika nilai_terkecil muncul lebih dari sekali.\ntemp = []: List sementara untuk menyimpan indeks kolom yang akan diproses.\nfor k in range(i, count_hasil_kunci[nilai_terkecil] + i): Loop untuk menambahkan semua indeks kolom yang memiliki nilai nilai_terkecil ke temp.\nmarker = hasil_kunci.index(nilai_terkecil): Temukan indeks dari nilai_terkecil di hasil_kunci.\ntemp.append(marker): Tambahkan indeks marker ke temp.\nhasil_kunci[marker] = None: Tandai kolom ini sebagai sudah diproses dengan mengubah nilai di hasil_kunci menjadi None.\nnilai_terkecil = min(non_none_values): Update nilai_terkecil dengan nilai terkecil berikutnya dari non_none_values.\nfor j in range(len(enkripsi)): Loop melalui setiap baris dalam matriks enkripsi.\nfor indeks in temp: Loop melalui setiap indeks yang disimpan di temp.\nhasil_enkripsi.append(enkripsi[j][indeks]): Tambahkan karakter di kolom indeks dari setiap baris ke hasil_enkripsi.\n\nhasil_enkripsi = ''.join(hasil_enkripsi)\nprint(\"Hasil Enkripsi = \", hasil_enkripsi)\n\nhasil_enkripsi = ''.join(hasil_enkripsi): Gabungkan semua karakter di hasil_enkripsi menjadi satu string.\nprint(\"Hasil Enkripsi = \", hasil_enkripsi): Cetak hasil enkripsi.",
    "crumbs": [
      "Kriptografi Klasik",
      "6. Transposisi Myzkowski"
    ]
  },
  {
    "objectID": "6_transposisi_myzkowski.html#proses-dekripsi",
    "href": "6_transposisi_myzkowski.html#proses-dekripsi",
    "title": "6. Transposisi Myzkowski",
    "section": "Proses Dekripsi",
    "text": "Proses Dekripsi\nMemasukkan cipherteks\nchipertext_myzkowski = input(\"Masukkan teks yang ingin dienkripsi: \")\nProses membuat list yang berisi kunci dan nomor urut hurufnya\n# membuat variabel list kosong\ndekripsi = []\nkey_myzkowski = list(key_myzkowski)\n# menambahkan kunci ke dalam list dekripsi\ndekripsi.append(key_myzkowski)\n# menambahkan list kosong yang akan berisi nomor urutan dari tiap abjad kunci\ndekripsi.append([])\n# perulangan untuk menambahkan urutan nomor dari tiap abjad kunci\ni = 0\nwhile i&lt;len(key_myzkowski):\n    dekripsi[1].append(i+1)\n    i+=1\nprint(dekripsi)\nOutputnya:\n[['u', 'd', 'i', 'n', 'u', 's', 'u', 'n', 'g', 'g', 'u', 'l'], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]\nMengurutkan isi list berdasarkan dari list pertama yang berisi kunci\ndekripsi = np.array(dekripsi)\ndekripsi = dekripsi [ :, dekripsi[0].argsort()]\ndekripsi = dekripsi.tolist()\nprint(dekripsi)\nOutputnya:\n[['d', 'g', 'g', 'i', 'l', 'n', 'n', 's', 'u', 'u', 'u', 'u'], ['2', '9', '10', '3', '12', '4', '8', '6', '1', '5', '7', '11']]\nMenghitung jumlah frekuensi abjad dari list yang berisi kunci\ncount_key_decrypt = {}\nfor nilai in dekripsi[0]:\n    # Jika nilai sudah ada dalam dictionary, tambahkan 1 ke jumlahnya\n    if nilai in count_key_decrypt:\n        count_key_decrypt[nilai] += 1\n    # Jika nilai belum ada dalam dictionary, tambahkan ke dictionary dengan jumlah 1\n    else:\n        count_key_decrypt[nilai] = 1\nprint(count_key_decrypt)\nMembaca karakter dari ciphertext dan menempatkannya ke dalam list dekripsi berdasarkan kunci yang telah diuraikan\nindeks = 0\ni = 0\n# perulangan untuk menambahkan abjad ciphertext ke dalam list berdasarkan kunci dan jumlah frekuensi abjad kunci\nwhile i&lt;len(key_myzkowski):\n    if count_key_decrypt[dekripsi[0][i]]&gt;1:\n        for k in range(2,int((len(chipertext_myzkowski)/len(key_myzkowski))+2)):\n            for j in range(count_key_decrypt[dekripsi[0][i]]):\n                dekripsi[k].append(chipertext_myzkowski[indeks])\n                indeks+=1\n        i+=(count_key_decrypt[dekripsi[0][i]]-1)\n    else:\n        for k in range(2, int((len(chipertext_myzkowski) / len(key_myzkowski)) + 2)):\n            dekripsi[k].append(chipertext_myzkowski[indeks])\n            indeks+=1\n    i+=1\nprint(dekripsi)\nPenjelasan prosesnya:\nwhile i &lt; len(key_myzkowski):\n    if count_key_decrypt[dekripsi[0][i]] &gt; 1:\n\nwhile i &lt; len(key_myzkowski): Loop ini berjalan selama i kurang dari panjang key_myzkowski.\nif count_key_decrypt[dekripsi[0][i]] &gt; 1: Memeriksa apakah karakter pada posisi i di dekripsi[0] (baris kunci) memiliki pengulangan. Jika iya, berarti kita akan menangani kolom yang berulang.\n\nfor k in range(2, int((len(chipertext_myzkowski) / len(key_myzkowski)) + 2)):\n    for j in range(count_key_decrypt[dekripsi[0][i]]):\n        dekripsi[k].append(chipertext_myzkowski[indeks])\n        indeks += 1\ni += (count_key_decrypt[dekripsi[0][i]] - 1)\n\nfor k in range(2, int((len(chipertext_myzkowski) / len(key_myzkowski)) + 2)): Loop melalui setiap baris dalam list dekripsi, dimulai dari baris kedua. Perulangan ini dilakukan sesuai dengan jumlah kolom dan panjang ciphertext.\nfor j in range(count_key_decrypt[dekripsi[0][i]]): Loop ini dilakukan sesuai dengan jumlah pengulangan karakter yang sama dalam kunci.\ndekripsi[k].append(chipertext_myzkowski[indeks]): Tambahkan karakter dari chipertext_myzkowski pada posisi indeks ke baris k dalam list dekripsi.\nindeks += 1: Update indeks untuk karakter berikutnya.\ni += (count_key_decrypt[dekripsi[0][i]] - 1): Lewati jumlah karakter pengulangan di key_myzkowski.\n\nelse:\n    for k in range(2, int((len(chipertext_myzkowski) / len(key_myzkowski)) + 2)):\n        dekripsi[k].append(chipertext_myzkowski[indeks])\n        indeks += 1\n\nelse: Jika karakter pada posisi i di dekripsi[0] tidak memiliki pengulangan.\nfor k in range(2, int((len(chipertext_myzkowski) / len(key_myzkowski)) + 2)): Loop melalui setiap baris dalam list dekripsi, dimulai dari baris kedua.\ndekripsi[k].append(chipertext_myzkowski[indeks]): Tambahkan karakter dari chipertext_myzkowski pada posisi indeks ke baris k dalam list dekripsi.\nindeks += 1: Update indeks untuk karakter berikutnya.\n\nOutputnya:\n[['d', 'g', 'g', 'i', 'l', 'n', 'n', 's', 'u', 'u', 'u', 'u'], ['2', '9', '10', '3', '12', '4', '8', '6', '1', '5', '7', '11'], ['E', 'N', 'F', 'K', 'R', 'N', 'I', 'K', 'T', 'I', ' ', 'O'], ['A', 'D', 'I', 'T', 'U', 'I', 'U', 'A', 'M', 'K', ' ', 'N'], [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'S', ' ', ' ', ' ']]\nMengurutkan list dekripsi berdasarkan nilai pada list kedua dan kemudian menggabungkan karakter dari dekripsi untuk menghasilkan teks dekripsi akhir\ndekripsi = np.array(dekripsi)\n# mengurutkan list berdasarkan list kedua dan menampilkan hasil dari dekripsinya\ndekripsi = dekripsi [ :, dekripsi[1].astype(int).argsort()]\nhasil_dekripsi = []\nfor index, row in enumerate(dekripsi):\n    if index != 0 and index != 1:\n        print(row)\nfor i in range(2,len(dekripsi)):\n    for j in range(len(dekripsi[0])):\n      hasil_dekripsi.append(dekripsi[i][j])\nhasil_dekripsi = ''.join(hasil_dekripsi)\nprint(\"\\nHasil Dekripsi = \", hasil_dekripsi)\nPenjelasan Prosesnya:\n\ndekripsi = np.array(dekripsi) : dekripsi dikonversi menjadi array NumPy untuk memudahkan manipulasi data, terutama untuk sorting.\n\ndekripsi = dekripsi[:, dekripsi[1].astype(int).argsort()]\n\ndekripsi[:, ...]: Mengambil semua baris (:) dari dekripsi, tetapi hanya kolom yang diurutkan berdasarkan baris kedua.\ndekripsi[1]: Mengambil baris kedua dari dekripsi, yang berisi nilai-nilai kunci yang digunakan untuk pengurutan.\n.astype(int): Mengonversi nilai di baris kedua menjadi tipe integer jika belum dalam tipe ini, agar bisa diurutkan.\n.argsort(): Mengembalikan indeks yang akan mengurutkan array. Indeks ini digunakan untuk mengurutkan dekripsi berdasarkan nilai di baris kedua.\n\nfor index, row in enumerate(dekripsi):\n    if index != 0 and index != 1:\n        print(row)\n\nfor index, row in enumerate(dekripsi): Loop ini berjalan melalui setiap baris dalam dekripsi.\nif index != 0 and index != 1: Memeriksa apakah indeks tidak sama dengan 0 atau 1, karena baris ini adalah kunci dan mungkin tidak perlu ditampilkan atau diproses lebih lanjut.\nprint(row): Mencetak baris yang relevan untuk melihat hasil sementara dari dekripsi.\n\nfor i in range(2, len(dekripsi)):\n    for j in range(len(dekripsi[0])):\n        hasil_dekripsi.append(dekripsi[i][j])\n\nfor i in range(2, len(dekripsi)): Loop melalui baris dekripsi dimulai dari baris ketiga, karena baris pertama dan kedua adalah kunci dan pengurutan.\nfor j in range(len(dekripsi[0])): Loop melalui setiap kolom dalam baris dekripsi.\nhasil_dekripsi.append(dekripsi[i][j]): Menambahkan karakter dari posisi (i, j) di dekripsi ke hasil_dekripsi.\n\nhasil_dekripsi = ''.join(hasil_dekripsi)\nprint(\"\\nHasil Dekripsi = \", hasil_dekripsi)\n\nhasil_dekripsi = ''.join(hasil_dekripsi): Menggabungkan semua karakter di hasil_dekripsi menjadi satu string.\nprint(\"\\nHasil Dekripsi = \", hasil_dekripsi): Mencetak hasil dekripsi akhir.",
    "crumbs": [
      "Kriptografi Klasik",
      "6. Transposisi Myzkowski"
    ]
  },
  {
    "objectID": "7_transposisi_rail_fence.html",
    "href": "7_transposisi_rail_fence.html",
    "title": "7. Transposisi Rail Fence",
    "section": "",
    "text": "Analogi Transposisi Railfence\nMari kita analogikan transposisi railfence dengan menyusun pesan di pagar besi sebagai proses enkripsinya dan membaca pesan tersembunyi dalam sebuah pagar besi sebagai proses dekripsinya\nEnkripsi: Menyusun Pesan di Pagar Besi\nBayangkan Anda memiliki sebuah pesan yang ingin Anda sembunyikan, seperti “HELLO WORLD”. Untuk mengenkripsi pesan ini dengan algoritma transposisi Rail Fence, Kita akan menggunakan sebuah pagar besi dengan beberapa tingkat atau baris (rails).\nMisalnya, jika Anda menggunakan 3 tingkat (rails), maka Anda akan menyusun pesan Anda dengan cara berikut:\nSekarang, Kita membaca huruf-huruf tersebut dari tingkat pertama ke tingkat terakhir:\nDengan Menggabungkan semua huruf-huruf ini, Kita akan mendapatkan pesan terenkripsi atau ciphertext: “HOR ELWLD LO”\nDekripsi: Membaca Pesan dari Pagar Besi\nSekarang, bayangkan seseorang menerima pesan terenkripsi “HOR ELWLD LO” dan ingin membacanya. Untuk mendekripsi pesan tersebut, mereka harus menggunakan pagar besi yang sama dengan jumlah tingkat yang sama (3 tingkat dalam contoh ini).\nSekarang, mereka bisa membaca pesan asli dengan mengikuti jalur dari tingkat pertama ke tingkat terakhir dan kembali:\nDengan menggabungkan semua huruf-huruf ini, mereka mendapatkan hasil dekripsi atau pesan asli : “HELLO WORLD”",
    "crumbs": [
      "Kriptografi Klasik",
      "7. Transposisi Rail Fence"
    ]
  },
  {
    "objectID": "7_transposisi_rail_fence.html#contoh-soal",
    "href": "7_transposisi_rail_fence.html#contoh-soal",
    "title": "7. Transposisi Rail Fence",
    "section": "Contoh Soal",
    "text": "Contoh Soal\nPlainteks   : UNIVERSITAS DIAN NUSWANTORO\nKunci       : 3 baris (spasi ditulis)\nLangkah mengerjakan :\n\nSusun huruf-huruf plainteks ke dalam pola zigzag menggunakan 3 baris\n\nketerangan : jika di plainteks ada spasi, maka spasi di tulis, contohnya setelah huruf S pada kata UNIVERSITAS ada pengosongan tempat itu adalah spasi.\nBaca huruf-huruf dari baris-baris tersebut secara berurutan dari baris atas ke baris bawah\n\nHasil Ciphertext : UETD WONVRIA INNSATRISSAUNO",
    "crumbs": [
      "Kriptografi Klasik",
      "7. Transposisi Rail Fence"
    ]
  },
  {
    "objectID": "7_transposisi_rail_fence.html#implementasi-pada-python",
    "href": "7_transposisi_rail_fence.html#implementasi-pada-python",
    "title": "7. Transposisi Rail Fence",
    "section": "Implementasi Pada Python",
    "text": "Implementasi Pada Python\nMasukkan Plaintext\nCONTOH : UNIVERSITAS DIAN NUSWANTORO\nplainText = input(\"Plaintext : \")\nMasukkan Kunci atau Jumlah Baris\nCONTOH KEY : 3\nrailFenceKey = int(input(\"Kunci: \"))",
    "crumbs": [
      "Kriptografi Klasik",
      "7. Transposisi Rail Fence"
    ]
  },
  {
    "objectID": "6_transposisi_myzkowski.html#penjelasan-prosesnya",
    "href": "6_transposisi_myzkowski.html#penjelasan-prosesnya",
    "title": "6. Transposisi Myzkowski",
    "section": "Penjelasan prosesnya:",
    "text": "Penjelasan prosesnya:",
    "crumbs": [
      "Kriptografi Klasik",
      "6. Transposisi Myzkowski"
    ]
  },
  {
    "objectID": "2_monoalphabetic_random_key.html#proses-enkripsi",
    "href": "2_monoalphabetic_random_key.html#proses-enkripsi",
    "title": "2. Monoalphabetic Random Key",
    "section": "Proses Enkripsi",
    "text": "Proses Enkripsi\nMembuat mapping (pemetaan) antara huruf abjad dengan kunci\nmapping = dict(zip(abjad, key_monoalphabetic))\nprint(mapping)\nMelakukan proses enkripsi dengan mengganti setiap karakter dalam plaintext dengan karakter yang sesuai dalam kunci, atau mempertahankan karakter jika tidak ada dalam kunci\nciphertext_monoalphabetic = ''.join(mapping.get(karakter, karakter) for karakter in plaintext_monoalphabetic)\nMenampilkan bentuk substitusi dari key terhadap plaintext\nprint(\"Visualisasi penggantian huruf pada plaintext:\")\nfor huruf_plaintext, huruf_ciphertext in zip(plaintext_monoalphabetic, ciphertext_monoalphabetic):\n    if huruf_plaintext in abjad:\n        print(f\"{huruf_plaintext} =&gt; {huruf_ciphertext}\")\nMenampilkan hasil enkripsinya\nprint(\"Teks terenkripsi:\", ciphertext_monoalphabetic)",
    "crumbs": [
      "Kriptografi Klasik",
      "2. Monoalphabetic Random Key"
    ]
  },
  {
    "objectID": "2_monoalphabetic_random_key.html#proses-dekripsi",
    "href": "2_monoalphabetic_random_key.html#proses-dekripsi",
    "title": "2. Monoalphabetic Random Key",
    "section": "Proses Dekripsi",
    "text": "Proses Dekripsi\nMemasukkan cipherteks\nciphertext_monoalphabetic = input(\"Masukkan teks yang akan di dekripsi: \").lower()\nMemasukkan kunci\nkey_decyrpt = input(\"Masukkan kunci untuk dekripsi: \")\nMembuat mapping (pemetaan) terbalik antara kunci dan list abjad\nreverse_mapping = dict(zip(key_decyrpt, abjad))\nprint(reverse_mapping)\nMelakukan proses dekripsi dengan menggantikan setiap karakter dalam cipherteks dengan karakter yang sesuai di kunci dalam pemetaan terbalik, atau mempertahankan karakter jika tidak ada dalam pemetaan terbalik\nhasil_dekripsi = ''.join(reverse_mapping.get(karakter, karakter) for karakter in ciphertext_monoalphabetic)\nMenampilkan bentuk substitusi dari key terhadap cipherteks\nfor huruf_awal, huruf_terdekripsi in zip(ciphertext_monoalphabetic, hasil_dekripsi):\n  if huruf_awal in abjad:\n      print(f\"{huruf_awal} =&gt; {huruf_terdekripsi}\")\nMenampilkan hasil dekripsi\nprint(\"Teks terdekripsi:\", hasil_dekripsi)",
    "crumbs": [
      "Kriptografi Klasik",
      "2. Monoalphabetic Random Key"
    ]
  },
  {
    "objectID": "index.html#kriptog",
    "href": "index.html#kriptog",
    "title": "Kriptografi",
    "section": "Kriptog",
    "text": "Kriptog",
    "crumbs": [
      "**Pengantar**"
    ]
  },
  {
    "objectID": "index.html#kriptografi-klasik",
    "href": "index.html#kriptografi-klasik",
    "title": "Kriptografi",
    "section": "Kriptografi Klasik",
    "text": "Kriptografi Klasik\nKriptografi klasik adalah bentuk kriptografi yang dikembangkan sebelum munculnya komputer modern dan algoritma kriptografi yang kompleks.\nMetode kriptografi klasik umumnya berfokus pada manipulasi huruf-huruf dalam teks, seperti mengganti huruf-huruf dengan huruf-huruf lain atau melakukan pergeseran pada posisi huruf.\nMeskipun metode-metode ini telah digunakan untuk keamanan pada masanya, sebagian besar dianggap tidak aman dengan standar saat ini karena mudah diretas dengan komputasi modern",
    "crumbs": [
      "**Pengantar**"
    ]
  },
  {
    "objectID": "index.html#kript",
    "href": "index.html#kript",
    "title": "Kriptografi",
    "section": "Kript",
    "text": "Kript",
    "crumbs": [
      "**Pengantar**"
    ]
  },
  {
    "objectID": "index.html#kriptografi-modern",
    "href": "index.html#kriptografi-modern",
    "title": "Kriptografi",
    "section": "Kriptografi Modern",
    "text": "Kriptografi Modern",
    "crumbs": [
      "**Pengantar**"
    ]
  },
  {
    "objectID": "8_transposisi_route.html",
    "href": "8_transposisi_route.html",
    "title": "8. Transposisi Route",
    "section": "",
    "text": "Analogi Transposisi Route\nMari kita gunakan analogi kelas dengan siswa yang duduk di kursi dalam bentuk grid untuk menjelaskan algoritma transposisi route menggunakan pola spiral.\nBayangkan kamu adalah guru yang ingin mengatur ulang tempat duduk siswa sesuai pola spiral. Anda mulai dengan siswa pertama di sudut kiri atas, lalu bergerak ke kanan hingga akhir baris, turun ke baris berikutnya di sebelah kanan, kemudian bergerak ke kiri, dan seterusnya, sampai Anda kembali ke tengah grid. Berikut langkahnya :",
    "crumbs": [
      "Kriptografi Klasik",
      "8. Transposisi Route"
    ]
  },
  {
    "objectID": "8_transposisi_route.html#contoh-soal",
    "href": "8_transposisi_route.html#contoh-soal",
    "title": "8. Transposisi Route",
    "section": "Contoh Soal",
    "text": "Contoh Soal\nPlainteks   : UNIVERSITAS DIAN NUSWANTORO\nKunci       : 3 baris (spasi ditulis)\nLangkah mengerjakan :\n\nSusun huruf-huruf plainteks ke dalam pola zigzag menggunakan 3 baris\n\nketerangan : jika di plainteks ada spasi, maka spasi di tulis, contohnya setelah huruf S pada kata UNIVERSITAS ada pengosongan tempat itu adalah spasi.\nBaca huruf-huruf dari baris-baris tersebut secara berurutan dari baris atas ke baris bawah\n\nHasil Ciphertext : UETD WONVRIA INNSATRISSAUNO",
    "crumbs": [
      "Kriptografi Klasik",
      "8. Transposisi Route"
    ]
  },
  {
    "objectID": "8_transposisi_route.html#implementasi-pada-python",
    "href": "8_transposisi_route.html#implementasi-pada-python",
    "title": "8. Transposisi Route",
    "section": "Implementasi Pada Python",
    "text": "Implementasi Pada Python\nMasukkan Plaintext\nCONTOH : TENTUKAN PRIORITAS ANDA SEBAB KITA TIDAK DAPAT MENGERJAKAN SEMUANYA X\nplainText = input(\"Plaintext : \")\nMasukkan Kunci\nCONTOH KEY : 5\nrouteKey = int(input(\"Kunci: \"))\nMenghapus Spasi\ncleanPlainTeks = plainTeks.replace(\" \", \"\")\nprint(cleanPlainTeks)",
    "crumbs": [
      "Kriptografi Klasik",
      "8. Transposisi Route"
    ]
  },
  {
    "objectID": "7_transposisi_rail_fence.html",
    "href": "7_transposisi_rail_fence.html",
    "title": "7. Transposisi Rail Fence",
    "section": "",
    "text": "Analogi Transposisi Railfence\nMari kita analogikan transposisi railfence dengan menyusun pesan di pagar besi sebagai proses enkripsinya dan membaca pesan tersembunyi dalam sebuah pagar besi sebagai proses dekripsinya\nEnkripsi: Menyusun Pesan di Pagar Besi\nBayangkan Anda memiliki sebuah pesan yang ingin Anda sembunyikan, seperti “HELLO WORLD”. Untuk mengenkripsi pesan ini dengan algoritma transposisi Rail Fence, Kita akan menggunakan sebuah pagar besi dengan beberapa tingkat atau baris (rails).\nMisalnya, jika Anda menggunakan 3 tingkat (rails), maka Anda akan menyusun pesan Anda dengan cara berikut:\nSekarang, Kita membaca huruf-huruf tersebut dari tingkat pertama ke tingkat terakhir:\nDengan Menggabungkan semua huruf-huruf ini, Kita akan mendapatkan pesan terenkripsi atau ciphertext: “HOR ELWLD LO”\nDekripsi: Membaca Pesan dari Pagar Besi\nSekarang, bayangkan seseorang menerima pesan terenkripsi “HOR ELWLD LO” dan ingin membacanya. Untuk mendekripsi pesan tersebut, mereka harus menggunakan pagar besi yang sama dengan jumlah tingkat yang sama (3 tingkat dalam contoh ini).\nSekarang, mereka bisa membaca pesan asli dengan mengikuti jalur dari tingkat pertama ke tingkat terakhir dan kembali:\nDengan menggabungkan semua huruf-huruf ini, mereka mendapatkan hasil dekripsi atau pesan asli : “HELLO WORLD”",
    "crumbs": [
      "Kriptografi Klasik",
      "7. Transposisi Rail Fence"
    ]
  },
  {
    "objectID": "7_transposisi_rail_fence.html#contoh-soal",
    "href": "7_transposisi_rail_fence.html#contoh-soal",
    "title": "7. Transposisi Rail Fence",
    "section": "Contoh Soal",
    "text": "Contoh Soal\nPlainteks   : UNIVERSITAS DIAN NUSWANTORO\nKunci       : 3 baris (spasi ditulis)\nLangkah mengerjakan :\n\nSusun huruf-huruf plainteks ke dalam pola zigzag menggunakan 3 baris\n\nketerangan : jika di plainteks ada spasi, maka spasi di tulis, contohnya setelah huruf S pada kata UNIVERSITAS ada pengosongan tempat itu adalah spasi.\nBaca huruf-huruf dari baris-baris tersebut secara berurutan dari baris atas ke baris bawah\n\nHasil Ciphertext : UETD WONVRIA INNSATRISSAUNO",
    "crumbs": [
      "Kriptografi Klasik",
      "7. Transposisi Rail Fence"
    ]
  },
  {
    "objectID": "7_transposisi_rail_fence.html#implementasi-pada-python",
    "href": "7_transposisi_rail_fence.html#implementasi-pada-python",
    "title": "7. Transposisi Rail Fence",
    "section": "Implementasi Pada Python",
    "text": "Implementasi Pada Python\nMasukkan Plaintext\nplainText = input(\"Plaintext : \")\nMasukkan Kunci atau Jumlah Baris\nrailFenceKey = int(input(\"Kunci: \"))\n\nProses Enkripsi\n\nMembuat Matriks Kosong Sesuai Dengan Jumlah Baris (kunci)\n\n   rails = [[' ' for _ in range(len(plainText))] for _ in \n   range(railFenceKey)]\n\nMenentukan Arah Pola Zig-Zag Dari Huruf-Huruf Dalam Plaintext, jika direction = 1 maka pola turun, jika -1 maka pola naik\n\n   i, j = 0, 0\n   direction = 1  \n\nMenempatkan karakter-karakter dari plainText ke dalam matriks dalam pola zigzag sesuai dengan kunci Rail Fence\n\n   for char in plainText:\n     rails[i][j] = char\n     if i == 0:\n       direction = 1\n     elif i == railFenceKey - 1:\n       direction = -1\n     i += direction\n     j += 1\nFor More Detail :\n\nfor char in plainText : Setiap karakter dalam teks yang ingin dienkripsi akan diproses satu per satu\nrails[i][j] = char : Karakter saat ini ditempatkan di baris [i] dan kolom [j] dari matriks rails\nif i == 0: direction = 1 : Jika berada di baris teratas, ubah arah pergerakan ke bawah\nelif i == railFenceKey - 1 : direction = -1: Jika berada di baris terbawah, ubah arah pergerakan ke atas\ni += direction : Indeks baris [i] ditambah atau dikurangi sesuai dengan arah pergerakan (ke bawah atau ke atas) Mengupdate indeks kolom [j] untuk pindah ke karakter berikutnya:\nj += 1 : Indeks kolom [j] selalu bertambah satu untuk setiap karakter\n\n\nMembentuk Teks Terenkripsi Berdasarkan Pola Zig-Zag\n\n   enkripsi_teks = '\\n'.join([''.join(row) for row in rails])\n   print(\"* RAIL FENCE: \")\n   print(enkripsi_teks)\nFore More Detail :\n\nrow merepresentasikan setiap baris dalam matriks rails.\n''.join(row) : Menggabungkan semua karakter dalam baris row menjadi satu string\nfor row in rails : Ini adalah list comprehension yang mengiterasi setiap baris dalam matriks rails\n'\\n'.join([...]) : Menggabungkan semua string dalam daftar hasil dari list comprehension di langkah sebelumnya menjadi satu string besar\n\n\nMempersiapkan daftar untuk setiap baris (rail) dan mengatur agar kita mulai dari baris pertama dengan pergerakan ke bawah.\n\n   rails = [[] for _ in range(railFenceKey)]\n   index = 0\n   direction = 1\nFor More Detail :\n\nrails = [[] for _ in range(railFenceKey)] : Membuat daftar berisi daftar kosong untuk setiap baris (rail) sesuai dengan jumlah baris yang ditentukan oleh railFenceKey\nindex = 0 : Menentukan bahwa kita mulai dari baris pertama (index 0).\ndirection = 1 : Menentukan bahwa pergerakan awalnya ke bawah (nilai 1).\n\n\nMenempatkan karakter-karakter dari plainText ke dalam daftar rails dalam pola zigzag, mengubah arah pergerakan ketika mencapai baris pertama atau terakhir\n\n   for char in plainText:\n     rails[index].append(char)\n     if index == 0:\n       direction = 1\n\n     elif index == railFenceKey - 1:\n       direction = -1\n\n     index += direction\nFor More Detail :\n\nfor char in plainText : Looping untuk Mengiterasi setiap karakter dalam plainText satu per satu\nrails[index].append(char) : Menambahkan karakter char ke daftar rails pada posisi index saat ini\nif index == 0: direction = 1 : Jika index adalah 0 (baris pertama), ubah arah pergerakan ke bawah (direction = 1)\nelif index == railFenceKey - 1: direction = -1 : Jika index adalah railFenceKey - 1 (baris terakhir), ubah arah pergerakan ke atas (direction = -1)\nindex += direction : Menambah atau mengurangi index sesuai dengan direction\n\n\nmenggabungkan karakter-karakter yang telah disusun dalam matriks rails menjadi satu string yang merupakan teks terenkripsi (ciphertext)\n\n   enkripsi_teks = \"\".join([\"\".join(rail) for rail in rails])\n   print(\"CIPHERTEXT : \" + enkripsi_teks)\nFor More Detail :\n\n[\"\".join(rail) for rail in rails] : List comprehension yang menghasilkan daftar string, di mana setiap string adalah satu baris dari matriks rails\n\"\".join([...]) : Menggabungkan semua string dalam daftar menjadi satu string besar tanpa pemisah\n\"\".join(rail) : Menggabungkan semua karakter dalam baris rail menjadi satu string\nHasilnya adalah satu string panjang yang merupakan teks terenkripsi (enkripsi_teks).\n\n   CIPHERTEXT : UETD WONVRIA INNSATRISSAUNO\n\n\nProses Dekripsi\n\nMempersiapkan daftar untuk setiap baris (rail) dan mengatur agar kita mulai dari baris pertama dengan pergerakan ke bawah\n\n   rails = [[] for _ in range(railFenceKey)]\n   index = 0\n   direction = 1\nFor More Detail :\n\nrails = [[] for _ in range(railFenceKey)]: Membuat daftar berisi daftar kosong untuk setiap baris (rail) sesuai dengan jumlah baris yang ditentukan oleh railFenceKey Membuat placeholder untuk menyiapkan “kotak-kotak” yang akan mengorganisir karakter-karakter terenkripsi sehingga dapat didekripsi kembali dengan benar\nindex = 0: Menentukan bahwa kita mulai dari baris pertama (index 0)\ndirection = 1: Menentukan bahwa pergerakan awalnya ke bawah (nilai 1)\n\n\nMempersiapkan tempat untuk karakter-karakter dari teks terenkripsi agar bisa ditempatkan di posisi yang benar selama proses dekripsi\n\n   for char in enkripsi_teks:\n     rails[index].append(None)\n     if index == 0:\n       direction = 1\n  \n     elif index == railFenceKey - 1:\n       direction = -1\n     index += direction\nFor More Detail :\n\nif index == 0: direction = 1 : Mengiterasi setiap karakter dalam enkripsi_teks satu persatu.\nelif index == railFenceKey - 1: direction = -1: Jika index adalah railFenceKey - 1 (baris terakhir), ubah arah pergerakan ke atas (direction = -1)\nindex += direction : Menambah atau mengurangi index sesuai dengan direction. Jika direction = 1 bergerak ke bawah sedangkan direction = -1 bergerak ke atas\n\n\nMenempatkan karakter-karakter dari teks terenkripsi kembali ke posisi yang benar dalam matriks rails, sesuai dengan placeholder (None) yang telah ditandai sebelumnya\n\n   index_char = 0\n   for rail in rails:\n     for i in range(len(rail)):\n       rail[i] = enkripsi_teks[index_char]\n       index_char += 1\nFor More Detail :\n\nindex_char : Melacak posisi karakter dalam enkripsi_teks.\nfor rail in rails : Looping untuk mengiterasi setiap baris dalam matriks rails.\nfor i in range(len(rail)): : Mengiterasi setiap posisi dalam baris rail yang memiliki placeholder.\nrail[i] = enkripsi_teks[index_char] : Menempatkan karakter dari enkripsi_teks pada posisi yang sesuai dalam rail.\nindex_char += 1 : Meningkatkan index_char untuk berpindah ke karakter berikutnya dalam enkripsi_teks.\n\n\nMembaca kembali karakter-karakter dari matriks rails dalam urutan zigzag yang benar dan menyusunnya menjadi teks asli\n\n   index = 0\n   direction = 1\n   dekripsi_teks = []\nFor More Detail :\n\nindex : Melacak baris saat ini dalam matriks rails\ndirection : Menentukan arah pergerakan (ke bawah atau ke atas)\ndekripsi_teks = [] : Daftar yang akan menyimpan karakter karakter teks asli dalam urutan yang benar.\n\n\nMembaca kembali karakter-karakter dari matriks rails dalam urutan zigzag yang benar dan menyusunnya menjadi teks asli\n\n    for _ in range(len(enkripsi_teks)):\n      dekripsi_teks.append(rails[index].pop(0))\n      if index == 0:\n        direction = 1\n\n      elif index == railFenceKey - 1:\n        direction = -1\n      index += direction\nFor More Detail :\n\nfor _ in range(len(enkripsi_teks)): : Mengiterasi sebanyak panjang enkripsi_teks untuk memastikan semua karakter diproses.\ndekripsi_teks.append(rails[index]) : Mengambil karakter pertama dari baris index dalam rails dan menambahkannya ke dekripsi_teks\n.pop(0) : pop(0) menghapus dan mengembalikan elemen pertama dari baris index\nif index == 0: direction = 1 : Jika index adalah 0 (baris pertama), ubah arah pergerakan ke bawah (direction = 1)\nelif index == railFenceKey - 1: direction = -1 : Jika index adalah railFenceKey - 1 (baris terakhir), ubah arah pergerakan ke atas (direction = -1)\nindex += direction: Mengupdate indeks baris\n\n\nMenggabungkan karakter-karakter yang telah disusun kembali dalam dekripsi_teks menjadi satu string yang merupakan teks asli hasil dekripsi\n\n   railFenceDecryption = \"\".join(dekripsi_teks)\n   print(\" DECRYPTED : \" + railFenceDecryption)\nFor More Detail :\n\n''.join(dekripsi_teks) : Menggabungkan semua elemen dalam dekripsi_teks menjadi satu string tanpa pemisah.\nVariabel railFenceDecryption akan menyimpan string hasil dek\n\nHASIL DECRYPTED : UNIVERSITAS DIAN NUSWANTORO",
    "crumbs": [
      "Kriptografi Klasik",
      "7. Transposisi Rail Fence"
    ]
  },
  {
    "objectID": "9_stream_cipher.html",
    "href": "9_stream_cipher.html",
    "title": "1. Stream Cipher",
    "section": "",
    "text": "Analogi Transposisi Route\nMari kita gunakan analogi kelas dengan siswa yang duduk di kursi dalam bentuk grid untuk menjelaskan algoritma transposisi route menggunakan pola spiral.\nBayangkan kamu adalah guru yang ingin mengatur ulang tempat duduk siswa sesuai pola spiral. Anda mulai dengan siswa pertama di sudut kiri atas, lalu bergerak ke kanan hingga akhir baris, turun ke baris berikutnya di sebelah kanan, kemudian bergerak ke kiri, dan seterusnya, sampai Anda kembali ke tengah grid. Berikut langkahnya :",
    "crumbs": [
      "Kriptografi Modern",
      "1. Stream Cipher"
    ]
  },
  {
    "objectID": "9_stream_cipher.html#implementasi-pada-python",
    "href": "9_stream_cipher.html#implementasi-pada-python",
    "title": "1. Stream Cipher",
    "section": "Implementasi Pada Python",
    "text": "Implementasi Pada Python\nMasukkan Plaintext\nCONTOH : TENTUKAN PRIORITAS ANDA SEBAB KITA TIDAK DAPAT MENGERJAKAN SEMUANYA X\nplainText = input(\"Plaintext : \")\nMasukkan Kunci\nCONTOH KEY : 5\nrouteKey = int(input(\"Kunci: \"))\nMenghapus Spasi\ncleanPlainTeks = plainTeks.replace(\" \", \"\")\nprint(cleanPlainTeks)\n\nProses Enkripsi\n\nMenyusun teks yang sudah dibersihkan ke dalam sebuah matriks dengan kolom sebagai jumlah kolom atau lebar matriks\n\n    kolom = routeKey\n    matrix = []\n    panjang = len(cleanPlainTeks)\n    temp = panjang/kolom\n    bulat = round(temp)\n\n    if temp - bulat == 0:\n        jml_baris = bulat\n    else:\n        if temp - bulat &lt; 0:\n            jml_baris = bulat\n        else:\n            jml_baris = bulat + 1\n    print(jml_baris)\nFor More Detail :\n\nkolom = routeKey : Menetapkan jumlah kolom pada matriks dengan nilai routeKey\nmatrix = [] : Menginisialisasi sebuah list kosong yang akan digunakan untuk menyimpan elemen-elemen matriks\npanjang = len(cleanPlainTeks) : Menghitung panjang teks yang sudah dibersihkan\ntemp = panjang/kolom : Menghitung berapa banyak baris yang diperlukan dengan membagi panjang teks dengan jumlah kolom dan menyimpan hasilnya dalam variabel temp\nbulat = round(temp) : Membulatkan hasil pembagian temp ke angka terdekat dan menyimpannya ke dalam variabel bulat\ntemp - bulat == 0 : hasil pembagian tepat bulat, maka jml_baris diambil dari bulat\ntemp - bulat &lt; 0 : hasil pembagian kurang dari bulat (mungkin karena temp lebih kecil dari bulat), dan juga mengambil jml_baris dari bulat\njml_baris = bulat + 1 : Jika kondisi sebelumnya tidak terpenuhi, maka perlu satu baris tambahan\n\n\nMembuat sebuah matriks (matrix) yang berisi teks yang sudah dibersihkan (cleanPlainTeks) menggunakan nilai jml_baris dan kolom yang telah dihitung sebelumnya\n\n    for i in range(jml_baris):\n        row = []\n        for j in range(kolom):\n            if i * kolom + j &lt; len(cleanPlainTeks):\n                elemen = cleanPlainTeks[i * kolom + j]\n            else:\n                elemen = \" \"\n            row.append(elemen)\n        matrix.append(row)\nFor More Detail :\n\nfor i in range(jml_baris) : Loop ini mengiterasi dari 0 hingga jml_baris - 1, yang berarti setiap iterasi mewakili satu baris dalam matriks\nrow = [] : Membuat list kosong row yang akan menyimpan elemen-elemen untuk satu baris matriks\nfor j in range(kolom) : Loop ini mengiterasi dari 0 hingga kolom - 1, yang berarti setiap iterasi mewakili satu kolom dalam matriks\nif i * kolom + j &lt; len(cleanPlainTeks) : Memastikan bahwa tidak melebihi panjang dari teks yang telah dibersihkan pada saat mengakses elemen cleanPlainTeks untuk dimasukkan ke dalam matrix\nelemen = x[i * kolom + j] : Jika ya, Mengambil elemen dari teks x pada posisi i * kolom + j\nelemen = \" \" : Jika tidak, Mengisi elemen dengan spasi kosong jika indeks berada di luar panjang teks x -row.append(elemen) : Menambahkan elemen yang telah ditentukan (baik dari x atau spasi kosong) ke list row\nmatrix.append(row) : Menambahkan list row yang berisi elemen-elemen satu baris ke dalam list matrix\n\n\nMencetak matrix\n\n    print(\"Matriks yang Anda buat:\")\n    for row in matrix:\n        print(row)\n\nMenghasilkan matriks transpose dari matrix yang telah dibuat\n\n    transposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\n    for row in transposed_matrix:\n        print(row)\nFor More Detail :\n\nrow[i] for row in matrix : Menghasilkan list elemen ke-i dari setiap baris dalam matrix\nfor i in range(len(matrix[0]))] : Mengiterasi setiap indeks kolom dari matrix dan membentuk baris baru dari elemen-elemen tersebut\nfor row in transposed_matrix : Loop ini mengiterasi melalui setiap baris dalam transposed_matrix\nprint(row) : Mencetak matriks transpose dari matrix\n\n\nString kosong yang akan digunakan untuk menyimpan teks yang terenkripsi\n\n    encrypted_text = \"\"\n\nMenandai batas awal dan akhir dari baris dan kolom pada matriks transpose\n\n    start_row, end_row = len(transposed_matrix) - 1, 0\n    start_col, end_col = len(transposed_matrix[0]) - 1, 0\n\nMengambil baris dari kanan ke kiri\n\n    while start_row &gt;= end_row and start_col &gt;= end_col:\n        for i in range(start_col, end_col - 1, -1):\n            encrypted_text += transposed_matrix[start_row][i]\n\n        start_row -= 1\nFor More Detail :\n\nwhile start_row &gt;= end_row and start_col &gt;= end_col : loop while yang berjalan selama start_row lebih besar dari atau sama dengan end_row dan start_col lebih besar dari atau sama dengan end_col\nfor i in range(start_col, end_col - 1, -1) : Loop ini mengiterasi dari kolom paling kanan (start_col) ke kolom paling kiri (end_col - 1)\nencrypted_text += transposed_matrix[start_row][i] : Menambahkan elemen dari baris start_row dan kolom i ke encrypted_text\nstart_row -= 1 : Mengurangi start_row untuk bergerak ke baris berikutnya ke atas\n\n\nMengambil kolom dari atas ke bawah\n\n    for i in range(start_row, end_row - 1, -1):\n            encrypted_text += transposed_matrix[i][end_col]\n\n        end_col += 1\nFor More Detail :\n\nfor i in range(start_row, end_row - 1, -1) : Loop ini mengiterasi dari baris start_row ke baris end_row - 1\nencrypted_text += transposed_matrix[i][end_col] : Menambahkan elemen dari baris i dan kolom end_col ke encrypted_text\nend_col += 1 : Menambahkan end_col untuk bergerak ke kolom berikutnya ke kiri.\n\n\nMengecek jika sudah mencapai kolom terakhir\n\n    if start_col &lt; end_col:\n            break\nFor More Detail :\n\nif start_col &lt; end_col: : Mengecek apakah start_col lebih kecil dari end_col\nbreak : Jika ya, keluar dari loop while.\n\n\nMengambil baris dari kiri ke kanan\n\n    for i in range(end_col, start_col + 1):\n            encrypted_text += transposed_matrix[end_row][i]\n\n        end_row += 1\nFor More Detail :\n\nfor i in range(end_col, start_col + 1) : Loop ini mengiterasi dari kolom end_col ke kolom start_col + 1\nencrypted_text += transposed_matrix[end_row][i] : Menambahkan elemen dari baris end_row dan kolom i ke encrypted_text\nend_row += 1 : Menambahkan end_row untuk bergerak ke baris berikutnya ke bawah.\n\n\nMengecek Jika Sudah Mencapai Baris Terakhir\n\n    if start_row &lt; end_row:\n            break\nFor More Detail :\n\nif start_row &lt; end_row : Mengecek apakah start_row lebih kecil dari end_row\nbreak : Jika ya, keluar dari loop while\n\n\nMengambil kolom dari bawah ke atas\n\n    for i in range(end_row, start_row + 1):\n            encrypted_text += transposed_matrix[i][start_col]\n\n        start_col -= 1\nFor More Detail :\n\nfor i in range(end_row, start_row + 1) : Loop ini mengiterasi dari baris end_row ke baris start_row + 1\nencrypted_text += transposed_matrix[i][start_col] : Menambahkan elemen dari baris i dan kolom start_col ke encrypted_text\nstart_col -= 1 : Mengurangi start_col untuk bergerak ke kolom berikutnya ke kanan\n\n\nMencetak teks terenkripsi (ciphertext)\n\nprint(\"Teks terenkripsi dengan pola spiral: \", encrypted_text[:length])\nFor More Detail :\n\nencrypted_text[:length]) : Memotong encrypted_text hingga panjang teks asli (length) untuk memastikan panjangnya sama dengan teks asli\n\nHASIL CIPHERTEXT : XUAETKAADTRUTNETKIAABTDMRNANYAMKGAATBNIPNAOSSKIAEJSEANPDIEAR\n\n\nProses Dekripsi\nMasukkan Ciphertext\ncipherText = input(\"cipher : \")\nMasukkan kunci\nrouteKey = int(input(\"Kunci: \"))\n\nMenentukan jumlah baris yang dibutuhkan untuk membentuk sebuah matriks dengan jumlah kolom yang telah ditentukan (routeKey). Matriks ini akan berisi teks x yang telah dibersihkan\n\n    kolom = routeKey\n    matrix = []\n    panjang = len(x)\n    temp = panjang/kolom\n    length = len(x)\n    bulat = round(temp)\n\n    if temp - bulat == 0:\n        jml_baris = bulat\n    else:\n        if temp - bulat &lt; 0:\n            jml_baris = bulat\n        else:\n            jml_baris = bulat + 1\n    print(jml_baris)\nFor More Detail :\n\nkolom = routeKey : Menetapkan jumlah kolom pada matriks dengan nilai routeKey\nmatrix = [] : Menginisialisasi sebuah list kosong yang akan digunakan untuk menyimpan elemen-elemen matriks\npanjang = len(x) : Menyimpan panjang dari teks x ke dalam variabel panjang\ntemp = panjang/kolom : Menghitung berapa banyak baris yang diperlukan dengan membagi panjang teks dengan jumlah kolom dan menyimpan hasilnya dalam variabel temp\nlength = len(x) : Menyimpan panjang teks x ke dalam variabel length\nbulat = round(temp) : Membulatkan hasil pembagian temp ke angka terdekat dan menyimpannya ke dalam variabel bulat\n\n\nMembangun matriks 2D yang berisi teks x yang telah dibersihkan (tanpa spasi), Matriks ini akan memiliki jml_baris baris dan kolom kolom\n\n    for i in range(jml_baris):\n        row = []\n        for j in range(kolom):\n            if i * kolom + j &lt; len(x):\n                elemen = [i * kolom + j]\n            else:\n                elemen = \" \"\n            row.append(elemen)\n        matrix.append(row)\nFor More Detail :\n\nfor i in range(jml_baris) : Loop ini mengiterasi dari 0 hingga jml_baris - 1, yang berarti setiap iterasi mewakili satu baris dalam matriks\nrow = [] : Membuat list kosong row yang akan menyimpan elemen-elemen untuk satu baris matriks\nfor j in range(kolom) : Loop ini mengiterasi dari 0 hingga kolom - 1, yang berarti setiap iterasi mewakili satu kolom dalam matriks\nif i * kolom + j &lt; len(x) : Mengecek apakah indeks (dihitung sebagai i * kolom + j) berada dalam rentang panjang teks x\nelemen = x[i * kolom + j] : Jika ya, Mengambil elemen dari teks x pada posisi i * kolom + j\nelemen = \" \" : Jika tidak, Mengisi elemen dengan spasi kosong jika indeks berada di luar panjang teks x -row.append(elemen) : Menambahkan elemen yang telah ditentukan (baik dari x atau spasi kosong) ke list row\nmatrix.append(row) : Menambahkan list row yang berisi elemen-elemen satu baris ke dalam list matrix\n\n\nMencetak matriks yang telah dibuat\n\n    print(\"Matriks yang Anda buat:\")\n    for row in matrix:\n        print(row)\n\nMembuat dan mencetak matriks transpose\n\n    transposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\n    for row in transposed_matrix:\n        print(row)\nFor More Detail :\n\nrow[i] for row in matrix : Menghasilkan list elemen ke-i dari setiap baris dalam matrix\nfor i in range(len(matrix[0]))] : Mengiterasi setiap indeks kolom dari matrix dan membentuk baris baru dari elemen-elemen tersebut\nfor row in transposed_matrix : Loop ini mengiterasi melalui setiap baris dalam transposed_matrix\n\n\nMengatur batas-batas dan kontrol iterasi saat mengisi transposed_matrix dalam pola spiral dengan karakter-karakter dari teks x\n\n    start_row, end_row = len(transposed_matrix) - 1, 0\n    start_col, end_col = len(transposed_matrix[0]) - 1, 0\n    text_index = 0\nFor More Detail :\n\nstart_row : Mengendalikan pengisian dari baris terakhir ke atas\nend_row : Mengendalikan pengisian dari baris pertama ke bawah\nend_row = 0 : Menetapkan indeks baris awal ke 0, yang berarti kita mulai dari baris pertama\nlen(transposed_matrix) : Memberikan jumlah baris dalam transposed_matrix\nMengurangkan 1 untuk mendapatkan indeks baris terakhir dari matriks transpose\nstart_col : Mengendalikan pengisian dari kolom terakhir ke kiri, sedangkan\nend_col : Mengendalikan pengisian dari kolom pertama ke kanan\nlen(transposed_matrix[0]) : Memberikan jumlah kolom dalam transposed_matrix\nMengurangkan 1 untuk mendapatkan indeks kolom terakhir dari matriks transpose\nend_col = 0 : Menetapkan indeks kolom awal ke 0, yang berarti kita mulai dari kolom pertama\ntext_index : Melacak posisi karakter dalam teks x yang sedang diproses\n\n\nMengisi baris pertama dari kanan ke kiri\n\n    while start_row &gt;= end_row and start_col &gt;= end_col:\n        # Fill the first row from the remaining rows\n        for i in range(start_col, end_col - 1, -1):\n            if text_index &lt; len(x):\n                transposed_matrix[start_row][i] = x[text_index]\n                text_index += 1\n\n        start_row -= 1\nFor More Detail :\n\nstart_col dan end_col : menentukan rentang kolom yang akan diisi\ntext_index : mengambil karakter dari teks x.\nTransposed_matrix[start_row][i] : Setiap karakter yang diambil dari x dimasukkan ke dalam posisi yang sesuai di t.\n\n\nMengisi kolom terakhir dari baris yang tersisa dalam matriks dengan karakter dari x dalam urutan spiral\n\n    for i in range(start_row, end_row - 1, -1):\n            if text_index &lt; len(x):\n                transposed_matrix[i][end_col] = x[text_index]\n                text_index += 1\n\n        end_col += 1\nFor More Detail :\n\nfor i in range(start_row, end_row - 1, -1) : Loop ini digunakan untuk iterasi melalui baris-baris dalam matriks dari start_row ke end_row - 1 dalam urutan menurun\nstart_row : Posisi baris awal untuk iterasi\nend_row - 1 : Posisi baris akhir (tidak termasuk) untuk iterasi\n-1 : Menunjukkan bahwa iterasi dilakukan secara menurun\nif text_index &lt; len(cipherText) : Kondisi ini memastikan bahwa indeks text_index masih dalam batas panjang cipherText\ntransposed_matrix[i][end_col] : Menunjukkan posisi kolom end_col dalam baris i dari matriks yang sedang diisi\ncipherText[text_index] : Karakter dari cipherText pada indeks text_index\ntext_index += 1 : Setelah menempatkan karakter dari cipherText ke dalam transposed_matrix, nilai text_index dinaikkan sebesar 1 untuk mempersiapkan karakter berikutnya pada iterasi selanjutnya\nend_col += 1 : Setelah menyelesaikan iterasi untuk mengisi kolom terakhir dari baris yang tersisa, end_col dinaikkan sebesar 1 untuk mempersempit batas kolom yang akan diisi pada iterasi berikutnya\n\n\nMenentukkan apakah batas kolom telah bertemu atau melewati satu sama lain, yang berarti bahwa semua kolom yang perlu diisi sudah selesai diproses\n\n    if start_col &lt; end_col:\n            break\n\nMengisi baris terakhir dari kolom yang tersisa dalam matriks dengan karakter dari x dalam urutan spiral.\n\n    for i in range(end_col, start_col + 1):\n            if text_index &lt; len(x):\n                transposed_matrix[end_row][i] = x[text_index]\n                text_index += 1\n\n        end_row += 1\nFor More Detail :\n\nfor i in range(end_col, start_col + 1): Loop ini digunakan untuk iterasi melalui kolom dari end_col ke start_col + 1\nend_col: Posisi kolom awal untuk iterasi\nstart_col + 1: Posisi kolom akhir (tidak termasuk) untuk iterasi, Menambah 1 untuk memasukkan start_col dalam iterasi\nif text_index &lt; len(x) : Kondisi ini memastikan bahwa indeks\ntext_index : Masih dalam batas panjang x. Hal ini untuk menghindari akses indeks yang tidak valid dari x\ntransposed_matrix[end_row][i] = x[text_index] Menetapkan karakter dari x pada posisi indeks text_index ke posisi [end_row][i] dalam transposed_matrix\ntransposed_matrix[end_row][i]: Menunjukkan posisi kolom i dalam baris end_row dari matriks yang sedang diisi.\nx[text_index]: Karakter dari x pada indeks text_index\ntext_index += 1 Setelah menempatkan karakter dari x ke dalam transposed_matrix, nilai text_index dinaikkan sebesar 1 untuk mempersiapkan karakter berikutnya pada iterasi selanjutnya\nend_row += 1 Setelah menyelesaikan iterasi untuk mengisi baris terakhir dari kolom yang tersisa, batas baris akhir (end_row) dinaikkan sebesar 1 untuk mempersempit batas baris yang akan diisi pada iterasi berikutnya\n\n\nMenghentikan loop while jika batas baris bertemu atau melewati satu sama lain, menandakan bahwa pengisian matriks dalam pola spiral sudah selesai\n\n    if start_row &lt; end_row:\n            break\n\nMengisi baris terakhir dari kolom yang tersisa dalam matriks dengan karakter dari x dalam urutan spiral\n\n    for i in range(end_row, start_row + 1):\n            if text_index &lt; len(x):\n                transposed_matrix[i][start_col] = x[text_index]\n                text_index += 1\n\n        start_col -= 1\nFor More Detail :\n\nfor i in range(end_row, start_row + 1) : Loop ini digunakan untuk iterasi melalui baris dari end_row ke start_row + 1 dalam urutan meningkat\nend_row : Posisi baris awal untuk iterasi\nstart_row + 1 : Posisi baris akhir (tidak termasuk) untuk iterasi, Menambah 1 untuk memasukkan start_row dalam iterasi\nif text_index &lt; len(x) : Kondisi ini memastikan bahwa indeks text_index masih dalam batas panjang x\ntransposed_matrix[i][start_col] : Menunjukkan posisi kolom start_col dalam baris i dari matriks yang sedang diisi\nx[text_index] : Karakter dari x pada indeks text_index\ntext_index += 1 : Nilai text_index dinaikkan sebesar 1 untuk mempersiapkan karakter berikutnya pada iterasi selanjutnya\nstart_col -= 1 : Batas kolom awal (start_col) dikurangi sebesar 1 untuk mempersempit batas kolom yang akan diisi pada iterasi berikutnya\n\n\nMencetak matriks yang telah diisi dengan ciphertext\n\n    print(\"Matriks setelah diisi dengan cipher secara spiral:\")\n    for row in transposed_matrix:\n        print(row)\n\nString kosong untuk menyimpan hasil teks yang telah didekripsi\n\n    decrypted_text = \"\"\n\nMenyimpan jumlah baris dari transposed_matrix dalam variabel num_rows\n\n    num_rows = len(transposed_matrix)\n\nMenghitung jumlah kolom dalam transposed_matrix\n\n    num_cols = len(transposed_matrix[0])\n\nMenggabungkan karakter-karakter dari transposed_matrix ke dalam decrypted_text dengan membaca matriks secara kolom demi kolom\n\n    for col in range(num_cols):  \n        for row in range(num_rows):  \n            decrypted_text += transposed_matrix[row][col]\nFor More Detail :\n\nfor col in range(num_cols): Loop for ini digunakan untuk iterasi melalui setiap kolom dalam transposed_matrix.\nnum_cols : Jumlah kolom dalam transposed_matrix Ini mengontrol jumlah iterasi, memastikan bahwa setiap kolom dalam matriks diproses\nfor row in range(num_rows) : Loop ini digunakan untuk iterasi melalui setiap baris dalam transposed_matrix untuk kolom yang saat ini sedang diproses oleh loop luar\nnum_rows : Jumlah baris dalam transposed_matrix Ini mengontrol jumlah iterasi, memastikan bahwa setiap baris dalam kolom yang sedang diproses dipertimbangkan\ntransposed_matrix[row][col] : Mengakses elemen pada baris row dan kolom col dalam matriks\ndecrypted_text +=: Operator += : Menambahkan karakter ke string decrypted_text\n\n\nMencetak hasil teks terdeskripsi\n\n    print(\"Teks terdekripsi setelah membaca secara berurutan:\")\n    print(decrypted_text)\nHasil Decrypted :\nTENTUKANPRIORITASANDASEBABKITATIDAKDAPATMENGERJAKANSEMUANYAX",
    "crumbs": [
      "Kriptografi Modern",
      "1. Stream Cipher"
    ]
  },
  {
    "objectID": "10_DES.html",
    "href": "10_DES.html",
    "title": "2. DES",
    "section": "",
    "text": "Skema Global DES\nKeterangan :",
    "crumbs": [
      "Kriptografi Modern",
      "2. DES"
    ]
  },
  {
    "objectID": "10_DES.html#implementasi-pada-python",
    "href": "10_DES.html#implementasi-pada-python",
    "title": "2. Data Encryption Standard",
    "section": "Implementasi Pada Python",
    "text": "Implementasi Pada Python\nMasukkan Plaintext\nCONTOH : TENTUKAN PRIORITAS ANDA SEBAB KITA TIDAK DAPAT MENGERJAKAN SEMUANYA X\nplainText = input(\"Plaintext : \")\nMasukkan Kunci\nCONTOH KEY : 5\nrouteKey = int(input(\"Kunci: \"))\nMenghapus Spasi\ncleanPlainTeks = plainTeks.replace(\" \", \"\")\nprint(cleanPlainTeks)\n\nProses Enkripsi\n\nMenyusun teks yang sudah dibersihkan ke dalam sebuah matriks dengan kolom sebagai jumlah kolom atau lebar matriks\n\n    kolom = routeKey\n    matrix = []\n    panjang = len(cleanPlainTeks)\n    temp = panjang/kolom\n    bulat = round(temp)\n\n    if temp - bulat == 0:\n        jml_baris = bulat\n    else:\n        if temp - bulat &lt; 0:\n            jml_baris = bulat\n        else:\n            jml_baris = bulat + 1\n    print(jml_baris)\nFor More Detail :\n\nkolom = routeKey : Menetapkan jumlah kolom pada matriks dengan nilai routeKey\nmatrix = [] : Menginisialisasi sebuah list kosong yang akan digunakan untuk menyimpan elemen-elemen matriks\npanjang = len(cleanPlainTeks) : Menghitung panjang teks yang sudah dibersihkan\ntemp = panjang/kolom : Menghitung berapa banyak baris yang diperlukan dengan membagi panjang teks dengan jumlah kolom dan menyimpan hasilnya dalam variabel temp\nbulat = round(temp) : Membulatkan hasil pembagian temp ke angka terdekat dan menyimpannya ke dalam variabel bulat\ntemp - bulat == 0 : hasil pembagian tepat bulat, maka jml_baris diambil dari bulat\ntemp - bulat &lt; 0 : hasil pembagian kurang dari bulat (mungkin karena temp lebih kecil dari bulat), dan juga mengambil jml_baris dari bulat\njml_baris = bulat + 1 : Jika kondisi sebelumnya tidak terpenuhi, maka perlu satu baris tambahan\n\n\nMembuat sebuah matriks (matrix) yang berisi teks yang sudah dibersihkan (cleanPlainTeks) menggunakan nilai jml_baris dan kolom yang telah dihitung sebelumnya\n\n    for i in range(jml_baris):\n        row = []\n        for j in range(kolom):\n            if i * kolom + j &lt; len(cleanPlainTeks):\n                elemen = cleanPlainTeks[i * kolom + j]\n            else:\n                elemen = \" \"\n            row.append(elemen)\n        matrix.append(row)\nFor More Detail :\n\nfor i in range(jml_baris) : Loop ini mengiterasi dari 0 hingga jml_baris - 1, yang berarti setiap iterasi mewakili satu baris dalam matriks\nrow = [] : Membuat list kosong row yang akan menyimpan elemen-elemen untuk satu baris matriks\nfor j in range(kolom) : Loop ini mengiterasi dari 0 hingga kolom - 1, yang berarti setiap iterasi mewakili satu kolom dalam matriks\nif i * kolom + j &lt; len(cleanPlainTeks) : Memastikan bahwa tidak melebihi panjang dari teks yang telah dibersihkan pada saat mengakses elemen cleanPlainTeks untuk dimasukkan ke dalam matrix\nelemen = x[i * kolom + j] : Jika ya, Mengambil elemen dari teks x pada posisi i * kolom + j\nelemen = \" \" : Jika tidak, Mengisi elemen dengan spasi kosong jika indeks berada di luar panjang teks x -row.append(elemen) : Menambahkan elemen yang telah ditentukan (baik dari x atau spasi kosong) ke list row\nmatrix.append(row) : Menambahkan list row yang berisi elemen-elemen satu baris ke dalam list matrix\n\n\nMencetak matrix\n\n    print(\"Matriks yang Anda buat:\")\n    for row in matrix:\n        print(row)\n\nMenghasilkan matriks transpose dari matrix yang telah dibuat\n\n    transposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\n    for row in transposed_matrix:\n        print(row)\nFor More Detail :\n\nrow[i] for row in matrix : Menghasilkan list elemen ke-i dari setiap baris dalam matrix\nfor i in range(len(matrix[0]))] : Mengiterasi setiap indeks kolom dari matrix dan membentuk baris baru dari elemen-elemen tersebut\nfor row in transposed_matrix : Loop ini mengiterasi melalui setiap baris dalam transposed_matrix\nprint(row) : Mencetak matriks transpose dari matrix\n\n\nString kosong yang akan digunakan untuk menyimpan teks yang terenkripsi\n\n    encrypted_text = \"\"\n\nMenandai batas awal dan akhir dari baris dan kolom pada matriks transpose\n\n    start_row, end_row = len(transposed_matrix) - 1, 0\n    start_col, end_col = len(transposed_matrix[0]) - 1, 0\n\nMengambil baris dari kanan ke kiri\n\n    while start_row &gt;= end_row and start_col &gt;= end_col:\n        for i in range(start_col, end_col - 1, -1):\n            encrypted_text += transposed_matrix[start_row][i]\n\n        start_row -= 1\nFor More Detail :\n\nwhile start_row &gt;= end_row and start_col &gt;= end_col : loop while yang berjalan selama start_row lebih besar dari atau sama dengan end_row dan start_col lebih besar dari atau sama dengan end_col\nfor i in range(start_col, end_col - 1, -1) : Loop ini mengiterasi dari kolom paling kanan (start_col) ke kolom paling kiri (end_col - 1)\nencrypted_text += transposed_matrix[start_row][i] : Menambahkan elemen dari baris start_row dan kolom i ke encrypted_text\nstart_row -= 1 : Mengurangi start_row untuk bergerak ke baris berikutnya ke atas\n\n\nMengambil kolom dari atas ke bawah\n\n    for i in range(start_row, end_row - 1, -1):\n            encrypted_text += transposed_matrix[i][end_col]\n\n        end_col += 1\nFor More Detail :\n\nfor i in range(start_row, end_row - 1, -1) : Loop ini mengiterasi dari baris start_row ke baris end_row - 1\nencrypted_text += transposed_matrix[i][end_col] : Menambahkan elemen dari baris i dan kolom end_col ke encrypted_text\nend_col += 1 : Menambahkan end_col untuk bergerak ke kolom berikutnya ke kiri.\n\n\nMengecek jika sudah mencapai kolom terakhir\n\n    if start_col &lt; end_col:\n            break\nFor More Detail :\n\nif start_col &lt; end_col: : Mengecek apakah start_col lebih kecil dari end_col\nbreak : Jika ya, keluar dari loop while.\n\n\nMengambil baris dari kiri ke kanan\n\n    for i in range(end_col, start_col + 1):\n            encrypted_text += transposed_matrix[end_row][i]\n\n        end_row += 1\nFor More Detail :\n\nfor i in range(end_col, start_col + 1) : Loop ini mengiterasi dari kolom end_col ke kolom start_col + 1\nencrypted_text += transposed_matrix[end_row][i] : Menambahkan elemen dari baris end_row dan kolom i ke encrypted_text\nend_row += 1 : Menambahkan end_row untuk bergerak ke baris berikutnya ke bawah.\n\n\nMengecek Jika Sudah Mencapai Baris Terakhir\n\n    if start_row &lt; end_row:\n            break\nFor More Detail :\n\nif start_row &lt; end_row : Mengecek apakah start_row lebih kecil dari end_row\nbreak : Jika ya, keluar dari loop while\n\n\nMengambil kolom dari bawah ke atas\n\n    for i in range(end_row, start_row + 1):\n            encrypted_text += transposed_matrix[i][start_col]\n\n        start_col -= 1\nFor More Detail :\n\nfor i in range(end_row, start_row + 1) : Loop ini mengiterasi dari baris end_row ke baris start_row + 1\nencrypted_text += transposed_matrix[i][start_col] : Menambahkan elemen dari baris i dan kolom start_col ke encrypted_text\nstart_col -= 1 : Mengurangi start_col untuk bergerak ke kolom berikutnya ke kanan\n\n\nMencetak teks terenkripsi (ciphertext)\n\nprint(\"Teks terenkripsi dengan pola spiral: \", encrypted_text[:length])\nFor More Detail :\n\nencrypted_text[:length]) : Memotong encrypted_text hingga panjang teks asli (length) untuk memastikan panjangnya sama dengan teks asli\n\nHASIL CIPHERTEXT : XUAETKAADTRUTNETKIAABTDMRNANYAMKGAATBNIPNAOSSKIAEJSEANPDIEAR\n\n\nProses Dekripsi\nMasukkan Ciphertext\ncipherText = input(\"cipher : \")\nMasukkan kunci\nrouteKey = int(input(\"Kunci: \"))\n\nMenentukan jumlah baris yang dibutuhkan untuk membentuk sebuah matriks dengan jumlah kolom yang telah ditentukan (routeKey). Matriks ini akan berisi teks x yang telah dibersihkan\n\n    kolom = routeKey\n    matrix = []\n    panjang = len(x)\n    temp = panjang/kolom\n    length = len(x)\n    bulat = round(temp)\n\n    if temp - bulat == 0:\n        jml_baris = bulat\n    else:\n        if temp - bulat &lt; 0:\n            jml_baris = bulat\n        else:\n            jml_baris = bulat + 1\n    print(jml_baris)\nFor More Detail :\n\nkolom = routeKey : Menetapkan jumlah kolom pada matriks dengan nilai routeKey\nmatrix = [] : Menginisialisasi sebuah list kosong yang akan digunakan untuk menyimpan elemen-elemen matriks\npanjang = len(x) : Menyimpan panjang dari teks x ke dalam variabel panjang\ntemp = panjang/kolom : Menghitung berapa banyak baris yang diperlukan dengan membagi panjang teks dengan jumlah kolom dan menyimpan hasilnya dalam variabel temp\nlength = len(x) : Menyimpan panjang teks x ke dalam variabel length\nbulat = round(temp) : Membulatkan hasil pembagian temp ke angka terdekat dan menyimpannya ke dalam variabel bulat\n\n\nMembangun matriks 2D yang berisi teks x yang telah dibersihkan (tanpa spasi), Matriks ini akan memiliki jml_baris baris dan kolom kolom\n\n    for i in range(jml_baris):\n        row = []\n        for j in range(kolom):\n            if i * kolom + j &lt; len(x):\n                elemen = [i * kolom + j]\n            else:\n                elemen = \" \"\n            row.append(elemen)\n        matrix.append(row)\nFor More Detail :\n\nfor i in range(jml_baris) : Loop ini mengiterasi dari 0 hingga jml_baris - 1, yang berarti setiap iterasi mewakili satu baris dalam matriks\nrow = [] : Membuat list kosong row yang akan menyimpan elemen-elemen untuk satu baris matriks\nfor j in range(kolom) : Loop ini mengiterasi dari 0 hingga kolom - 1, yang berarti setiap iterasi mewakili satu kolom dalam matriks\nif i * kolom + j &lt; len(x) : Mengecek apakah indeks (dihitung sebagai i * kolom + j) berada dalam rentang panjang teks x\nelemen = x[i * kolom + j] : Jika ya, Mengambil elemen dari teks x pada posisi i * kolom + j\nelemen = \" \" : Jika tidak, Mengisi elemen dengan spasi kosong jika indeks berada di luar panjang teks x -row.append(elemen) : Menambahkan elemen yang telah ditentukan (baik dari x atau spasi kosong) ke list row\nmatrix.append(row) : Menambahkan list row yang berisi elemen-elemen satu baris ke dalam list matrix\n\n\nMencetak matriks yang telah dibuat\n\n    print(\"Matriks yang Anda buat:\")\n    for row in matrix:\n        print(row)\n\nMembuat dan mencetak matriks transpose\n\n    transposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\n    for row in transposed_matrix:\n        print(row)\nFor More Detail :\n\nrow[i] for row in matrix : Menghasilkan list elemen ke-i dari setiap baris dalam matrix\nfor i in range(len(matrix[0]))] : Mengiterasi setiap indeks kolom dari matrix dan membentuk baris baru dari elemen-elemen tersebut\nfor row in transposed_matrix : Loop ini mengiterasi melalui setiap baris dalam transposed_matrix\n\n\nMengatur batas-batas dan kontrol iterasi saat mengisi transposed_matrix dalam pola spiral dengan karakter-karakter dari teks x\n\n    start_row, end_row = len(transposed_matrix) - 1, 0\n    start_col, end_col = len(transposed_matrix[0]) - 1, 0\n    text_index = 0\nFor More Detail :\n\nstart_row : Mengendalikan pengisian dari baris terakhir ke atas\nend_row : Mengendalikan pengisian dari baris pertama ke bawah\nend_row = 0 : Menetapkan indeks baris awal ke 0, yang berarti kita mulai dari baris pertama\nlen(transposed_matrix) : Memberikan jumlah baris dalam transposed_matrix\nMengurangkan 1 untuk mendapatkan indeks baris terakhir dari matriks transpose\nstart_col : Mengendalikan pengisian dari kolom terakhir ke kiri, sedangkan\nend_col : Mengendalikan pengisian dari kolom pertama ke kanan\nlen(transposed_matrix[0]) : Memberikan jumlah kolom dalam transposed_matrix\nMengurangkan 1 untuk mendapatkan indeks kolom terakhir dari matriks transpose\nend_col = 0 : Menetapkan indeks kolom awal ke 0, yang berarti kita mulai dari kolom pertama\ntext_index : Melacak posisi karakter dalam teks x yang sedang diproses\n\n\nMengisi baris pertama dari kanan ke kiri\n\n    while start_row &gt;= end_row and start_col &gt;= end_col:\n        # Fill the first row from the remaining rows\n        for i in range(start_col, end_col - 1, -1):\n            if text_index &lt; len(x):\n                transposed_matrix[start_row][i] = x[text_index]\n                text_index += 1\n\n        start_row -= 1\nFor More Detail :\n\nstart_col dan end_col : menentukan rentang kolom yang akan diisi\ntext_index : mengambil karakter dari teks x.\nTransposed_matrix[start_row][i] : Setiap karakter yang diambil dari x dimasukkan ke dalam posisi yang sesuai di t.\n\n\nMengisi kolom terakhir dari baris yang tersisa dalam matriks dengan karakter dari x dalam urutan spiral\n\n    for i in range(start_row, end_row - 1, -1):\n            if text_index &lt; len(x):\n                transposed_matrix[i][end_col] = x[text_index]\n                text_index += 1\n\n        end_col += 1\nFor More Detail :\n\nfor i in range(start_row, end_row - 1, -1) : Loop ini digunakan untuk iterasi melalui baris-baris dalam matriks dari start_row ke end_row - 1 dalam urutan menurun\nstart_row : Posisi baris awal untuk iterasi\nend_row - 1 : Posisi baris akhir (tidak termasuk) untuk iterasi\n-1 : Menunjukkan bahwa iterasi dilakukan secara menurun\nif text_index &lt; len(cipherText) : Kondisi ini memastikan bahwa indeks text_index masih dalam batas panjang cipherText\ntransposed_matrix[i][end_col] : Menunjukkan posisi kolom end_col dalam baris i dari matriks yang sedang diisi\ncipherText[text_index] : Karakter dari cipherText pada indeks text_index\ntext_index += 1 : Setelah menempatkan karakter dari cipherText ke dalam transposed_matrix, nilai text_index dinaikkan sebesar 1 untuk mempersiapkan karakter berikutnya pada iterasi selanjutnya\nend_col += 1 : Setelah menyelesaikan iterasi untuk mengisi kolom terakhir dari baris yang tersisa, end_col dinaikkan sebesar 1 untuk mempersempit batas kolom yang akan diisi pada iterasi berikutnya\n\n\nMenentukkan apakah batas kolom telah bertemu atau melewati satu sama lain, yang berarti bahwa semua kolom yang perlu diisi sudah selesai diproses\n\n    if start_col &lt; end_col:\n            break\n\nMengisi baris terakhir dari kolom yang tersisa dalam matriks dengan karakter dari x dalam urutan spiral.\n\n    for i in range(end_col, start_col + 1):\n            if text_index &lt; len(x):\n                transposed_matrix[end_row][i] = x[text_index]\n                text_index += 1\n\n        end_row += 1\nFor More Detail :\n\nfor i in range(end_col, start_col + 1): Loop ini digunakan untuk iterasi melalui kolom dari end_col ke start_col + 1\nend_col: Posisi kolom awal untuk iterasi\nstart_col + 1: Posisi kolom akhir (tidak termasuk) untuk iterasi, Menambah 1 untuk memasukkan start_col dalam iterasi\nif text_index &lt; len(x) : Kondisi ini memastikan bahwa indeks\ntext_index : Masih dalam batas panjang x. Hal ini untuk menghindari akses indeks yang tidak valid dari x\ntransposed_matrix[end_row][i] = x[text_index] Menetapkan karakter dari x pada posisi indeks text_index ke posisi [end_row][i] dalam transposed_matrix\ntransposed_matrix[end_row][i]: Menunjukkan posisi kolom i dalam baris end_row dari matriks yang sedang diisi.\nx[text_index]: Karakter dari x pada indeks text_index\ntext_index += 1 Setelah menempatkan karakter dari x ke dalam transposed_matrix, nilai text_index dinaikkan sebesar 1 untuk mempersiapkan karakter berikutnya pada iterasi selanjutnya\nend_row += 1 Setelah menyelesaikan iterasi untuk mengisi baris terakhir dari kolom yang tersisa, batas baris akhir (end_row) dinaikkan sebesar 1 untuk mempersempit batas baris yang akan diisi pada iterasi berikutnya\n\n\nMenghentikan loop while jika batas baris bertemu atau melewati satu sama lain, menandakan bahwa pengisian matriks dalam pola spiral sudah selesai\n\n    if start_row &lt; end_row:\n            break\n\nMengisi baris terakhir dari kolom yang tersisa dalam matriks dengan karakter dari x dalam urutan spiral\n\n    for i in range(end_row, start_row + 1):\n            if text_index &lt; len(x):\n                transposed_matrix[i][start_col] = x[text_index]\n                text_index += 1\n\n        start_col -= 1\nFor More Detail :\n\nfor i in range(end_row, start_row + 1) : Loop ini digunakan untuk iterasi melalui baris dari end_row ke start_row + 1 dalam urutan meningkat\nend_row : Posisi baris awal untuk iterasi\nstart_row + 1 : Posisi baris akhir (tidak termasuk) untuk iterasi, Menambah 1 untuk memasukkan start_row dalam iterasi\nif text_index &lt; len(x) : Kondisi ini memastikan bahwa indeks text_index masih dalam batas panjang x\ntransposed_matrix[i][start_col] : Menunjukkan posisi kolom start_col dalam baris i dari matriks yang sedang diisi\nx[text_index] : Karakter dari x pada indeks text_index\ntext_index += 1 : Nilai text_index dinaikkan sebesar 1 untuk mempersiapkan karakter berikutnya pada iterasi selanjutnya\nstart_col -= 1 : Batas kolom awal (start_col) dikurangi sebesar 1 untuk mempersempit batas kolom yang akan diisi pada iterasi berikutnya\n\n\nMencetak matriks yang telah diisi dengan ciphertext\n\n    print(\"Matriks setelah diisi dengan cipher secara spiral:\")\n    for row in transposed_matrix:\n        print(row)\n\nString kosong untuk menyimpan hasil teks yang telah didekripsi\n\n    decrypted_text = \"\"\n\nMenyimpan jumlah baris dari transposed_matrix dalam variabel num_rows\n\n    num_rows = len(transposed_matrix)\n\nMenghitung jumlah kolom dalam transposed_matrix\n\n    num_cols = len(transposed_matrix[0])\n\nMenggabungkan karakter-karakter dari transposed_matrix ke dalam decrypted_text dengan membaca matriks secara kolom demi kolom\n\n    for col in range(num_cols):  \n        for row in range(num_rows):  \n            decrypted_text += transposed_matrix[row][col]\nFor More Detail :\n\nfor col in range(num_cols): Loop for ini digunakan untuk iterasi melalui setiap kolom dalam transposed_matrix.\nnum_cols : Jumlah kolom dalam transposed_matrix Ini mengontrol jumlah iterasi, memastikan bahwa setiap kolom dalam matriks diproses\nfor row in range(num_rows) : Loop ini digunakan untuk iterasi melalui setiap baris dalam transposed_matrix untuk kolom yang saat ini sedang diproses oleh loop luar\nnum_rows : Jumlah baris dalam transposed_matrix Ini mengontrol jumlah iterasi, memastikan bahwa setiap baris dalam kolom yang sedang diproses dipertimbangkan\ntransposed_matrix[row][col] : Mengakses elemen pada baris row dan kolom col dalam matriks\ndecrypted_text +=: Operator += : Menambahkan karakter ke string decrypted_text\n\n\nMencetak hasil teks terdeskripsi\n\n    print(\"Teks terdekripsi setelah membaca secara berurutan:\")\n    print(decrypted_text)\nHasil Decrypted :\nTENTUKANPRIORITASANDASEBABKITATIDAKDAPATMENGERJAKANSEMUANYAX",
    "crumbs": [
      "Kriptografi Modern",
      "2. Data Encryption Standard"
    ]
  },
  {
    "objectID": "11_3DES.html",
    "href": "11_3DES.html",
    "title": "3. 3DES",
    "section": "",
    "text": "Analogi Transposisi Route\nMari kita gunakan analogi kelas dengan siswa yang duduk di kursi dalam bentuk grid untuk menjelaskan algoritma transposisi route menggunakan pola spiral.\nBayangkan kamu adalah guru yang ingin mengatur ulang tempat duduk siswa sesuai pola spiral. Anda mulai dengan siswa pertama di sudut kiri atas, lalu bergerak ke kanan hingga akhir baris, turun ke baris berikutnya di sebelah kanan, kemudian bergerak ke kiri, dan seterusnya, sampai Anda kembali ke tengah grid. Berikut langkahnya :",
    "crumbs": [
      "Kriptografi Modern",
      "3. 3DES"
    ]
  },
  {
    "objectID": "11_3DES.html#implementasi-pada-python",
    "href": "11_3DES.html#implementasi-pada-python",
    "title": "3. 3DES",
    "section": "Implementasi Pada Python",
    "text": "Implementasi Pada Python\nMasukkan Plaintext\nCONTOH : TENTUKAN PRIORITAS ANDA SEBAB KITA TIDAK DAPAT MENGERJAKAN SEMUANYA X\nplainText = input(\"Plaintext : \")\nMasukkan Kunci\nCONTOH KEY : 5\nrouteKey = int(input(\"Kunci: \"))\nMenghapus Spasi\ncleanPlainTeks = plainTeks.replace(\" \", \"\")\nprint(cleanPlainTeks)\n\nProses Enkripsi\n\nMenyusun teks yang sudah dibersihkan ke dalam sebuah matriks dengan kolom sebagai jumlah kolom atau lebar matriks\n\n    kolom = routeKey\n    matrix = []\n    panjang = len(cleanPlainTeks)\n    temp = panjang/kolom\n    bulat = round(temp)\n\n    if temp - bulat == 0:\n        jml_baris = bulat\n    else:\n        if temp - bulat &lt; 0:\n            jml_baris = bulat\n        else:\n            jml_baris = bulat + 1\n    print(jml_baris)\nFor More Detail :\n\nkolom = routeKey : Menetapkan jumlah kolom pada matriks dengan nilai routeKey\nmatrix = [] : Menginisialisasi sebuah list kosong yang akan digunakan untuk menyimpan elemen-elemen matriks\npanjang = len(cleanPlainTeks) : Menghitung panjang teks yang sudah dibersihkan\ntemp = panjang/kolom : Menghitung berapa banyak baris yang diperlukan dengan membagi panjang teks dengan jumlah kolom dan menyimpan hasilnya dalam variabel temp\nbulat = round(temp) : Membulatkan hasil pembagian temp ke angka terdekat dan menyimpannya ke dalam variabel bulat\ntemp - bulat == 0 : hasil pembagian tepat bulat, maka jml_baris diambil dari bulat\ntemp - bulat &lt; 0 : hasil pembagian kurang dari bulat (mungkin karena temp lebih kecil dari bulat), dan juga mengambil jml_baris dari bulat\njml_baris = bulat + 1 : Jika kondisi sebelumnya tidak terpenuhi, maka perlu satu baris tambahan\n\n\nMembuat sebuah matriks (matrix) yang berisi teks yang sudah dibersihkan (cleanPlainTeks) menggunakan nilai jml_baris dan kolom yang telah dihitung sebelumnya\n\n    for i in range(jml_baris):\n        row = []\n        for j in range(kolom):\n            if i * kolom + j &lt; len(cleanPlainTeks):\n                elemen = cleanPlainTeks[i * kolom + j]\n            else:\n                elemen = \" \"\n            row.append(elemen)\n        matrix.append(row)\nFor More Detail :\n\nfor i in range(jml_baris) : Loop ini mengiterasi dari 0 hingga jml_baris - 1, yang berarti setiap iterasi mewakili satu baris dalam matriks\nrow = [] : Membuat list kosong row yang akan menyimpan elemen-elemen untuk satu baris matriks\nfor j in range(kolom) : Loop ini mengiterasi dari 0 hingga kolom - 1, yang berarti setiap iterasi mewakili satu kolom dalam matriks\nif i * kolom + j &lt; len(cleanPlainTeks) : Memastikan bahwa tidak melebihi panjang dari teks yang telah dibersihkan pada saat mengakses elemen cleanPlainTeks untuk dimasukkan ke dalam matrix\nelemen = x[i * kolom + j] : Jika ya, Mengambil elemen dari teks x pada posisi i * kolom + j\nelemen = \" \" : Jika tidak, Mengisi elemen dengan spasi kosong jika indeks berada di luar panjang teks x -row.append(elemen) : Menambahkan elemen yang telah ditentukan (baik dari x atau spasi kosong) ke list row\nmatrix.append(row) : Menambahkan list row yang berisi elemen-elemen satu baris ke dalam list matrix\n\n\nMencetak matrix\n\n    print(\"Matriks yang Anda buat:\")\n    for row in matrix:\n        print(row)\n\nMenghasilkan matriks transpose dari matrix yang telah dibuat\n\n    transposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\n    for row in transposed_matrix:\n        print(row)\nFor More Detail :\n\nrow[i] for row in matrix : Menghasilkan list elemen ke-i dari setiap baris dalam matrix\nfor i in range(len(matrix[0]))] : Mengiterasi setiap indeks kolom dari matrix dan membentuk baris baru dari elemen-elemen tersebut\nfor row in transposed_matrix : Loop ini mengiterasi melalui setiap baris dalam transposed_matrix\nprint(row) : Mencetak matriks transpose dari matrix\n\n\nString kosong yang akan digunakan untuk menyimpan teks yang terenkripsi\n\n    encrypted_text = \"\"\n\nMenandai batas awal dan akhir dari baris dan kolom pada matriks transpose\n\n    start_row, end_row = len(transposed_matrix) - 1, 0\n    start_col, end_col = len(transposed_matrix[0]) - 1, 0\n\nMengambil baris dari kanan ke kiri\n\n    while start_row &gt;= end_row and start_col &gt;= end_col:\n        for i in range(start_col, end_col - 1, -1):\n            encrypted_text += transposed_matrix[start_row][i]\n\n        start_row -= 1\nFor More Detail :\n\nwhile start_row &gt;= end_row and start_col &gt;= end_col : loop while yang berjalan selama start_row lebih besar dari atau sama dengan end_row dan start_col lebih besar dari atau sama dengan end_col\nfor i in range(start_col, end_col - 1, -1) : Loop ini mengiterasi dari kolom paling kanan (start_col) ke kolom paling kiri (end_col - 1)\nencrypted_text += transposed_matrix[start_row][i] : Menambahkan elemen dari baris start_row dan kolom i ke encrypted_text\nstart_row -= 1 : Mengurangi start_row untuk bergerak ke baris berikutnya ke atas\n\n\nMengambil kolom dari atas ke bawah\n\n    for i in range(start_row, end_row - 1, -1):\n            encrypted_text += transposed_matrix[i][end_col]\n\n        end_col += 1\nFor More Detail :\n\nfor i in range(start_row, end_row - 1, -1) : Loop ini mengiterasi dari baris start_row ke baris end_row - 1\nencrypted_text += transposed_matrix[i][end_col] : Menambahkan elemen dari baris i dan kolom end_col ke encrypted_text\nend_col += 1 : Menambahkan end_col untuk bergerak ke kolom berikutnya ke kiri.\n\n\nMengecek jika sudah mencapai kolom terakhir\n\n    if start_col &lt; end_col:\n            break\nFor More Detail :\n\nif start_col &lt; end_col: : Mengecek apakah start_col lebih kecil dari end_col\nbreak : Jika ya, keluar dari loop while.\n\n\nMengambil baris dari kiri ke kanan\n\n    for i in range(end_col, start_col + 1):\n            encrypted_text += transposed_matrix[end_row][i]\n\n        end_row += 1\nFor More Detail :\n\nfor i in range(end_col, start_col + 1) : Loop ini mengiterasi dari kolom end_col ke kolom start_col + 1\nencrypted_text += transposed_matrix[end_row][i] : Menambahkan elemen dari baris end_row dan kolom i ke encrypted_text\nend_row += 1 : Menambahkan end_row untuk bergerak ke baris berikutnya ke bawah.\n\n\nMengecek Jika Sudah Mencapai Baris Terakhir\n\n    if start_row &lt; end_row:\n            break\nFor More Detail :\n\nif start_row &lt; end_row : Mengecek apakah start_row lebih kecil dari end_row\nbreak : Jika ya, keluar dari loop while\n\n\nMengambil kolom dari bawah ke atas\n\n    for i in range(end_row, start_row + 1):\n            encrypted_text += transposed_matrix[i][start_col]\n\n        start_col -= 1\nFor More Detail :\n\nfor i in range(end_row, start_row + 1) : Loop ini mengiterasi dari baris end_row ke baris start_row + 1\nencrypted_text += transposed_matrix[i][start_col] : Menambahkan elemen dari baris i dan kolom start_col ke encrypted_text\nstart_col -= 1 : Mengurangi start_col untuk bergerak ke kolom berikutnya ke kanan\n\n\nMencetak teks terenkripsi (ciphertext)\n\nprint(\"Teks terenkripsi dengan pola spiral: \", encrypted_text[:length])\nFor More Detail :\n\nencrypted_text[:length]) : Memotong encrypted_text hingga panjang teks asli (length) untuk memastikan panjangnya sama dengan teks asli\n\nHASIL CIPHERTEXT : XUAETKAADTRUTNETKIAABTDMRNANYAMKGAATBNIPNAOSSKIAEJSEANPDIEAR\n\n\nProses Dekripsi\nMasukkan Ciphertext\ncipherText = input(\"cipher : \")\nMasukkan kunci\nrouteKey = int(input(\"Kunci: \"))\n\nMenentukan jumlah baris yang dibutuhkan untuk membentuk sebuah matriks dengan jumlah kolom yang telah ditentukan (routeKey). Matriks ini akan berisi teks x yang telah dibersihkan\n\n    kolom = routeKey\n    matrix = []\n    panjang = len(x)\n    temp = panjang/kolom\n    length = len(x)\n    bulat = round(temp)\n\n    if temp - bulat == 0:\n        jml_baris = bulat\n    else:\n        if temp - bulat &lt; 0:\n            jml_baris = bulat\n        else:\n            jml_baris = bulat + 1\n    print(jml_baris)\nFor More Detail :\n\nkolom = routeKey : Menetapkan jumlah kolom pada matriks dengan nilai routeKey\nmatrix = [] : Menginisialisasi sebuah list kosong yang akan digunakan untuk menyimpan elemen-elemen matriks\npanjang = len(x) : Menyimpan panjang dari teks x ke dalam variabel panjang\ntemp = panjang/kolom : Menghitung berapa banyak baris yang diperlukan dengan membagi panjang teks dengan jumlah kolom dan menyimpan hasilnya dalam variabel temp\nlength = len(x) : Menyimpan panjang teks x ke dalam variabel length\nbulat = round(temp) : Membulatkan hasil pembagian temp ke angka terdekat dan menyimpannya ke dalam variabel bulat\n\n\nMembangun matriks 2D yang berisi teks x yang telah dibersihkan (tanpa spasi), Matriks ini akan memiliki jml_baris baris dan kolom kolom\n\n    for i in range(jml_baris):\n        row = []\n        for j in range(kolom):\n            if i * kolom + j &lt; len(x):\n                elemen = [i * kolom + j]\n            else:\n                elemen = \" \"\n            row.append(elemen)\n        matrix.append(row)\nFor More Detail :\n\nfor i in range(jml_baris) : Loop ini mengiterasi dari 0 hingga jml_baris - 1, yang berarti setiap iterasi mewakili satu baris dalam matriks\nrow = [] : Membuat list kosong row yang akan menyimpan elemen-elemen untuk satu baris matriks\nfor j in range(kolom) : Loop ini mengiterasi dari 0 hingga kolom - 1, yang berarti setiap iterasi mewakili satu kolom dalam matriks\nif i * kolom + j &lt; len(x) : Mengecek apakah indeks (dihitung sebagai i * kolom + j) berada dalam rentang panjang teks x\nelemen = x[i * kolom + j] : Jika ya, Mengambil elemen dari teks x pada posisi i * kolom + j\nelemen = \" \" : Jika tidak, Mengisi elemen dengan spasi kosong jika indeks berada di luar panjang teks x -row.append(elemen) : Menambahkan elemen yang telah ditentukan (baik dari x atau spasi kosong) ke list row\nmatrix.append(row) : Menambahkan list row yang berisi elemen-elemen satu baris ke dalam list matrix\n\n\nMencetak matriks yang telah dibuat\n\n    print(\"Matriks yang Anda buat:\")\n    for row in matrix:\n        print(row)\n\nMembuat dan mencetak matriks transpose\n\n    transposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\n    for row in transposed_matrix:\n        print(row)\nFor More Detail :\n\nrow[i] for row in matrix : Menghasilkan list elemen ke-i dari setiap baris dalam matrix\nfor i in range(len(matrix[0]))] : Mengiterasi setiap indeks kolom dari matrix dan membentuk baris baru dari elemen-elemen tersebut\nfor row in transposed_matrix : Loop ini mengiterasi melalui setiap baris dalam transposed_matrix\n\n\nMengatur batas-batas dan kontrol iterasi saat mengisi transposed_matrix dalam pola spiral dengan karakter-karakter dari teks x\n\n    start_row, end_row = len(transposed_matrix) - 1, 0\n    start_col, end_col = len(transposed_matrix[0]) - 1, 0\n    text_index = 0\nFor More Detail :\n\nstart_row : Mengendalikan pengisian dari baris terakhir ke atas\nend_row : Mengendalikan pengisian dari baris pertama ke bawah\nend_row = 0 : Menetapkan indeks baris awal ke 0, yang berarti kita mulai dari baris pertama\nlen(transposed_matrix) : Memberikan jumlah baris dalam transposed_matrix\nMengurangkan 1 untuk mendapatkan indeks baris terakhir dari matriks transpose\nstart_col : Mengendalikan pengisian dari kolom terakhir ke kiri, sedangkan\nend_col : Mengendalikan pengisian dari kolom pertama ke kanan\nlen(transposed_matrix[0]) : Memberikan jumlah kolom dalam transposed_matrix\nMengurangkan 1 untuk mendapatkan indeks kolom terakhir dari matriks transpose\nend_col = 0 : Menetapkan indeks kolom awal ke 0, yang berarti kita mulai dari kolom pertama\ntext_index : Melacak posisi karakter dalam teks x yang sedang diproses\n\n\nMengisi baris pertama dari kanan ke kiri\n\n    while start_row &gt;= end_row and start_col &gt;= end_col:\n        # Fill the first row from the remaining rows\n        for i in range(start_col, end_col - 1, -1):\n            if text_index &lt; len(x):\n                transposed_matrix[start_row][i] = x[text_index]\n                text_index += 1\n\n        start_row -= 1\nFor More Detail :\n\nstart_col dan end_col : menentukan rentang kolom yang akan diisi\ntext_index : mengambil karakter dari teks x.\nTransposed_matrix[start_row][i] : Setiap karakter yang diambil dari x dimasukkan ke dalam posisi yang sesuai di t.\n\n\nMengisi kolom terakhir dari baris yang tersisa dalam matriks dengan karakter dari x dalam urutan spiral\n\n    for i in range(start_row, end_row - 1, -1):\n            if text_index &lt; len(x):\n                transposed_matrix[i][end_col] = x[text_index]\n                text_index += 1\n\n        end_col += 1\nFor More Detail :\n\nfor i in range(start_row, end_row - 1, -1) : Loop ini digunakan untuk iterasi melalui baris-baris dalam matriks dari start_row ke end_row - 1 dalam urutan menurun\nstart_row : Posisi baris awal untuk iterasi\nend_row - 1 : Posisi baris akhir (tidak termasuk) untuk iterasi\n-1 : Menunjukkan bahwa iterasi dilakukan secara menurun\nif text_index &lt; len(cipherText) : Kondisi ini memastikan bahwa indeks text_index masih dalam batas panjang cipherText\ntransposed_matrix[i][end_col] : Menunjukkan posisi kolom end_col dalam baris i dari matriks yang sedang diisi\ncipherText[text_index] : Karakter dari cipherText pada indeks text_index\ntext_index += 1 : Setelah menempatkan karakter dari cipherText ke dalam transposed_matrix, nilai text_index dinaikkan sebesar 1 untuk mempersiapkan karakter berikutnya pada iterasi selanjutnya\nend_col += 1 : Setelah menyelesaikan iterasi untuk mengisi kolom terakhir dari baris yang tersisa, end_col dinaikkan sebesar 1 untuk mempersempit batas kolom yang akan diisi pada iterasi berikutnya\n\n\nMenentukkan apakah batas kolom telah bertemu atau melewati satu sama lain, yang berarti bahwa semua kolom yang perlu diisi sudah selesai diproses\n\n    if start_col &lt; end_col:\n            break\n\nMengisi baris terakhir dari kolom yang tersisa dalam matriks dengan karakter dari x dalam urutan spiral.\n\n    for i in range(end_col, start_col + 1):\n            if text_index &lt; len(x):\n                transposed_matrix[end_row][i] = x[text_index]\n                text_index += 1\n\n        end_row += 1\nFor More Detail :\n\nfor i in range(end_col, start_col + 1): Loop ini digunakan untuk iterasi melalui kolom dari end_col ke start_col + 1\nend_col: Posisi kolom awal untuk iterasi\nstart_col + 1: Posisi kolom akhir (tidak termasuk) untuk iterasi, Menambah 1 untuk memasukkan start_col dalam iterasi\nif text_index &lt; len(x) : Kondisi ini memastikan bahwa indeks\ntext_index : Masih dalam batas panjang x. Hal ini untuk menghindari akses indeks yang tidak valid dari x\ntransposed_matrix[end_row][i] = x[text_index] Menetapkan karakter dari x pada posisi indeks text_index ke posisi [end_row][i] dalam transposed_matrix\ntransposed_matrix[end_row][i]: Menunjukkan posisi kolom i dalam baris end_row dari matriks yang sedang diisi.\nx[text_index]: Karakter dari x pada indeks text_index\ntext_index += 1 Setelah menempatkan karakter dari x ke dalam transposed_matrix, nilai text_index dinaikkan sebesar 1 untuk mempersiapkan karakter berikutnya pada iterasi selanjutnya\nend_row += 1 Setelah menyelesaikan iterasi untuk mengisi baris terakhir dari kolom yang tersisa, batas baris akhir (end_row) dinaikkan sebesar 1 untuk mempersempit batas baris yang akan diisi pada iterasi berikutnya\n\n\nMenghentikan loop while jika batas baris bertemu atau melewati satu sama lain, menandakan bahwa pengisian matriks dalam pola spiral sudah selesai\n\n    if start_row &lt; end_row:\n            break\n\nMengisi baris terakhir dari kolom yang tersisa dalam matriks dengan karakter dari x dalam urutan spiral\n\n    for i in range(end_row, start_row + 1):\n            if text_index &lt; len(x):\n                transposed_matrix[i][start_col] = x[text_index]\n                text_index += 1\n\n        start_col -= 1\nFor More Detail :\n\nfor i in range(end_row, start_row + 1) : Loop ini digunakan untuk iterasi melalui baris dari end_row ke start_row + 1 dalam urutan meningkat\nend_row : Posisi baris awal untuk iterasi\nstart_row + 1 : Posisi baris akhir (tidak termasuk) untuk iterasi, Menambah 1 untuk memasukkan start_row dalam iterasi\nif text_index &lt; len(x) : Kondisi ini memastikan bahwa indeks text_index masih dalam batas panjang x\ntransposed_matrix[i][start_col] : Menunjukkan posisi kolom start_col dalam baris i dari matriks yang sedang diisi\nx[text_index] : Karakter dari x pada indeks text_index\ntext_index += 1 : Nilai text_index dinaikkan sebesar 1 untuk mempersiapkan karakter berikutnya pada iterasi selanjutnya\nstart_col -= 1 : Batas kolom awal (start_col) dikurangi sebesar 1 untuk mempersempit batas kolom yang akan diisi pada iterasi berikutnya\n\n\nMencetak matriks yang telah diisi dengan ciphertext\n\n    print(\"Matriks setelah diisi dengan cipher secara spiral:\")\n    for row in transposed_matrix:\n        print(row)\n\nString kosong untuk menyimpan hasil teks yang telah didekripsi\n\n    decrypted_text = \"\"\n\nMenyimpan jumlah baris dari transposed_matrix dalam variabel num_rows\n\n    num_rows = len(transposed_matrix)\n\nMenghitung jumlah kolom dalam transposed_matrix\n\n    num_cols = len(transposed_matrix[0])\n\nMenggabungkan karakter-karakter dari transposed_matrix ke dalam decrypted_text dengan membaca matriks secara kolom demi kolom\n\n    for col in range(num_cols):  \n        for row in range(num_rows):  \n            decrypted_text += transposed_matrix[row][col]\nFor More Detail :\n\nfor col in range(num_cols): Loop for ini digunakan untuk iterasi melalui setiap kolom dalam transposed_matrix.\nnum_cols : Jumlah kolom dalam transposed_matrix Ini mengontrol jumlah iterasi, memastikan bahwa setiap kolom dalam matriks diproses\nfor row in range(num_rows) : Loop ini digunakan untuk iterasi melalui setiap baris dalam transposed_matrix untuk kolom yang saat ini sedang diproses oleh loop luar\nnum_rows : Jumlah baris dalam transposed_matrix Ini mengontrol jumlah iterasi, memastikan bahwa setiap baris dalam kolom yang sedang diproses dipertimbangkan\ntransposed_matrix[row][col] : Mengakses elemen pada baris row dan kolom col dalam matriks\ndecrypted_text +=: Operator += : Menambahkan karakter ke string decrypted_text\n\n\nMencetak hasil teks terdeskripsi\n\n    print(\"Teks terdekripsi setelah membaca secara berurutan:\")\n    print(decrypted_text)\nHasil Decrypted :\nTENTUKANPRIORITASANDASEBABKITATIDAKDAPATMENGERJAKANSEMUANYAX",
    "crumbs": [
      "Kriptografi Modern",
      "3. 3DES"
    ]
  },
  {
    "objectID": "12_AES.html",
    "href": "12_AES.html",
    "title": "4. AES",
    "section": "",
    "text": "Analogi Transposisi Route\nMari kita gunakan analogi kelas dengan siswa yang duduk di kursi dalam bentuk grid untuk menjelaskan algoritma transposisi route menggunakan pola spiral.\nBayangkan kamu adalah guru yang ingin mengatur ulang tempat duduk siswa sesuai pola spiral. Anda mulai dengan siswa pertama di sudut kiri atas, lalu bergerak ke kanan hingga akhir baris, turun ke baris berikutnya di sebelah kanan, kemudian bergerak ke kiri, dan seterusnya, sampai Anda kembali ke tengah grid. Berikut langkahnya :",
    "crumbs": [
      "Kriptografi Modern",
      "4. AES"
    ]
  },
  {
    "objectID": "12_AES.html#implementasi-pada-python",
    "href": "12_AES.html#implementasi-pada-python",
    "title": "4. AES",
    "section": "Implementasi Pada Python",
    "text": "Implementasi Pada Python\nMasukkan Plaintext\nCONTOH : TENTUKAN PRIORITAS ANDA SEBAB KITA TIDAK DAPAT MENGERJAKAN SEMUANYA X\nplainText = input(\"Plaintext : \")\nMasukkan Kunci\nCONTOH KEY : 5\nrouteKey = int(input(\"Kunci: \"))\nMenghapus Spasi\ncleanPlainTeks = plainTeks.replace(\" \", \"\")\nprint(cleanPlainTeks)\n\nProses Enkripsi\n\nMenyusun teks yang sudah dibersihkan ke dalam sebuah matriks dengan kolom sebagai jumlah kolom atau lebar matriks\n\n    kolom = routeKey\n    matrix = []\n    panjang = len(cleanPlainTeks)\n    temp = panjang/kolom\n    bulat = round(temp)\n\n    if temp - bulat == 0:\n        jml_baris = bulat\n    else:\n        if temp - bulat &lt; 0:\n            jml_baris = bulat\n        else:\n            jml_baris = bulat + 1\n    print(jml_baris)\nFor More Detail :\n\nkolom = routeKey : Menetapkan jumlah kolom pada matriks dengan nilai routeKey\nmatrix = [] : Menginisialisasi sebuah list kosong yang akan digunakan untuk menyimpan elemen-elemen matriks\npanjang = len(cleanPlainTeks) : Menghitung panjang teks yang sudah dibersihkan\ntemp = panjang/kolom : Menghitung berapa banyak baris yang diperlukan dengan membagi panjang teks dengan jumlah kolom dan menyimpan hasilnya dalam variabel temp\nbulat = round(temp) : Membulatkan hasil pembagian temp ke angka terdekat dan menyimpannya ke dalam variabel bulat\ntemp - bulat == 0 : hasil pembagian tepat bulat, maka jml_baris diambil dari bulat\ntemp - bulat &lt; 0 : hasil pembagian kurang dari bulat (mungkin karena temp lebih kecil dari bulat), dan juga mengambil jml_baris dari bulat\njml_baris = bulat + 1 : Jika kondisi sebelumnya tidak terpenuhi, maka perlu satu baris tambahan\n\n\nMembuat sebuah matriks (matrix) yang berisi teks yang sudah dibersihkan (cleanPlainTeks) menggunakan nilai jml_baris dan kolom yang telah dihitung sebelumnya\n\n    for i in range(jml_baris):\n        row = []\n        for j in range(kolom):\n            if i * kolom + j &lt; len(cleanPlainTeks):\n                elemen = cleanPlainTeks[i * kolom + j]\n            else:\n                elemen = \" \"\n            row.append(elemen)\n        matrix.append(row)\nFor More Detail :\n\nfor i in range(jml_baris) : Loop ini mengiterasi dari 0 hingga jml_baris - 1, yang berarti setiap iterasi mewakili satu baris dalam matriks\nrow = [] : Membuat list kosong row yang akan menyimpan elemen-elemen untuk satu baris matriks\nfor j in range(kolom) : Loop ini mengiterasi dari 0 hingga kolom - 1, yang berarti setiap iterasi mewakili satu kolom dalam matriks\nif i * kolom + j &lt; len(cleanPlainTeks) : Memastikan bahwa tidak melebihi panjang dari teks yang telah dibersihkan pada saat mengakses elemen cleanPlainTeks untuk dimasukkan ke dalam matrix\nelemen = x[i * kolom + j] : Jika ya, Mengambil elemen dari teks x pada posisi i * kolom + j\nelemen = \" \" : Jika tidak, Mengisi elemen dengan spasi kosong jika indeks berada di luar panjang teks x -row.append(elemen) : Menambahkan elemen yang telah ditentukan (baik dari x atau spasi kosong) ke list row\nmatrix.append(row) : Menambahkan list row yang berisi elemen-elemen satu baris ke dalam list matrix\n\n\nMencetak matrix\n\n    print(\"Matriks yang Anda buat:\")\n    for row in matrix:\n        print(row)\n\nMenghasilkan matriks transpose dari matrix yang telah dibuat\n\n    transposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\n    for row in transposed_matrix:\n        print(row)\nFor More Detail :\n\nrow[i] for row in matrix : Menghasilkan list elemen ke-i dari setiap baris dalam matrix\nfor i in range(len(matrix[0]))] : Mengiterasi setiap indeks kolom dari matrix dan membentuk baris baru dari elemen-elemen tersebut\nfor row in transposed_matrix : Loop ini mengiterasi melalui setiap baris dalam transposed_matrix\nprint(row) : Mencetak matriks transpose dari matrix\n\n\nString kosong yang akan digunakan untuk menyimpan teks yang terenkripsi\n\n    encrypted_text = \"\"\n\nMenandai batas awal dan akhir dari baris dan kolom pada matriks transpose\n\n    start_row, end_row = len(transposed_matrix) - 1, 0\n    start_col, end_col = len(transposed_matrix[0]) - 1, 0\n\nMengambil baris dari kanan ke kiri\n\n    while start_row &gt;= end_row and start_col &gt;= end_col:\n        for i in range(start_col, end_col - 1, -1):\n            encrypted_text += transposed_matrix[start_row][i]\n\n        start_row -= 1\nFor More Detail :\n\nwhile start_row &gt;= end_row and start_col &gt;= end_col : loop while yang berjalan selama start_row lebih besar dari atau sama dengan end_row dan start_col lebih besar dari atau sama dengan end_col\nfor i in range(start_col, end_col - 1, -1) : Loop ini mengiterasi dari kolom paling kanan (start_col) ke kolom paling kiri (end_col - 1)\nencrypted_text += transposed_matrix[start_row][i] : Menambahkan elemen dari baris start_row dan kolom i ke encrypted_text\nstart_row -= 1 : Mengurangi start_row untuk bergerak ke baris berikutnya ke atas\n\n\nMengambil kolom dari atas ke bawah\n\n    for i in range(start_row, end_row - 1, -1):\n            encrypted_text += transposed_matrix[i][end_col]\n\n        end_col += 1\nFor More Detail :\n\nfor i in range(start_row, end_row - 1, -1) : Loop ini mengiterasi dari baris start_row ke baris end_row - 1\nencrypted_text += transposed_matrix[i][end_col] : Menambahkan elemen dari baris i dan kolom end_col ke encrypted_text\nend_col += 1 : Menambahkan end_col untuk bergerak ke kolom berikutnya ke kiri.\n\n\nMengecek jika sudah mencapai kolom terakhir\n\n    if start_col &lt; end_col:\n            break\nFor More Detail :\n\nif start_col &lt; end_col: : Mengecek apakah start_col lebih kecil dari end_col\nbreak : Jika ya, keluar dari loop while.\n\n\nMengambil baris dari kiri ke kanan\n\n    for i in range(end_col, start_col + 1):\n            encrypted_text += transposed_matrix[end_row][i]\n\n        end_row += 1\nFor More Detail :\n\nfor i in range(end_col, start_col + 1) : Loop ini mengiterasi dari kolom end_col ke kolom start_col + 1\nencrypted_text += transposed_matrix[end_row][i] : Menambahkan elemen dari baris end_row dan kolom i ke encrypted_text\nend_row += 1 : Menambahkan end_row untuk bergerak ke baris berikutnya ke bawah.\n\n\nMengecek Jika Sudah Mencapai Baris Terakhir\n\n    if start_row &lt; end_row:\n            break\nFor More Detail :\n\nif start_row &lt; end_row : Mengecek apakah start_row lebih kecil dari end_row\nbreak : Jika ya, keluar dari loop while\n\n\nMengambil kolom dari bawah ke atas\n\n    for i in range(end_row, start_row + 1):\n            encrypted_text += transposed_matrix[i][start_col]\n\n        start_col -= 1\nFor More Detail :\n\nfor i in range(end_row, start_row + 1) : Loop ini mengiterasi dari baris end_row ke baris start_row + 1\nencrypted_text += transposed_matrix[i][start_col] : Menambahkan elemen dari baris i dan kolom start_col ke encrypted_text\nstart_col -= 1 : Mengurangi start_col untuk bergerak ke kolom berikutnya ke kanan\n\n\nMencetak teks terenkripsi (ciphertext)\n\nprint(\"Teks terenkripsi dengan pola spiral: \", encrypted_text[:length])\nFor More Detail :\n\nencrypted_text[:length]) : Memotong encrypted_text hingga panjang teks asli (length) untuk memastikan panjangnya sama dengan teks asli\n\nHASIL CIPHERTEXT : XUAETKAADTRUTNETKIAABTDMRNANYAMKGAATBNIPNAOSSKIAEJSEANPDIEAR\n\n\nProses Dekripsi\nMasukkan Ciphertext\ncipherText = input(\"cipher : \")\nMasukkan kunci\nrouteKey = int(input(\"Kunci: \"))\n\nMenentukan jumlah baris yang dibutuhkan untuk membentuk sebuah matriks dengan jumlah kolom yang telah ditentukan (routeKey). Matriks ini akan berisi teks x yang telah dibersihkan\n\n    kolom = routeKey\n    matrix = []\n    panjang = len(x)\n    temp = panjang/kolom\n    length = len(x)\n    bulat = round(temp)\n\n    if temp - bulat == 0:\n        jml_baris = bulat\n    else:\n        if temp - bulat &lt; 0:\n            jml_baris = bulat\n        else:\n            jml_baris = bulat + 1\n    print(jml_baris)\nFor More Detail :\n\nkolom = routeKey : Menetapkan jumlah kolom pada matriks dengan nilai routeKey\nmatrix = [] : Menginisialisasi sebuah list kosong yang akan digunakan untuk menyimpan elemen-elemen matriks\npanjang = len(x) : Menyimpan panjang dari teks x ke dalam variabel panjang\ntemp = panjang/kolom : Menghitung berapa banyak baris yang diperlukan dengan membagi panjang teks dengan jumlah kolom dan menyimpan hasilnya dalam variabel temp\nlength = len(x) : Menyimpan panjang teks x ke dalam variabel length\nbulat = round(temp) : Membulatkan hasil pembagian temp ke angka terdekat dan menyimpannya ke dalam variabel bulat\n\n\nMembangun matriks 2D yang berisi teks x yang telah dibersihkan (tanpa spasi), Matriks ini akan memiliki jml_baris baris dan kolom kolom\n\n    for i in range(jml_baris):\n        row = []\n        for j in range(kolom):\n            if i * kolom + j &lt; len(x):\n                elemen = [i * kolom + j]\n            else:\n                elemen = \" \"\n            row.append(elemen)\n        matrix.append(row)\nFor More Detail :\n\nfor i in range(jml_baris) : Loop ini mengiterasi dari 0 hingga jml_baris - 1, yang berarti setiap iterasi mewakili satu baris dalam matriks\nrow = [] : Membuat list kosong row yang akan menyimpan elemen-elemen untuk satu baris matriks\nfor j in range(kolom) : Loop ini mengiterasi dari 0 hingga kolom - 1, yang berarti setiap iterasi mewakili satu kolom dalam matriks\nif i * kolom + j &lt; len(x) : Mengecek apakah indeks (dihitung sebagai i * kolom + j) berada dalam rentang panjang teks x\nelemen = x[i * kolom + j] : Jika ya, Mengambil elemen dari teks x pada posisi i * kolom + j\nelemen = \" \" : Jika tidak, Mengisi elemen dengan spasi kosong jika indeks berada di luar panjang teks x -row.append(elemen) : Menambahkan elemen yang telah ditentukan (baik dari x atau spasi kosong) ke list row\nmatrix.append(row) : Menambahkan list row yang berisi elemen-elemen satu baris ke dalam list matrix\n\n\nMencetak matriks yang telah dibuat\n\n    print(\"Matriks yang Anda buat:\")\n    for row in matrix:\n        print(row)\n\nMembuat dan mencetak matriks transpose\n\n    transposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\n    for row in transposed_matrix:\n        print(row)\nFor More Detail :\n\nrow[i] for row in matrix : Menghasilkan list elemen ke-i dari setiap baris dalam matrix\nfor i in range(len(matrix[0]))] : Mengiterasi setiap indeks kolom dari matrix dan membentuk baris baru dari elemen-elemen tersebut\nfor row in transposed_matrix : Loop ini mengiterasi melalui setiap baris dalam transposed_matrix\n\n\nMengatur batas-batas dan kontrol iterasi saat mengisi transposed_matrix dalam pola spiral dengan karakter-karakter dari teks x\n\n    start_row, end_row = len(transposed_matrix) - 1, 0\n    start_col, end_col = len(transposed_matrix[0]) - 1, 0\n    text_index = 0\nFor More Detail :\n\nstart_row : Mengendalikan pengisian dari baris terakhir ke atas\nend_row : Mengendalikan pengisian dari baris pertama ke bawah\nend_row = 0 : Menetapkan indeks baris awal ke 0, yang berarti kita mulai dari baris pertama\nlen(transposed_matrix) : Memberikan jumlah baris dalam transposed_matrix\nMengurangkan 1 untuk mendapatkan indeks baris terakhir dari matriks transpose\nstart_col : Mengendalikan pengisian dari kolom terakhir ke kiri, sedangkan\nend_col : Mengendalikan pengisian dari kolom pertama ke kanan\nlen(transposed_matrix[0]) : Memberikan jumlah kolom dalam transposed_matrix\nMengurangkan 1 untuk mendapatkan indeks kolom terakhir dari matriks transpose\nend_col = 0 : Menetapkan indeks kolom awal ke 0, yang berarti kita mulai dari kolom pertama\ntext_index : Melacak posisi karakter dalam teks x yang sedang diproses\n\n\nMengisi baris pertama dari kanan ke kiri\n\n    while start_row &gt;= end_row and start_col &gt;= end_col:\n        # Fill the first row from the remaining rows\n        for i in range(start_col, end_col - 1, -1):\n            if text_index &lt; len(x):\n                transposed_matrix[start_row][i] = x[text_index]\n                text_index += 1\n\n        start_row -= 1\nFor More Detail :\n\nstart_col dan end_col : menentukan rentang kolom yang akan diisi\ntext_index : mengambil karakter dari teks x.\nTransposed_matrix[start_row][i] : Setiap karakter yang diambil dari x dimasukkan ke dalam posisi yang sesuai di t.\n\n\nMengisi kolom terakhir dari baris yang tersisa dalam matriks dengan karakter dari x dalam urutan spiral\n\n    for i in range(start_row, end_row - 1, -1):\n            if text_index &lt; len(x):\n                transposed_matrix[i][end_col] = x[text_index]\n                text_index += 1\n\n        end_col += 1\nFor More Detail :\n\nfor i in range(start_row, end_row - 1, -1) : Loop ini digunakan untuk iterasi melalui baris-baris dalam matriks dari start_row ke end_row - 1 dalam urutan menurun\nstart_row : Posisi baris awal untuk iterasi\nend_row - 1 : Posisi baris akhir (tidak termasuk) untuk iterasi\n-1 : Menunjukkan bahwa iterasi dilakukan secara menurun\nif text_index &lt; len(cipherText) : Kondisi ini memastikan bahwa indeks text_index masih dalam batas panjang cipherText\ntransposed_matrix[i][end_col] : Menunjukkan posisi kolom end_col dalam baris i dari matriks yang sedang diisi\ncipherText[text_index] : Karakter dari cipherText pada indeks text_index\ntext_index += 1 : Setelah menempatkan karakter dari cipherText ke dalam transposed_matrix, nilai text_index dinaikkan sebesar 1 untuk mempersiapkan karakter berikutnya pada iterasi selanjutnya\nend_col += 1 : Setelah menyelesaikan iterasi untuk mengisi kolom terakhir dari baris yang tersisa, end_col dinaikkan sebesar 1 untuk mempersempit batas kolom yang akan diisi pada iterasi berikutnya\n\n\nMenentukkan apakah batas kolom telah bertemu atau melewati satu sama lain, yang berarti bahwa semua kolom yang perlu diisi sudah selesai diproses\n\n    if start_col &lt; end_col:\n            break\n\nMengisi baris terakhir dari kolom yang tersisa dalam matriks dengan karakter dari x dalam urutan spiral.\n\n    for i in range(end_col, start_col + 1):\n            if text_index &lt; len(x):\n                transposed_matrix[end_row][i] = x[text_index]\n                text_index += 1\n\n        end_row += 1\nFor More Detail :\n\nfor i in range(end_col, start_col + 1): Loop ini digunakan untuk iterasi melalui kolom dari end_col ke start_col + 1\nend_col: Posisi kolom awal untuk iterasi\nstart_col + 1: Posisi kolom akhir (tidak termasuk) untuk iterasi, Menambah 1 untuk memasukkan start_col dalam iterasi\nif text_index &lt; len(x) : Kondisi ini memastikan bahwa indeks\ntext_index : Masih dalam batas panjang x. Hal ini untuk menghindari akses indeks yang tidak valid dari x\ntransposed_matrix[end_row][i] = x[text_index] Menetapkan karakter dari x pada posisi indeks text_index ke posisi [end_row][i] dalam transposed_matrix\ntransposed_matrix[end_row][i]: Menunjukkan posisi kolom i dalam baris end_row dari matriks yang sedang diisi.\nx[text_index]: Karakter dari x pada indeks text_index\ntext_index += 1 Setelah menempatkan karakter dari x ke dalam transposed_matrix, nilai text_index dinaikkan sebesar 1 untuk mempersiapkan karakter berikutnya pada iterasi selanjutnya\nend_row += 1 Setelah menyelesaikan iterasi untuk mengisi baris terakhir dari kolom yang tersisa, batas baris akhir (end_row) dinaikkan sebesar 1 untuk mempersempit batas baris yang akan diisi pada iterasi berikutnya\n\n\nMenghentikan loop while jika batas baris bertemu atau melewati satu sama lain, menandakan bahwa pengisian matriks dalam pola spiral sudah selesai\n\n    if start_row &lt; end_row:\n            break\n\nMengisi baris terakhir dari kolom yang tersisa dalam matriks dengan karakter dari x dalam urutan spiral\n\n    for i in range(end_row, start_row + 1):\n            if text_index &lt; len(x):\n                transposed_matrix[i][start_col] = x[text_index]\n                text_index += 1\n\n        start_col -= 1\nFor More Detail :\n\nfor i in range(end_row, start_row + 1) : Loop ini digunakan untuk iterasi melalui baris dari end_row ke start_row + 1 dalam urutan meningkat\nend_row : Posisi baris awal untuk iterasi\nstart_row + 1 : Posisi baris akhir (tidak termasuk) untuk iterasi, Menambah 1 untuk memasukkan start_row dalam iterasi\nif text_index &lt; len(x) : Kondisi ini memastikan bahwa indeks text_index masih dalam batas panjang x\ntransposed_matrix[i][start_col] : Menunjukkan posisi kolom start_col dalam baris i dari matriks yang sedang diisi\nx[text_index] : Karakter dari x pada indeks text_index\ntext_index += 1 : Nilai text_index dinaikkan sebesar 1 untuk mempersiapkan karakter berikutnya pada iterasi selanjutnya\nstart_col -= 1 : Batas kolom awal (start_col) dikurangi sebesar 1 untuk mempersempit batas kolom yang akan diisi pada iterasi berikutnya\n\n\nMencetak matriks yang telah diisi dengan ciphertext\n\n    print(\"Matriks setelah diisi dengan cipher secara spiral:\")\n    for row in transposed_matrix:\n        print(row)\n\nString kosong untuk menyimpan hasil teks yang telah didekripsi\n\n    decrypted_text = \"\"\n\nMenyimpan jumlah baris dari transposed_matrix dalam variabel num_rows\n\n    num_rows = len(transposed_matrix)\n\nMenghitung jumlah kolom dalam transposed_matrix\n\n    num_cols = len(transposed_matrix[0])\n\nMenggabungkan karakter-karakter dari transposed_matrix ke dalam decrypted_text dengan membaca matriks secara kolom demi kolom\n\n    for col in range(num_cols):  \n        for row in range(num_rows):  \n            decrypted_text += transposed_matrix[row][col]\nFor More Detail :\n\nfor col in range(num_cols): Loop for ini digunakan untuk iterasi melalui setiap kolom dalam transposed_matrix.\nnum_cols : Jumlah kolom dalam transposed_matrix Ini mengontrol jumlah iterasi, memastikan bahwa setiap kolom dalam matriks diproses\nfor row in range(num_rows) : Loop ini digunakan untuk iterasi melalui setiap baris dalam transposed_matrix untuk kolom yang saat ini sedang diproses oleh loop luar\nnum_rows : Jumlah baris dalam transposed_matrix Ini mengontrol jumlah iterasi, memastikan bahwa setiap baris dalam kolom yang sedang diproses dipertimbangkan\ntransposed_matrix[row][col] : Mengakses elemen pada baris row dan kolom col dalam matriks\ndecrypted_text +=: Operator += : Menambahkan karakter ke string decrypted_text\n\n\nMencetak hasil teks terdeskripsi\n\n    print(\"Teks terdekripsi setelah membaca secara berurutan:\")\n    print(decrypted_text)\nHasil Decrypted :\nTENTUKANPRIORITASANDASEBABKITATIDAKDAPATMENGERJAKANSEMUANYAX",
    "crumbs": [
      "Kriptografi Modern",
      "4. AES"
    ]
  },
  {
    "objectID": "13_RSA.html",
    "href": "13_RSA.html",
    "title": "5. RSA",
    "section": "",
    "text": "Analogi Transposisi Route\nMari kita gunakan analogi kelas dengan siswa yang duduk di kursi dalam bentuk grid untuk menjelaskan algoritma transposisi route menggunakan pola spiral.\nBayangkan kamu adalah guru yang ingin mengatur ulang tempat duduk siswa sesuai pola spiral. Anda mulai dengan siswa pertama di sudut kiri atas, lalu bergerak ke kanan hingga akhir baris, turun ke baris berikutnya di sebelah kanan, kemudian bergerak ke kiri, dan seterusnya, sampai Anda kembali ke tengah grid. Berikut langkahnya :",
    "crumbs": [
      "Kriptografi Modern",
      "5. RSA"
    ]
  },
  {
    "objectID": "13_RSA.html#implementasi-pada-python",
    "href": "13_RSA.html#implementasi-pada-python",
    "title": "5. RSA",
    "section": "Implementasi Pada Python",
    "text": "Implementasi Pada Python\nMasukkan Plaintext\nCONTOH : TENTUKAN PRIORITAS ANDA SEBAB KITA TIDAK DAPAT MENGERJAKAN SEMUANYA X\nplainText = input(\"Plaintext : \")\nMasukkan Kunci\nCONTOH KEY : 5\nrouteKey = int(input(\"Kunci: \"))\nMenghapus Spasi\ncleanPlainTeks = plainTeks.replace(\" \", \"\")\nprint(cleanPlainTeks)\n\nProses Enkripsi\n\nMenyusun teks yang sudah dibersihkan ke dalam sebuah matriks dengan kolom sebagai jumlah kolom atau lebar matriks\n\n    kolom = routeKey\n    matrix = []\n    panjang = len(cleanPlainTeks)\n    temp = panjang/kolom\n    bulat = round(temp)\n\n    if temp - bulat == 0:\n        jml_baris = bulat\n    else:\n        if temp - bulat &lt; 0:\n            jml_baris = bulat\n        else:\n            jml_baris = bulat + 1\n    print(jml_baris)\nFor More Detail :\n\nkolom = routeKey : Menetapkan jumlah kolom pada matriks dengan nilai routeKey\nmatrix = [] : Menginisialisasi sebuah list kosong yang akan digunakan untuk menyimpan elemen-elemen matriks\npanjang = len(cleanPlainTeks) : Menghitung panjang teks yang sudah dibersihkan\ntemp = panjang/kolom : Menghitung berapa banyak baris yang diperlukan dengan membagi panjang teks dengan jumlah kolom dan menyimpan hasilnya dalam variabel temp\nbulat = round(temp) : Membulatkan hasil pembagian temp ke angka terdekat dan menyimpannya ke dalam variabel bulat\ntemp - bulat == 0 : hasil pembagian tepat bulat, maka jml_baris diambil dari bulat\ntemp - bulat &lt; 0 : hasil pembagian kurang dari bulat (mungkin karena temp lebih kecil dari bulat), dan juga mengambil jml_baris dari bulat\njml_baris = bulat + 1 : Jika kondisi sebelumnya tidak terpenuhi, maka perlu satu baris tambahan\n\n\nMembuat sebuah matriks (matrix) yang berisi teks yang sudah dibersihkan (cleanPlainTeks) menggunakan nilai jml_baris dan kolom yang telah dihitung sebelumnya\n\n    for i in range(jml_baris):\n        row = []\n        for j in range(kolom):\n            if i * kolom + j &lt; len(cleanPlainTeks):\n                elemen = cleanPlainTeks[i * kolom + j]\n            else:\n                elemen = \" \"\n            row.append(elemen)\n        matrix.append(row)\nFor More Detail :\n\nfor i in range(jml_baris) : Loop ini mengiterasi dari 0 hingga jml_baris - 1, yang berarti setiap iterasi mewakili satu baris dalam matriks\nrow = [] : Membuat list kosong row yang akan menyimpan elemen-elemen untuk satu baris matriks\nfor j in range(kolom) : Loop ini mengiterasi dari 0 hingga kolom - 1, yang berarti setiap iterasi mewakili satu kolom dalam matriks\nif i * kolom + j &lt; len(cleanPlainTeks) : Memastikan bahwa tidak melebihi panjang dari teks yang telah dibersihkan pada saat mengakses elemen cleanPlainTeks untuk dimasukkan ke dalam matrix\nelemen = x[i * kolom + j] : Jika ya, Mengambil elemen dari teks x pada posisi i * kolom + j\nelemen = \" \" : Jika tidak, Mengisi elemen dengan spasi kosong jika indeks berada di luar panjang teks x -row.append(elemen) : Menambahkan elemen yang telah ditentukan (baik dari x atau spasi kosong) ke list row\nmatrix.append(row) : Menambahkan list row yang berisi elemen-elemen satu baris ke dalam list matrix\n\n\nMencetak matrix\n\n    print(\"Matriks yang Anda buat:\")\n    for row in matrix:\n        print(row)\n\nMenghasilkan matriks transpose dari matrix yang telah dibuat\n\n    transposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\n    for row in transposed_matrix:\n        print(row)\nFor More Detail :\n\nrow[i] for row in matrix : Menghasilkan list elemen ke-i dari setiap baris dalam matrix\nfor i in range(len(matrix[0]))] : Mengiterasi setiap indeks kolom dari matrix dan membentuk baris baru dari elemen-elemen tersebut\nfor row in transposed_matrix : Loop ini mengiterasi melalui setiap baris dalam transposed_matrix\nprint(row) : Mencetak matriks transpose dari matrix\n\n\nString kosong yang akan digunakan untuk menyimpan teks yang terenkripsi\n\n    encrypted_text = \"\"\n\nMenandai batas awal dan akhir dari baris dan kolom pada matriks transpose\n\n    start_row, end_row = len(transposed_matrix) - 1, 0\n    start_col, end_col = len(transposed_matrix[0]) - 1, 0\n\nMengambil baris dari kanan ke kiri\n\n    while start_row &gt;= end_row and start_col &gt;= end_col:\n        for i in range(start_col, end_col - 1, -1):\n            encrypted_text += transposed_matrix[start_row][i]\n\n        start_row -= 1\nFor More Detail :\n\nwhile start_row &gt;= end_row and start_col &gt;= end_col : loop while yang berjalan selama start_row lebih besar dari atau sama dengan end_row dan start_col lebih besar dari atau sama dengan end_col\nfor i in range(start_col, end_col - 1, -1) : Loop ini mengiterasi dari kolom paling kanan (start_col) ke kolom paling kiri (end_col - 1)\nencrypted_text += transposed_matrix[start_row][i] : Menambahkan elemen dari baris start_row dan kolom i ke encrypted_text\nstart_row -= 1 : Mengurangi start_row untuk bergerak ke baris berikutnya ke atas\n\n\nMengambil kolom dari atas ke bawah\n\n    for i in range(start_row, end_row - 1, -1):\n            encrypted_text += transposed_matrix[i][end_col]\n\n        end_col += 1\nFor More Detail :\n\nfor i in range(start_row, end_row - 1, -1) : Loop ini mengiterasi dari baris start_row ke baris end_row - 1\nencrypted_text += transposed_matrix[i][end_col] : Menambahkan elemen dari baris i dan kolom end_col ke encrypted_text\nend_col += 1 : Menambahkan end_col untuk bergerak ke kolom berikutnya ke kiri.\n\n\nMengecek jika sudah mencapai kolom terakhir\n\n    if start_col &lt; end_col:\n            break\nFor More Detail :\n\nif start_col &lt; end_col: : Mengecek apakah start_col lebih kecil dari end_col\nbreak : Jika ya, keluar dari loop while.\n\n\nMengambil baris dari kiri ke kanan\n\n    for i in range(end_col, start_col + 1):\n            encrypted_text += transposed_matrix[end_row][i]\n\n        end_row += 1\nFor More Detail :\n\nfor i in range(end_col, start_col + 1) : Loop ini mengiterasi dari kolom end_col ke kolom start_col + 1\nencrypted_text += transposed_matrix[end_row][i] : Menambahkan elemen dari baris end_row dan kolom i ke encrypted_text\nend_row += 1 : Menambahkan end_row untuk bergerak ke baris berikutnya ke bawah.\n\n\nMengecek Jika Sudah Mencapai Baris Terakhir\n\n    if start_row &lt; end_row:\n            break\nFor More Detail :\n\nif start_row &lt; end_row : Mengecek apakah start_row lebih kecil dari end_row\nbreak : Jika ya, keluar dari loop while\n\n\nMengambil kolom dari bawah ke atas\n\n    for i in range(end_row, start_row + 1):\n            encrypted_text += transposed_matrix[i][start_col]\n\n        start_col -= 1\nFor More Detail :\n\nfor i in range(end_row, start_row + 1) : Loop ini mengiterasi dari baris end_row ke baris start_row + 1\nencrypted_text += transposed_matrix[i][start_col] : Menambahkan elemen dari baris i dan kolom start_col ke encrypted_text\nstart_col -= 1 : Mengurangi start_col untuk bergerak ke kolom berikutnya ke kanan\n\n\nMencetak teks terenkripsi (ciphertext)\n\nprint(\"Teks terenkripsi dengan pola spiral: \", encrypted_text[:length])\nFor More Detail :\n\nencrypted_text[:length]) : Memotong encrypted_text hingga panjang teks asli (length) untuk memastikan panjangnya sama dengan teks asli\n\nHASIL CIPHERTEXT : XUAETKAADTRUTNETKIAABTDMRNANYAMKGAATBNIPNAOSSKIAEJSEANPDIEAR\n\n\nProses Dekripsi\nMasukkan Ciphertext\ncipherText = input(\"cipher : \")\nMasukkan kunci\nrouteKey = int(input(\"Kunci: \"))\n\nMenentukan jumlah baris yang dibutuhkan untuk membentuk sebuah matriks dengan jumlah kolom yang telah ditentukan (routeKey). Matriks ini akan berisi teks x yang telah dibersihkan\n\n    kolom = routeKey\n    matrix = []\n    panjang = len(x)\n    temp = panjang/kolom\n    length = len(x)\n    bulat = round(temp)\n\n    if temp - bulat == 0:\n        jml_baris = bulat\n    else:\n        if temp - bulat &lt; 0:\n            jml_baris = bulat\n        else:\n            jml_baris = bulat + 1\n    print(jml_baris)\nFor More Detail :\n\nkolom = routeKey : Menetapkan jumlah kolom pada matriks dengan nilai routeKey\nmatrix = [] : Menginisialisasi sebuah list kosong yang akan digunakan untuk menyimpan elemen-elemen matriks\npanjang = len(x) : Menyimpan panjang dari teks x ke dalam variabel panjang\ntemp = panjang/kolom : Menghitung berapa banyak baris yang diperlukan dengan membagi panjang teks dengan jumlah kolom dan menyimpan hasilnya dalam variabel temp\nlength = len(x) : Menyimpan panjang teks x ke dalam variabel length\nbulat = round(temp) : Membulatkan hasil pembagian temp ke angka terdekat dan menyimpannya ke dalam variabel bulat\n\n\nMembangun matriks 2D yang berisi teks x yang telah dibersihkan (tanpa spasi), Matriks ini akan memiliki jml_baris baris dan kolom kolom\n\n    for i in range(jml_baris):\n        row = []\n        for j in range(kolom):\n            if i * kolom + j &lt; len(x):\n                elemen = [i * kolom + j]\n            else:\n                elemen = \" \"\n            row.append(elemen)\n        matrix.append(row)\nFor More Detail :\n\nfor i in range(jml_baris) : Loop ini mengiterasi dari 0 hingga jml_baris - 1, yang berarti setiap iterasi mewakili satu baris dalam matriks\nrow = [] : Membuat list kosong row yang akan menyimpan elemen-elemen untuk satu baris matriks\nfor j in range(kolom) : Loop ini mengiterasi dari 0 hingga kolom - 1, yang berarti setiap iterasi mewakili satu kolom dalam matriks\nif i * kolom + j &lt; len(x) : Mengecek apakah indeks (dihitung sebagai i * kolom + j) berada dalam rentang panjang teks x\nelemen = x[i * kolom + j] : Jika ya, Mengambil elemen dari teks x pada posisi i * kolom + j\nelemen = \" \" : Jika tidak, Mengisi elemen dengan spasi kosong jika indeks berada di luar panjang teks x -row.append(elemen) : Menambahkan elemen yang telah ditentukan (baik dari x atau spasi kosong) ke list row\nmatrix.append(row) : Menambahkan list row yang berisi elemen-elemen satu baris ke dalam list matrix\n\n\nMencetak matriks yang telah dibuat\n\n    print(\"Matriks yang Anda buat:\")\n    for row in matrix:\n        print(row)\n\nMembuat dan mencetak matriks transpose\n\n    transposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\n    for row in transposed_matrix:\n        print(row)\nFor More Detail :\n\nrow[i] for row in matrix : Menghasilkan list elemen ke-i dari setiap baris dalam matrix\nfor i in range(len(matrix[0]))] : Mengiterasi setiap indeks kolom dari matrix dan membentuk baris baru dari elemen-elemen tersebut\nfor row in transposed_matrix : Loop ini mengiterasi melalui setiap baris dalam transposed_matrix\n\n\nMengatur batas-batas dan kontrol iterasi saat mengisi transposed_matrix dalam pola spiral dengan karakter-karakter dari teks x\n\n    start_row, end_row = len(transposed_matrix) - 1, 0\n    start_col, end_col = len(transposed_matrix[0]) - 1, 0\n    text_index = 0\nFor More Detail :\n\nstart_row : Mengendalikan pengisian dari baris terakhir ke atas\nend_row : Mengendalikan pengisian dari baris pertama ke bawah\nend_row = 0 : Menetapkan indeks baris awal ke 0, yang berarti kita mulai dari baris pertama\nlen(transposed_matrix) : Memberikan jumlah baris dalam transposed_matrix\nMengurangkan 1 untuk mendapatkan indeks baris terakhir dari matriks transpose\nstart_col : Mengendalikan pengisian dari kolom terakhir ke kiri, sedangkan\nend_col : Mengendalikan pengisian dari kolom pertama ke kanan\nlen(transposed_matrix[0]) : Memberikan jumlah kolom dalam transposed_matrix\nMengurangkan 1 untuk mendapatkan indeks kolom terakhir dari matriks transpose\nend_col = 0 : Menetapkan indeks kolom awal ke 0, yang berarti kita mulai dari kolom pertama\ntext_index : Melacak posisi karakter dalam teks x yang sedang diproses\n\n\nMengisi baris pertama dari kanan ke kiri\n\n    while start_row &gt;= end_row and start_col &gt;= end_col:\n        # Fill the first row from the remaining rows\n        for i in range(start_col, end_col - 1, -1):\n            if text_index &lt; len(x):\n                transposed_matrix[start_row][i] = x[text_index]\n                text_index += 1\n\n        start_row -= 1\nFor More Detail :\n\nstart_col dan end_col : menentukan rentang kolom yang akan diisi\ntext_index : mengambil karakter dari teks x.\nTransposed_matrix[start_row][i] : Setiap karakter yang diambil dari x dimasukkan ke dalam posisi yang sesuai di t.\n\n\nMengisi kolom terakhir dari baris yang tersisa dalam matriks dengan karakter dari x dalam urutan spiral\n\n    for i in range(start_row, end_row - 1, -1):\n            if text_index &lt; len(x):\n                transposed_matrix[i][end_col] = x[text_index]\n                text_index += 1\n\n        end_col += 1\nFor More Detail :\n\nfor i in range(start_row, end_row - 1, -1) : Loop ini digunakan untuk iterasi melalui baris-baris dalam matriks dari start_row ke end_row - 1 dalam urutan menurun\nstart_row : Posisi baris awal untuk iterasi\nend_row - 1 : Posisi baris akhir (tidak termasuk) untuk iterasi\n-1 : Menunjukkan bahwa iterasi dilakukan secara menurun\nif text_index &lt; len(cipherText) : Kondisi ini memastikan bahwa indeks text_index masih dalam batas panjang cipherText\ntransposed_matrix[i][end_col] : Menunjukkan posisi kolom end_col dalam baris i dari matriks yang sedang diisi\ncipherText[text_index] : Karakter dari cipherText pada indeks text_index\ntext_index += 1 : Setelah menempatkan karakter dari cipherText ke dalam transposed_matrix, nilai text_index dinaikkan sebesar 1 untuk mempersiapkan karakter berikutnya pada iterasi selanjutnya\nend_col += 1 : Setelah menyelesaikan iterasi untuk mengisi kolom terakhir dari baris yang tersisa, end_col dinaikkan sebesar 1 untuk mempersempit batas kolom yang akan diisi pada iterasi berikutnya\n\n\nMenentukkan apakah batas kolom telah bertemu atau melewati satu sama lain, yang berarti bahwa semua kolom yang perlu diisi sudah selesai diproses\n\n    if start_col &lt; end_col:\n            break\n\nMengisi baris terakhir dari kolom yang tersisa dalam matriks dengan karakter dari x dalam urutan spiral.\n\n    for i in range(end_col, start_col + 1):\n            if text_index &lt; len(x):\n                transposed_matrix[end_row][i] = x[text_index]\n                text_index += 1\n\n        end_row += 1\nFor More Detail :\n\nfor i in range(end_col, start_col + 1): Loop ini digunakan untuk iterasi melalui kolom dari end_col ke start_col + 1\nend_col: Posisi kolom awal untuk iterasi\nstart_col + 1: Posisi kolom akhir (tidak termasuk) untuk iterasi, Menambah 1 untuk memasukkan start_col dalam iterasi\nif text_index &lt; len(x) : Kondisi ini memastikan bahwa indeks\ntext_index : Masih dalam batas panjang x. Hal ini untuk menghindari akses indeks yang tidak valid dari x\ntransposed_matrix[end_row][i] = x[text_index] Menetapkan karakter dari x pada posisi indeks text_index ke posisi [end_row][i] dalam transposed_matrix\ntransposed_matrix[end_row][i]: Menunjukkan posisi kolom i dalam baris end_row dari matriks yang sedang diisi.\nx[text_index]: Karakter dari x pada indeks text_index\ntext_index += 1 Setelah menempatkan karakter dari x ke dalam transposed_matrix, nilai text_index dinaikkan sebesar 1 untuk mempersiapkan karakter berikutnya pada iterasi selanjutnya\nend_row += 1 Setelah menyelesaikan iterasi untuk mengisi baris terakhir dari kolom yang tersisa, batas baris akhir (end_row) dinaikkan sebesar 1 untuk mempersempit batas baris yang akan diisi pada iterasi berikutnya\n\n\nMenghentikan loop while jika batas baris bertemu atau melewati satu sama lain, menandakan bahwa pengisian matriks dalam pola spiral sudah selesai\n\n    if start_row &lt; end_row:\n            break\n\nMengisi baris terakhir dari kolom yang tersisa dalam matriks dengan karakter dari x dalam urutan spiral\n\n    for i in range(end_row, start_row + 1):\n            if text_index &lt; len(x):\n                transposed_matrix[i][start_col] = x[text_index]\n                text_index += 1\n\n        start_col -= 1\nFor More Detail :\n\nfor i in range(end_row, start_row + 1) : Loop ini digunakan untuk iterasi melalui baris dari end_row ke start_row + 1 dalam urutan meningkat\nend_row : Posisi baris awal untuk iterasi\nstart_row + 1 : Posisi baris akhir (tidak termasuk) untuk iterasi, Menambah 1 untuk memasukkan start_row dalam iterasi\nif text_index &lt; len(x) : Kondisi ini memastikan bahwa indeks text_index masih dalam batas panjang x\ntransposed_matrix[i][start_col] : Menunjukkan posisi kolom start_col dalam baris i dari matriks yang sedang diisi\nx[text_index] : Karakter dari x pada indeks text_index\ntext_index += 1 : Nilai text_index dinaikkan sebesar 1 untuk mempersiapkan karakter berikutnya pada iterasi selanjutnya\nstart_col -= 1 : Batas kolom awal (start_col) dikurangi sebesar 1 untuk mempersempit batas kolom yang akan diisi pada iterasi berikutnya\n\n\nMencetak matriks yang telah diisi dengan ciphertext\n\n    print(\"Matriks setelah diisi dengan cipher secara spiral:\")\n    for row in transposed_matrix:\n        print(row)\n\nString kosong untuk menyimpan hasil teks yang telah didekripsi\n\n    decrypted_text = \"\"\n\nMenyimpan jumlah baris dari transposed_matrix dalam variabel num_rows\n\n    num_rows = len(transposed_matrix)\n\nMenghitung jumlah kolom dalam transposed_matrix\n\n    num_cols = len(transposed_matrix[0])\n\nMenggabungkan karakter-karakter dari transposed_matrix ke dalam decrypted_text dengan membaca matriks secara kolom demi kolom\n\n    for col in range(num_cols):  \n        for row in range(num_rows):  \n            decrypted_text += transposed_matrix[row][col]\nFor More Detail :\n\nfor col in range(num_cols): Loop for ini digunakan untuk iterasi melalui setiap kolom dalam transposed_matrix.\nnum_cols : Jumlah kolom dalam transposed_matrix Ini mengontrol jumlah iterasi, memastikan bahwa setiap kolom dalam matriks diproses\nfor row in range(num_rows) : Loop ini digunakan untuk iterasi melalui setiap baris dalam transposed_matrix untuk kolom yang saat ini sedang diproses oleh loop luar\nnum_rows : Jumlah baris dalam transposed_matrix Ini mengontrol jumlah iterasi, memastikan bahwa setiap baris dalam kolom yang sedang diproses dipertimbangkan\ntransposed_matrix[row][col] : Mengakses elemen pada baris row dan kolom col dalam matriks\ndecrypted_text +=: Operator += : Menambahkan karakter ke string decrypted_text\n\n\nMencetak hasil teks terdeskripsi\n\n    print(\"Teks terdekripsi setelah membaca secara berurutan:\")\n    print(decrypted_text)\nHasil Decrypted :\nTENTUKANPRIORITASANDASEBABKITATIDAKDAPATMENGERJAKANSEMUANYAX",
    "crumbs": [
      "Kriptografi Modern",
      "5. RSA"
    ]
  },
  {
    "objectID": "14_Elgamal.html",
    "href": "14_Elgamal.html",
    "title": "6. Elgamal",
    "section": "",
    "text": "Analogi Transposisi Route\nMari kita gunakan analogi kelas dengan siswa yang duduk di kursi dalam bentuk grid untuk menjelaskan algoritma transposisi route menggunakan pola spiral.\nBayangkan kamu adalah guru yang ingin mengatur ulang tempat duduk siswa sesuai pola spiral. Anda mulai dengan siswa pertama di sudut kiri atas, lalu bergerak ke kanan hingga akhir baris, turun ke baris berikutnya di sebelah kanan, kemudian bergerak ke kiri, dan seterusnya, sampai Anda kembali ke tengah grid. Berikut langkahnya :",
    "crumbs": [
      "Kriptografi Modern",
      "6. Elgamal"
    ]
  },
  {
    "objectID": "14_Elgamal.html#implementasi-pada-python",
    "href": "14_Elgamal.html#implementasi-pada-python",
    "title": "6. Elgamal",
    "section": "Implementasi Pada Python",
    "text": "Implementasi Pada Python\nMasukkan Plaintext\nCONTOH : TENTUKAN PRIORITAS ANDA SEBAB KITA TIDAK DAPAT MENGERJAKAN SEMUANYA X\nplainText = input(\"Plaintext : \")\nMasukkan Kunci\nCONTOH KEY : 5\nrouteKey = int(input(\"Kunci: \"))\nMenghapus Spasi\ncleanPlainTeks = plainTeks.replace(\" \", \"\")\nprint(cleanPlainTeks)\n\nProses Enkripsi\n\nMenyusun teks yang sudah dibersihkan ke dalam sebuah matriks dengan kolom sebagai jumlah kolom atau lebar matriks\n\n    kolom = routeKey\n    matrix = []\n    panjang = len(cleanPlainTeks)\n    temp = panjang/kolom\n    bulat = round(temp)\n\n    if temp - bulat == 0:\n        jml_baris = bulat\n    else:\n        if temp - bulat &lt; 0:\n            jml_baris = bulat\n        else:\n            jml_baris = bulat + 1\n    print(jml_baris)\nFor More Detail :\n\nkolom = routeKey : Menetapkan jumlah kolom pada matriks dengan nilai routeKey\nmatrix = [] : Menginisialisasi sebuah list kosong yang akan digunakan untuk menyimpan elemen-elemen matriks\npanjang = len(cleanPlainTeks) : Menghitung panjang teks yang sudah dibersihkan\ntemp = panjang/kolom : Menghitung berapa banyak baris yang diperlukan dengan membagi panjang teks dengan jumlah kolom dan menyimpan hasilnya dalam variabel temp\nbulat = round(temp) : Membulatkan hasil pembagian temp ke angka terdekat dan menyimpannya ke dalam variabel bulat\ntemp - bulat == 0 : hasil pembagian tepat bulat, maka jml_baris diambil dari bulat\ntemp - bulat &lt; 0 : hasil pembagian kurang dari bulat (mungkin karena temp lebih kecil dari bulat), dan juga mengambil jml_baris dari bulat\njml_baris = bulat + 1 : Jika kondisi sebelumnya tidak terpenuhi, maka perlu satu baris tambahan\n\n\nMembuat sebuah matriks (matrix) yang berisi teks yang sudah dibersihkan (cleanPlainTeks) menggunakan nilai jml_baris dan kolom yang telah dihitung sebelumnya\n\n    for i in range(jml_baris):\n        row = []\n        for j in range(kolom):\n            if i * kolom + j &lt; len(cleanPlainTeks):\n                elemen = cleanPlainTeks[i * kolom + j]\n            else:\n                elemen = \" \"\n            row.append(elemen)\n        matrix.append(row)\nFor More Detail :\n\nfor i in range(jml_baris) : Loop ini mengiterasi dari 0 hingga jml_baris - 1, yang berarti setiap iterasi mewakili satu baris dalam matriks\nrow = [] : Membuat list kosong row yang akan menyimpan elemen-elemen untuk satu baris matriks\nfor j in range(kolom) : Loop ini mengiterasi dari 0 hingga kolom - 1, yang berarti setiap iterasi mewakili satu kolom dalam matriks\nif i * kolom + j &lt; len(cleanPlainTeks) : Memastikan bahwa tidak melebihi panjang dari teks yang telah dibersihkan pada saat mengakses elemen cleanPlainTeks untuk dimasukkan ke dalam matrix\nelemen = x[i * kolom + j] : Jika ya, Mengambil elemen dari teks x pada posisi i * kolom + j\nelemen = \" \" : Jika tidak, Mengisi elemen dengan spasi kosong jika indeks berada di luar panjang teks x -row.append(elemen) : Menambahkan elemen yang telah ditentukan (baik dari x atau spasi kosong) ke list row\nmatrix.append(row) : Menambahkan list row yang berisi elemen-elemen satu baris ke dalam list matrix\n\n\nMencetak matrix\n\n    print(\"Matriks yang Anda buat:\")\n    for row in matrix:\n        print(row)\n\nMenghasilkan matriks transpose dari matrix yang telah dibuat\n\n    transposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\n    for row in transposed_matrix:\n        print(row)\nFor More Detail :\n\nrow[i] for row in matrix : Menghasilkan list elemen ke-i dari setiap baris dalam matrix\nfor i in range(len(matrix[0]))] : Mengiterasi setiap indeks kolom dari matrix dan membentuk baris baru dari elemen-elemen tersebut\nfor row in transposed_matrix : Loop ini mengiterasi melalui setiap baris dalam transposed_matrix\nprint(row) : Mencetak matriks transpose dari matrix\n\n\nString kosong yang akan digunakan untuk menyimpan teks yang terenkripsi\n\n    encrypted_text = \"\"\n\nMenandai batas awal dan akhir dari baris dan kolom pada matriks transpose\n\n    start_row, end_row = len(transposed_matrix) - 1, 0\n    start_col, end_col = len(transposed_matrix[0]) - 1, 0\n\nMengambil baris dari kanan ke kiri\n\n    while start_row &gt;= end_row and start_col &gt;= end_col:\n        for i in range(start_col, end_col - 1, -1):\n            encrypted_text += transposed_matrix[start_row][i]\n\n        start_row -= 1\nFor More Detail :\n\nwhile start_row &gt;= end_row and start_col &gt;= end_col : loop while yang berjalan selama start_row lebih besar dari atau sama dengan end_row dan start_col lebih besar dari atau sama dengan end_col\nfor i in range(start_col, end_col - 1, -1) : Loop ini mengiterasi dari kolom paling kanan (start_col) ke kolom paling kiri (end_col - 1)\nencrypted_text += transposed_matrix[start_row][i] : Menambahkan elemen dari baris start_row dan kolom i ke encrypted_text\nstart_row -= 1 : Mengurangi start_row untuk bergerak ke baris berikutnya ke atas\n\n\nMengambil kolom dari atas ke bawah\n\n    for i in range(start_row, end_row - 1, -1):\n            encrypted_text += transposed_matrix[i][end_col]\n\n        end_col += 1\nFor More Detail :\n\nfor i in range(start_row, end_row - 1, -1) : Loop ini mengiterasi dari baris start_row ke baris end_row - 1\nencrypted_text += transposed_matrix[i][end_col] : Menambahkan elemen dari baris i dan kolom end_col ke encrypted_text\nend_col += 1 : Menambahkan end_col untuk bergerak ke kolom berikutnya ke kiri.\n\n\nMengecek jika sudah mencapai kolom terakhir\n\n    if start_col &lt; end_col:\n            break\nFor More Detail :\n\nif start_col &lt; end_col: : Mengecek apakah start_col lebih kecil dari end_col\nbreak : Jika ya, keluar dari loop while.\n\n\nMengambil baris dari kiri ke kanan\n\n    for i in range(end_col, start_col + 1):\n            encrypted_text += transposed_matrix[end_row][i]\n\n        end_row += 1\nFor More Detail :\n\nfor i in range(end_col, start_col + 1) : Loop ini mengiterasi dari kolom end_col ke kolom start_col + 1\nencrypted_text += transposed_matrix[end_row][i] : Menambahkan elemen dari baris end_row dan kolom i ke encrypted_text\nend_row += 1 : Menambahkan end_row untuk bergerak ke baris berikutnya ke bawah.\n\n\nMengecek Jika Sudah Mencapai Baris Terakhir\n\n    if start_row &lt; end_row:\n            break\nFor More Detail :\n\nif start_row &lt; end_row : Mengecek apakah start_row lebih kecil dari end_row\nbreak : Jika ya, keluar dari loop while\n\n\nMengambil kolom dari bawah ke atas\n\n    for i in range(end_row, start_row + 1):\n            encrypted_text += transposed_matrix[i][start_col]\n\n        start_col -= 1\nFor More Detail :\n\nfor i in range(end_row, start_row + 1) : Loop ini mengiterasi dari baris end_row ke baris start_row + 1\nencrypted_text += transposed_matrix[i][start_col] : Menambahkan elemen dari baris i dan kolom start_col ke encrypted_text\nstart_col -= 1 : Mengurangi start_col untuk bergerak ke kolom berikutnya ke kanan\n\n\nMencetak teks terenkripsi (ciphertext)\n\nprint(\"Teks terenkripsi dengan pola spiral: \", encrypted_text[:length])\nFor More Detail :\n\nencrypted_text[:length]) : Memotong encrypted_text hingga panjang teks asli (length) untuk memastikan panjangnya sama dengan teks asli\n\nHASIL CIPHERTEXT : XUAETKAADTRUTNETKIAABTDMRNANYAMKGAATBNIPNAOSSKIAEJSEANPDIEAR\n\n\nProses Dekripsi\nMasukkan Ciphertext\ncipherText = input(\"cipher : \")\nMasukkan kunci\nrouteKey = int(input(\"Kunci: \"))\n\nMenentukan jumlah baris yang dibutuhkan untuk membentuk sebuah matriks dengan jumlah kolom yang telah ditentukan (routeKey). Matriks ini akan berisi teks x yang telah dibersihkan\n\n    kolom = routeKey\n    matrix = []\n    panjang = len(x)\n    temp = panjang/kolom\n    length = len(x)\n    bulat = round(temp)\n\n    if temp - bulat == 0:\n        jml_baris = bulat\n    else:\n        if temp - bulat &lt; 0:\n            jml_baris = bulat\n        else:\n            jml_baris = bulat + 1\n    print(jml_baris)\nFor More Detail :\n\nkolom = routeKey : Menetapkan jumlah kolom pada matriks dengan nilai routeKey\nmatrix = [] : Menginisialisasi sebuah list kosong yang akan digunakan untuk menyimpan elemen-elemen matriks\npanjang = len(x) : Menyimpan panjang dari teks x ke dalam variabel panjang\ntemp = panjang/kolom : Menghitung berapa banyak baris yang diperlukan dengan membagi panjang teks dengan jumlah kolom dan menyimpan hasilnya dalam variabel temp\nlength = len(x) : Menyimpan panjang teks x ke dalam variabel length\nbulat = round(temp) : Membulatkan hasil pembagian temp ke angka terdekat dan menyimpannya ke dalam variabel bulat\n\n\nMembangun matriks 2D yang berisi teks x yang telah dibersihkan (tanpa spasi), Matriks ini akan memiliki jml_baris baris dan kolom kolom\n\n    for i in range(jml_baris):\n        row = []\n        for j in range(kolom):\n            if i * kolom + j &lt; len(x):\n                elemen = [i * kolom + j]\n            else:\n                elemen = \" \"\n            row.append(elemen)\n        matrix.append(row)\nFor More Detail :\n\nfor i in range(jml_baris) : Loop ini mengiterasi dari 0 hingga jml_baris - 1, yang berarti setiap iterasi mewakili satu baris dalam matriks\nrow = [] : Membuat list kosong row yang akan menyimpan elemen-elemen untuk satu baris matriks\nfor j in range(kolom) : Loop ini mengiterasi dari 0 hingga kolom - 1, yang berarti setiap iterasi mewakili satu kolom dalam matriks\nif i * kolom + j &lt; len(x) : Mengecek apakah indeks (dihitung sebagai i * kolom + j) berada dalam rentang panjang teks x\nelemen = x[i * kolom + j] : Jika ya, Mengambil elemen dari teks x pada posisi i * kolom + j\nelemen = \" \" : Jika tidak, Mengisi elemen dengan spasi kosong jika indeks berada di luar panjang teks x -row.append(elemen) : Menambahkan elemen yang telah ditentukan (baik dari x atau spasi kosong) ke list row\nmatrix.append(row) : Menambahkan list row yang berisi elemen-elemen satu baris ke dalam list matrix\n\n\nMencetak matriks yang telah dibuat\n\n    print(\"Matriks yang Anda buat:\")\n    for row in matrix:\n        print(row)\n\nMembuat dan mencetak matriks transpose\n\n    transposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\n    for row in transposed_matrix:\n        print(row)\nFor More Detail :\n\nrow[i] for row in matrix : Menghasilkan list elemen ke-i dari setiap baris dalam matrix\nfor i in range(len(matrix[0]))] : Mengiterasi setiap indeks kolom dari matrix dan membentuk baris baru dari elemen-elemen tersebut\nfor row in transposed_matrix : Loop ini mengiterasi melalui setiap baris dalam transposed_matrix\n\n\nMengatur batas-batas dan kontrol iterasi saat mengisi transposed_matrix dalam pola spiral dengan karakter-karakter dari teks x\n\n    start_row, end_row = len(transposed_matrix) - 1, 0\n    start_col, end_col = len(transposed_matrix[0]) - 1, 0\n    text_index = 0\nFor More Detail :\n\nstart_row : Mengendalikan pengisian dari baris terakhir ke atas\nend_row : Mengendalikan pengisian dari baris pertama ke bawah\nend_row = 0 : Menetapkan indeks baris awal ke 0, yang berarti kita mulai dari baris pertama\nlen(transposed_matrix) : Memberikan jumlah baris dalam transposed_matrix\nMengurangkan 1 untuk mendapatkan indeks baris terakhir dari matriks transpose\nstart_col : Mengendalikan pengisian dari kolom terakhir ke kiri, sedangkan\nend_col : Mengendalikan pengisian dari kolom pertama ke kanan\nlen(transposed_matrix[0]) : Memberikan jumlah kolom dalam transposed_matrix\nMengurangkan 1 untuk mendapatkan indeks kolom terakhir dari matriks transpose\nend_col = 0 : Menetapkan indeks kolom awal ke 0, yang berarti kita mulai dari kolom pertama\ntext_index : Melacak posisi karakter dalam teks x yang sedang diproses\n\n\nMengisi baris pertama dari kanan ke kiri\n\n    while start_row &gt;= end_row and start_col &gt;= end_col:\n        # Fill the first row from the remaining rows\n        for i in range(start_col, end_col - 1, -1):\n            if text_index &lt; len(x):\n                transposed_matrix[start_row][i] = x[text_index]\n                text_index += 1\n\n        start_row -= 1\nFor More Detail :\n\nstart_col dan end_col : menentukan rentang kolom yang akan diisi\ntext_index : mengambil karakter dari teks x.\nTransposed_matrix[start_row][i] : Setiap karakter yang diambil dari x dimasukkan ke dalam posisi yang sesuai di t.\n\n\nMengisi kolom terakhir dari baris yang tersisa dalam matriks dengan karakter dari x dalam urutan spiral\n\n    for i in range(start_row, end_row - 1, -1):\n            if text_index &lt; len(x):\n                transposed_matrix[i][end_col] = x[text_index]\n                text_index += 1\n\n        end_col += 1\nFor More Detail :\n\nfor i in range(start_row, end_row - 1, -1) : Loop ini digunakan untuk iterasi melalui baris-baris dalam matriks dari start_row ke end_row - 1 dalam urutan menurun\nstart_row : Posisi baris awal untuk iterasi\nend_row - 1 : Posisi baris akhir (tidak termasuk) untuk iterasi\n-1 : Menunjukkan bahwa iterasi dilakukan secara menurun\nif text_index &lt; len(cipherText) : Kondisi ini memastikan bahwa indeks text_index masih dalam batas panjang cipherText\ntransposed_matrix[i][end_col] : Menunjukkan posisi kolom end_col dalam baris i dari matriks yang sedang diisi\ncipherText[text_index] : Karakter dari cipherText pada indeks text_index\ntext_index += 1 : Setelah menempatkan karakter dari cipherText ke dalam transposed_matrix, nilai text_index dinaikkan sebesar 1 untuk mempersiapkan karakter berikutnya pada iterasi selanjutnya\nend_col += 1 : Setelah menyelesaikan iterasi untuk mengisi kolom terakhir dari baris yang tersisa, end_col dinaikkan sebesar 1 untuk mempersempit batas kolom yang akan diisi pada iterasi berikutnya\n\n\nMenentukkan apakah batas kolom telah bertemu atau melewati satu sama lain, yang berarti bahwa semua kolom yang perlu diisi sudah selesai diproses\n\n    if start_col &lt; end_col:\n            break\n\nMengisi baris terakhir dari kolom yang tersisa dalam matriks dengan karakter dari x dalam urutan spiral.\n\n    for i in range(end_col, start_col + 1):\n            if text_index &lt; len(x):\n                transposed_matrix[end_row][i] = x[text_index]\n                text_index += 1\n\n        end_row += 1\nFor More Detail :\n\nfor i in range(end_col, start_col + 1): Loop ini digunakan untuk iterasi melalui kolom dari end_col ke start_col + 1\nend_col: Posisi kolom awal untuk iterasi\nstart_col + 1: Posisi kolom akhir (tidak termasuk) untuk iterasi, Menambah 1 untuk memasukkan start_col dalam iterasi\nif text_index &lt; len(x) : Kondisi ini memastikan bahwa indeks\ntext_index : Masih dalam batas panjang x. Hal ini untuk menghindari akses indeks yang tidak valid dari x\ntransposed_matrix[end_row][i] = x[text_index] Menetapkan karakter dari x pada posisi indeks text_index ke posisi [end_row][i] dalam transposed_matrix\ntransposed_matrix[end_row][i]: Menunjukkan posisi kolom i dalam baris end_row dari matriks yang sedang diisi.\nx[text_index]: Karakter dari x pada indeks text_index\ntext_index += 1 Setelah menempatkan karakter dari x ke dalam transposed_matrix, nilai text_index dinaikkan sebesar 1 untuk mempersiapkan karakter berikutnya pada iterasi selanjutnya\nend_row += 1 Setelah menyelesaikan iterasi untuk mengisi baris terakhir dari kolom yang tersisa, batas baris akhir (end_row) dinaikkan sebesar 1 untuk mempersempit batas baris yang akan diisi pada iterasi berikutnya\n\n\nMenghentikan loop while jika batas baris bertemu atau melewati satu sama lain, menandakan bahwa pengisian matriks dalam pola spiral sudah selesai\n\n    if start_row &lt; end_row:\n            break\n\nMengisi baris terakhir dari kolom yang tersisa dalam matriks dengan karakter dari x dalam urutan spiral\n\n    for i in range(end_row, start_row + 1):\n            if text_index &lt; len(x):\n                transposed_matrix[i][start_col] = x[text_index]\n                text_index += 1\n\n        start_col -= 1\nFor More Detail :\n\nfor i in range(end_row, start_row + 1) : Loop ini digunakan untuk iterasi melalui baris dari end_row ke start_row + 1 dalam urutan meningkat\nend_row : Posisi baris awal untuk iterasi\nstart_row + 1 : Posisi baris akhir (tidak termasuk) untuk iterasi, Menambah 1 untuk memasukkan start_row dalam iterasi\nif text_index &lt; len(x) : Kondisi ini memastikan bahwa indeks text_index masih dalam batas panjang x\ntransposed_matrix[i][start_col] : Menunjukkan posisi kolom start_col dalam baris i dari matriks yang sedang diisi\nx[text_index] : Karakter dari x pada indeks text_index\ntext_index += 1 : Nilai text_index dinaikkan sebesar 1 untuk mempersiapkan karakter berikutnya pada iterasi selanjutnya\nstart_col -= 1 : Batas kolom awal (start_col) dikurangi sebesar 1 untuk mempersempit batas kolom yang akan diisi pada iterasi berikutnya\n\n\nMencetak matriks yang telah diisi dengan ciphertext\n\n    print(\"Matriks setelah diisi dengan cipher secara spiral:\")\n    for row in transposed_matrix:\n        print(row)\n\nString kosong untuk menyimpan hasil teks yang telah didekripsi\n\n    decrypted_text = \"\"\n\nMenyimpan jumlah baris dari transposed_matrix dalam variabel num_rows\n\n    num_rows = len(transposed_matrix)\n\nMenghitung jumlah kolom dalam transposed_matrix\n\n    num_cols = len(transposed_matrix[0])\n\nMenggabungkan karakter-karakter dari transposed_matrix ke dalam decrypted_text dengan membaca matriks secara kolom demi kolom\n\n    for col in range(num_cols):  \n        for row in range(num_rows):  \n            decrypted_text += transposed_matrix[row][col]\nFor More Detail :\n\nfor col in range(num_cols): Loop for ini digunakan untuk iterasi melalui setiap kolom dalam transposed_matrix.\nnum_cols : Jumlah kolom dalam transposed_matrix Ini mengontrol jumlah iterasi, memastikan bahwa setiap kolom dalam matriks diproses\nfor row in range(num_rows) : Loop ini digunakan untuk iterasi melalui setiap baris dalam transposed_matrix untuk kolom yang saat ini sedang diproses oleh loop luar\nnum_rows : Jumlah baris dalam transposed_matrix Ini mengontrol jumlah iterasi, memastikan bahwa setiap baris dalam kolom yang sedang diproses dipertimbangkan\ntransposed_matrix[row][col] : Mengakses elemen pada baris row dan kolom col dalam matriks\ndecrypted_text +=: Operator += : Menambahkan karakter ke string decrypted_text\n\n\nMencetak hasil teks terdeskripsi\n\n    print(\"Teks terdekripsi setelah membaca secara berurutan:\")\n    print(decrypted_text)\nHasil Decrypted :\nTENTUKANPRIORITASANDASEBABKITATIDAKDAPATMENGERJAKANSEMUANYAX",
    "crumbs": [
      "Kriptografi Modern",
      "6. Elgamal"
    ]
  },
  {
    "objectID": "15_Diffie_Helman.html",
    "href": "15_Diffie_Helman.html",
    "title": "8. Transposisi Route",
    "section": "",
    "text": "Analogi Transposisi Route\nMari kita gunakan analogi kelas dengan siswa yang duduk di kursi dalam bentuk grid untuk menjelaskan algoritma transposisi route menggunakan pola spiral.\nBayangkan kamu adalah guru yang ingin mengatur ulang tempat duduk siswa sesuai pola spiral. Anda mulai dengan siswa pertama di sudut kiri atas, lalu bergerak ke kanan hingga akhir baris, turun ke baris berikutnya di sebelah kanan, kemudian bergerak ke kiri, dan seterusnya, sampai Anda kembali ke tengah grid. Berikut langkahnya :",
    "crumbs": [
      "Kriptografi Modern",
      "8. Transposisi Route"
    ]
  },
  {
    "objectID": "15_Diffie_Helman.html#implementasi-pada-python",
    "href": "15_Diffie_Helman.html#implementasi-pada-python",
    "title": "8. Transposisi Route",
    "section": "Implementasi Pada Python",
    "text": "Implementasi Pada Python\nMasukkan Plaintext\nCONTOH : TENTUKAN PRIORITAS ANDA SEBAB KITA TIDAK DAPAT MENGERJAKAN SEMUANYA X\nplainText = input(\"Plaintext : \")\nMasukkan Kunci\nCONTOH KEY : 5\nrouteKey = int(input(\"Kunci: \"))\nMenghapus Spasi\ncleanPlainTeks = plainTeks.replace(\" \", \"\")\nprint(cleanPlainTeks)\n\nProses Enkripsi\n\nMenyusun teks yang sudah dibersihkan ke dalam sebuah matriks dengan kolom sebagai jumlah kolom atau lebar matriks\n\n    kolom = routeKey\n    matrix = []\n    panjang = len(cleanPlainTeks)\n    temp = panjang/kolom\n    bulat = round(temp)\n\n    if temp - bulat == 0:\n        jml_baris = bulat\n    else:\n        if temp - bulat &lt; 0:\n            jml_baris = bulat\n        else:\n            jml_baris = bulat + 1\n    print(jml_baris)\nFor More Detail :\n\nkolom = routeKey : Menetapkan jumlah kolom pada matriks dengan nilai routeKey\nmatrix = [] : Menginisialisasi sebuah list kosong yang akan digunakan untuk menyimpan elemen-elemen matriks\npanjang = len(cleanPlainTeks) : Menghitung panjang teks yang sudah dibersihkan\ntemp = panjang/kolom : Menghitung berapa banyak baris yang diperlukan dengan membagi panjang teks dengan jumlah kolom dan menyimpan hasilnya dalam variabel temp\nbulat = round(temp) : Membulatkan hasil pembagian temp ke angka terdekat dan menyimpannya ke dalam variabel bulat\ntemp - bulat == 0 : hasil pembagian tepat bulat, maka jml_baris diambil dari bulat\ntemp - bulat &lt; 0 : hasil pembagian kurang dari bulat (mungkin karena temp lebih kecil dari bulat), dan juga mengambil jml_baris dari bulat\njml_baris = bulat + 1 : Jika kondisi sebelumnya tidak terpenuhi, maka perlu satu baris tambahan\n\n\nMembuat sebuah matriks (matrix) yang berisi teks yang sudah dibersihkan (cleanPlainTeks) menggunakan nilai jml_baris dan kolom yang telah dihitung sebelumnya\n\n    for i in range(jml_baris):\n        row = []\n        for j in range(kolom):\n            if i * kolom + j &lt; len(cleanPlainTeks):\n                elemen = cleanPlainTeks[i * kolom + j]\n            else:\n                elemen = \" \"\n            row.append(elemen)\n        matrix.append(row)\nFor More Detail :\n\nfor i in range(jml_baris) : Loop ini mengiterasi dari 0 hingga jml_baris - 1, yang berarti setiap iterasi mewakili satu baris dalam matriks\nrow = [] : Membuat list kosong row yang akan menyimpan elemen-elemen untuk satu baris matriks\nfor j in range(kolom) : Loop ini mengiterasi dari 0 hingga kolom - 1, yang berarti setiap iterasi mewakili satu kolom dalam matriks\nif i * kolom + j &lt; len(cleanPlainTeks) : Memastikan bahwa tidak melebihi panjang dari teks yang telah dibersihkan pada saat mengakses elemen cleanPlainTeks untuk dimasukkan ke dalam matrix\nelemen = x[i * kolom + j] : Jika ya, Mengambil elemen dari teks x pada posisi i * kolom + j\nelemen = \" \" : Jika tidak, Mengisi elemen dengan spasi kosong jika indeks berada di luar panjang teks x -row.append(elemen) : Menambahkan elemen yang telah ditentukan (baik dari x atau spasi kosong) ke list row\nmatrix.append(row) : Menambahkan list row yang berisi elemen-elemen satu baris ke dalam list matrix\n\n\nMencetak matrix\n\n    print(\"Matriks yang Anda buat:\")\n    for row in matrix:\n        print(row)\n\nMenghasilkan matriks transpose dari matrix yang telah dibuat\n\n    transposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\n    for row in transposed_matrix:\n        print(row)\nFor More Detail :\n\nrow[i] for row in matrix : Menghasilkan list elemen ke-i dari setiap baris dalam matrix\nfor i in range(len(matrix[0]))] : Mengiterasi setiap indeks kolom dari matrix dan membentuk baris baru dari elemen-elemen tersebut\nfor row in transposed_matrix : Loop ini mengiterasi melalui setiap baris dalam transposed_matrix\nprint(row) : Mencetak matriks transpose dari matrix\n\n\nString kosong yang akan digunakan untuk menyimpan teks yang terenkripsi\n\n    encrypted_text = \"\"\n\nMenandai batas awal dan akhir dari baris dan kolom pada matriks transpose\n\n    start_row, end_row = len(transposed_matrix) - 1, 0\n    start_col, end_col = len(transposed_matrix[0]) - 1, 0\n\nMengambil baris dari kanan ke kiri\n\n    while start_row &gt;= end_row and start_col &gt;= end_col:\n        for i in range(start_col, end_col - 1, -1):\n            encrypted_text += transposed_matrix[start_row][i]\n\n        start_row -= 1\nFor More Detail :\n\nwhile start_row &gt;= end_row and start_col &gt;= end_col : loop while yang berjalan selama start_row lebih besar dari atau sama dengan end_row dan start_col lebih besar dari atau sama dengan end_col\nfor i in range(start_col, end_col - 1, -1) : Loop ini mengiterasi dari kolom paling kanan (start_col) ke kolom paling kiri (end_col - 1)\nencrypted_text += transposed_matrix[start_row][i] : Menambahkan elemen dari baris start_row dan kolom i ke encrypted_text\nstart_row -= 1 : Mengurangi start_row untuk bergerak ke baris berikutnya ke atas\n\n\nMengambil kolom dari atas ke bawah\n\n    for i in range(start_row, end_row - 1, -1):\n            encrypted_text += transposed_matrix[i][end_col]\n\n        end_col += 1\nFor More Detail :\n\nfor i in range(start_row, end_row - 1, -1) : Loop ini mengiterasi dari baris start_row ke baris end_row - 1\nencrypted_text += transposed_matrix[i][end_col] : Menambahkan elemen dari baris i dan kolom end_col ke encrypted_text\nend_col += 1 : Menambahkan end_col untuk bergerak ke kolom berikutnya ke kiri.\n\n\nMengecek jika sudah mencapai kolom terakhir\n\n    if start_col &lt; end_col:\n            break\nFor More Detail :\n\nif start_col &lt; end_col: : Mengecek apakah start_col lebih kecil dari end_col\nbreak : Jika ya, keluar dari loop while.\n\n\nMengambil baris dari kiri ke kanan\n\n    for i in range(end_col, start_col + 1):\n            encrypted_text += transposed_matrix[end_row][i]\n\n        end_row += 1\nFor More Detail :\n\nfor i in range(end_col, start_col + 1) : Loop ini mengiterasi dari kolom end_col ke kolom start_col + 1\nencrypted_text += transposed_matrix[end_row][i] : Menambahkan elemen dari baris end_row dan kolom i ke encrypted_text\nend_row += 1 : Menambahkan end_row untuk bergerak ke baris berikutnya ke bawah.\n\n\nMengecek Jika Sudah Mencapai Baris Terakhir\n\n    if start_row &lt; end_row:\n            break\nFor More Detail :\n\nif start_row &lt; end_row : Mengecek apakah start_row lebih kecil dari end_row\nbreak : Jika ya, keluar dari loop while\n\n\nMengambil kolom dari bawah ke atas\n\n    for i in range(end_row, start_row + 1):\n            encrypted_text += transposed_matrix[i][start_col]\n\n        start_col -= 1\nFor More Detail :\n\nfor i in range(end_row, start_row + 1) : Loop ini mengiterasi dari baris end_row ke baris start_row + 1\nencrypted_text += transposed_matrix[i][start_col] : Menambahkan elemen dari baris i dan kolom start_col ke encrypted_text\nstart_col -= 1 : Mengurangi start_col untuk bergerak ke kolom berikutnya ke kanan\n\n\nMencetak teks terenkripsi (ciphertext)\n\nprint(\"Teks terenkripsi dengan pola spiral: \", encrypted_text[:length])\nFor More Detail :\n\nencrypted_text[:length]) : Memotong encrypted_text hingga panjang teks asli (length) untuk memastikan panjangnya sama dengan teks asli\n\nHASIL CIPHERTEXT : XUAETKAADTRUTNETKIAABTDMRNANYAMKGAATBNIPNAOSSKIAEJSEANPDIEAR\n\n\nProses Dekripsi\nMasukkan Ciphertext\ncipherText = input(\"cipher : \")\nMasukkan kunci\nrouteKey = int(input(\"Kunci: \"))\n\nMenentukan jumlah baris yang dibutuhkan untuk membentuk sebuah matriks dengan jumlah kolom yang telah ditentukan (routeKey). Matriks ini akan berisi teks x yang telah dibersihkan\n\n    kolom = routeKey\n    matrix = []\n    panjang = len(x)\n    temp = panjang/kolom\n    length = len(x)\n    bulat = round(temp)\n\n    if temp - bulat == 0:\n        jml_baris = bulat\n    else:\n        if temp - bulat &lt; 0:\n            jml_baris = bulat\n        else:\n            jml_baris = bulat + 1\n    print(jml_baris)\nFor More Detail :\n\nkolom = routeKey : Menetapkan jumlah kolom pada matriks dengan nilai routeKey\nmatrix = [] : Menginisialisasi sebuah list kosong yang akan digunakan untuk menyimpan elemen-elemen matriks\npanjang = len(x) : Menyimpan panjang dari teks x ke dalam variabel panjang\ntemp = panjang/kolom : Menghitung berapa banyak baris yang diperlukan dengan membagi panjang teks dengan jumlah kolom dan menyimpan hasilnya dalam variabel temp\nlength = len(x) : Menyimpan panjang teks x ke dalam variabel length\nbulat = round(temp) : Membulatkan hasil pembagian temp ke angka terdekat dan menyimpannya ke dalam variabel bulat\n\n\nMembangun matriks 2D yang berisi teks x yang telah dibersihkan (tanpa spasi), Matriks ini akan memiliki jml_baris baris dan kolom kolom\n\n    for i in range(jml_baris):\n        row = []\n        for j in range(kolom):\n            if i * kolom + j &lt; len(x):\n                elemen = [i * kolom + j]\n            else:\n                elemen = \" \"\n            row.append(elemen)\n        matrix.append(row)\nFor More Detail :\n\nfor i in range(jml_baris) : Loop ini mengiterasi dari 0 hingga jml_baris - 1, yang berarti setiap iterasi mewakili satu baris dalam matriks\nrow = [] : Membuat list kosong row yang akan menyimpan elemen-elemen untuk satu baris matriks\nfor j in range(kolom) : Loop ini mengiterasi dari 0 hingga kolom - 1, yang berarti setiap iterasi mewakili satu kolom dalam matriks\nif i * kolom + j &lt; len(x) : Mengecek apakah indeks (dihitung sebagai i * kolom + j) berada dalam rentang panjang teks x\nelemen = x[i * kolom + j] : Jika ya, Mengambil elemen dari teks x pada posisi i * kolom + j\nelemen = \" \" : Jika tidak, Mengisi elemen dengan spasi kosong jika indeks berada di luar panjang teks x -row.append(elemen) : Menambahkan elemen yang telah ditentukan (baik dari x atau spasi kosong) ke list row\nmatrix.append(row) : Menambahkan list row yang berisi elemen-elemen satu baris ke dalam list matrix\n\n\nMencetak matriks yang telah dibuat\n\n    print(\"Matriks yang Anda buat:\")\n    for row in matrix:\n        print(row)\n\nMembuat dan mencetak matriks transpose\n\n    transposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\n    for row in transposed_matrix:\n        print(row)\nFor More Detail :\n\nrow[i] for row in matrix : Menghasilkan list elemen ke-i dari setiap baris dalam matrix\nfor i in range(len(matrix[0]))] : Mengiterasi setiap indeks kolom dari matrix dan membentuk baris baru dari elemen-elemen tersebut\nfor row in transposed_matrix : Loop ini mengiterasi melalui setiap baris dalam transposed_matrix\n\n\nMengatur batas-batas dan kontrol iterasi saat mengisi transposed_matrix dalam pola spiral dengan karakter-karakter dari teks x\n\n    start_row, end_row = len(transposed_matrix) - 1, 0\n    start_col, end_col = len(transposed_matrix[0]) - 1, 0\n    text_index = 0\nFor More Detail :\n\nstart_row : Mengendalikan pengisian dari baris terakhir ke atas\nend_row : Mengendalikan pengisian dari baris pertama ke bawah\nend_row = 0 : Menetapkan indeks baris awal ke 0, yang berarti kita mulai dari baris pertama\nlen(transposed_matrix) : Memberikan jumlah baris dalam transposed_matrix\nMengurangkan 1 untuk mendapatkan indeks baris terakhir dari matriks transpose\nstart_col : Mengendalikan pengisian dari kolom terakhir ke kiri, sedangkan\nend_col : Mengendalikan pengisian dari kolom pertama ke kanan\nlen(transposed_matrix[0]) : Memberikan jumlah kolom dalam transposed_matrix\nMengurangkan 1 untuk mendapatkan indeks kolom terakhir dari matriks transpose\nend_col = 0 : Menetapkan indeks kolom awal ke 0, yang berarti kita mulai dari kolom pertama\ntext_index : Melacak posisi karakter dalam teks x yang sedang diproses\n\n\nMengisi baris pertama dari kanan ke kiri\n\n    while start_row &gt;= end_row and start_col &gt;= end_col:\n        # Fill the first row from the remaining rows\n        for i in range(start_col, end_col - 1, -1):\n            if text_index &lt; len(x):\n                transposed_matrix[start_row][i] = x[text_index]\n                text_index += 1\n\n        start_row -= 1\nFor More Detail :\n\nstart_col dan end_col : menentukan rentang kolom yang akan diisi\ntext_index : mengambil karakter dari teks x.\nTransposed_matrix[start_row][i] : Setiap karakter yang diambil dari x dimasukkan ke dalam posisi yang sesuai di t.\n\n\nMengisi kolom terakhir dari baris yang tersisa dalam matriks dengan karakter dari x dalam urutan spiral\n\n    for i in range(start_row, end_row - 1, -1):\n            if text_index &lt; len(x):\n                transposed_matrix[i][end_col] = x[text_index]\n                text_index += 1\n\n        end_col += 1\nFor More Detail :\n\nfor i in range(start_row, end_row - 1, -1) : Loop ini digunakan untuk iterasi melalui baris-baris dalam matriks dari start_row ke end_row - 1 dalam urutan menurun\nstart_row : Posisi baris awal untuk iterasi\nend_row - 1 : Posisi baris akhir (tidak termasuk) untuk iterasi\n-1 : Menunjukkan bahwa iterasi dilakukan secara menurun\nif text_index &lt; len(cipherText) : Kondisi ini memastikan bahwa indeks text_index masih dalam batas panjang cipherText\ntransposed_matrix[i][end_col] : Menunjukkan posisi kolom end_col dalam baris i dari matriks yang sedang diisi\ncipherText[text_index] : Karakter dari cipherText pada indeks text_index\ntext_index += 1 : Setelah menempatkan karakter dari cipherText ke dalam transposed_matrix, nilai text_index dinaikkan sebesar 1 untuk mempersiapkan karakter berikutnya pada iterasi selanjutnya\nend_col += 1 : Setelah menyelesaikan iterasi untuk mengisi kolom terakhir dari baris yang tersisa, end_col dinaikkan sebesar 1 untuk mempersempit batas kolom yang akan diisi pada iterasi berikutnya\n\n\nMenentukkan apakah batas kolom telah bertemu atau melewati satu sama lain, yang berarti bahwa semua kolom yang perlu diisi sudah selesai diproses\n\n    if start_col &lt; end_col:\n            break\n\nMengisi baris terakhir dari kolom yang tersisa dalam matriks dengan karakter dari x dalam urutan spiral.\n\n    for i in range(end_col, start_col + 1):\n            if text_index &lt; len(x):\n                transposed_matrix[end_row][i] = x[text_index]\n                text_index += 1\n\n        end_row += 1\nFor More Detail :\n\nfor i in range(end_col, start_col + 1): Loop ini digunakan untuk iterasi melalui kolom dari end_col ke start_col + 1\nend_col: Posisi kolom awal untuk iterasi\nstart_col + 1: Posisi kolom akhir (tidak termasuk) untuk iterasi, Menambah 1 untuk memasukkan start_col dalam iterasi\nif text_index &lt; len(x) : Kondisi ini memastikan bahwa indeks\ntext_index : Masih dalam batas panjang x. Hal ini untuk menghindari akses indeks yang tidak valid dari x\ntransposed_matrix[end_row][i] = x[text_index] Menetapkan karakter dari x pada posisi indeks text_index ke posisi [end_row][i] dalam transposed_matrix\ntransposed_matrix[end_row][i]: Menunjukkan posisi kolom i dalam baris end_row dari matriks yang sedang diisi.\nx[text_index]: Karakter dari x pada indeks text_index\ntext_index += 1 Setelah menempatkan karakter dari x ke dalam transposed_matrix, nilai text_index dinaikkan sebesar 1 untuk mempersiapkan karakter berikutnya pada iterasi selanjutnya\nend_row += 1 Setelah menyelesaikan iterasi untuk mengisi baris terakhir dari kolom yang tersisa, batas baris akhir (end_row) dinaikkan sebesar 1 untuk mempersempit batas baris yang akan diisi pada iterasi berikutnya\n\n\nMenghentikan loop while jika batas baris bertemu atau melewati satu sama lain, menandakan bahwa pengisian matriks dalam pola spiral sudah selesai\n\n    if start_row &lt; end_row:\n            break\n\nMengisi baris terakhir dari kolom yang tersisa dalam matriks dengan karakter dari x dalam urutan spiral\n\n    for i in range(end_row, start_row + 1):\n            if text_index &lt; len(x):\n                transposed_matrix[i][start_col] = x[text_index]\n                text_index += 1\n\n        start_col -= 1\nFor More Detail :\n\nfor i in range(end_row, start_row + 1) : Loop ini digunakan untuk iterasi melalui baris dari end_row ke start_row + 1 dalam urutan meningkat\nend_row : Posisi baris awal untuk iterasi\nstart_row + 1 : Posisi baris akhir (tidak termasuk) untuk iterasi, Menambah 1 untuk memasukkan start_row dalam iterasi\nif text_index &lt; len(x) : Kondisi ini memastikan bahwa indeks text_index masih dalam batas panjang x\ntransposed_matrix[i][start_col] : Menunjukkan posisi kolom start_col dalam baris i dari matriks yang sedang diisi\nx[text_index] : Karakter dari x pada indeks text_index\ntext_index += 1 : Nilai text_index dinaikkan sebesar 1 untuk mempersiapkan karakter berikutnya pada iterasi selanjutnya\nstart_col -= 1 : Batas kolom awal (start_col) dikurangi sebesar 1 untuk mempersempit batas kolom yang akan diisi pada iterasi berikutnya\n\n\nMencetak matriks yang telah diisi dengan ciphertext\n\n    print(\"Matriks setelah diisi dengan cipher secara spiral:\")\n    for row in transposed_matrix:\n        print(row)\n\nString kosong untuk menyimpan hasil teks yang telah didekripsi\n\n    decrypted_text = \"\"\n\nMenyimpan jumlah baris dari transposed_matrix dalam variabel num_rows\n\n    num_rows = len(transposed_matrix)\n\nMenghitung jumlah kolom dalam transposed_matrix\n\n    num_cols = len(transposed_matrix[0])\n\nMenggabungkan karakter-karakter dari transposed_matrix ke dalam decrypted_text dengan membaca matriks secara kolom demi kolom\n\n    for col in range(num_cols):  \n        for row in range(num_rows):  \n            decrypted_text += transposed_matrix[row][col]\nFor More Detail :\n\nfor col in range(num_cols): Loop for ini digunakan untuk iterasi melalui setiap kolom dalam transposed_matrix.\nnum_cols : Jumlah kolom dalam transposed_matrix Ini mengontrol jumlah iterasi, memastikan bahwa setiap kolom dalam matriks diproses\nfor row in range(num_rows) : Loop ini digunakan untuk iterasi melalui setiap baris dalam transposed_matrix untuk kolom yang saat ini sedang diproses oleh loop luar\nnum_rows : Jumlah baris dalam transposed_matrix Ini mengontrol jumlah iterasi, memastikan bahwa setiap baris dalam kolom yang sedang diproses dipertimbangkan\ntransposed_matrix[row][col] : Mengakses elemen pada baris row dan kolom col dalam matriks\ndecrypted_text +=: Operator += : Menambahkan karakter ke string decrypted_text\n\n\nMencetak hasil teks terdeskripsi\n\n    print(\"Teks terdekripsi setelah membaca secara berurutan:\")\n    print(decrypted_text)\nHasil Decrypted :\nTENTUKANPRIORITASANDASEBABKITATIDAKDAPATMENGERJAKANSEMUANYAX",
    "crumbs": [
      "Kriptografi Modern",
      "8. Transposisi Route"
    ]
  },
  {
    "objectID": "10_DES.html#teknik-enkripsi-des",
    "href": "10_DES.html#teknik-enkripsi-des",
    "title": "2. Data Encryption Standard",
    "section": "Teknik Enkripsi DES",
    "text": "Teknik Enkripsi DES\nMari kita gunakan analogi kelas dengan siswa yang duduk di kursi dalam bentuk grid untuk menjelaskan algoritma transposisi route menggunakan pola spiral.\nBayangkan kamu adalah guru yang ingin mengatur ulang tempat duduk siswa sesuai pola spiral. Anda mulai dengan siswa pertama di sudut kiri atas, lalu bergerak ke kanan hingga akhir baris, turun ke baris berikutnya di sebelah kanan, kemudian bergerak ke kiri, dan seterusnya, sampai Anda kembali ke tengah grid. Berikut langkahnya :\n\nSusunan awal :\n\nPola spiral Sekarang kita akan membaca huruf-huruf dalam pola spiral, dimulai dari sudut kiri atas dan bergerak searah jarum jam.\nBaca sesuai pola spiral Kita mulai dari A dan mengikuti pola spiral : \n Jika kita menulis urutan bacaan tersebut, kita \n mendapatkan : A B C D H L P O N M I E F G K J\nSekarang kita menulis ulang huruf-huruf tersebut sesuai urutan bacaan spiral :",
    "crumbs": [
      "Kriptografi Modern",
      "2. Data Encryption Standard"
    ]
  },
  {
    "objectID": "10_DES.html#skema-global-des",
    "href": "10_DES.html#skema-global-des",
    "title": "2. DES",
    "section": "",
    "text": "Setiap blok (plainteks atau cipherteks) dienkripsi dalam 16 putaran\nSetiap putaran menggunakan kunci internal berbeda\nKunci internal (56-bit) dibangkitkan dari kunci eksternal\nSetiap blok mengalami permutasi awal (IP), 16 putaran enciphering, dan inversi permutasi awal (IP-1)\n\n\n\n\nSkema Global Algoritma DES\n\n\n\n\nBlok plainteks dipermutasi dengan matriks permutasi awal (initial permutation atau IP)\nHasil permutasi awal kemudian di-enciphering- sebanyak 16 kali (16 putaran). Setiap putaran menggunakan kunci internal yang berbeda\nHasil enciphering kemudian dipermutasi dengan matriks permutasi balikan (invers initial permutation atau IP-1 ) menjadi blok cipherteks\n\n\n\n\nSkema Global Algoritma DES Lebih Rinci",
    "crumbs": [
      "Kriptografi Modern",
      "2. DES"
    ]
  },
  {
    "objectID": "7_transposisi_rail_fence.html#analogi-transposisi-railfence",
    "href": "7_transposisi_rail_fence.html#analogi-transposisi-railfence",
    "title": "7. Transposisi Rail Fence",
    "section": "",
    "text": "Mulailah dari tingkat pertama, lalu turun ke tingkat kedua, kemudian ke tingkat ketiga, dan kembali ke tingkat kedua, lalu ke tingkat pertama, dan seterusnya.\nTuliskan huruf-huruf pesan di sepanjang jalur ini.\nJadi, pesan “HELLO WORLD” akan disusun seperti ini :\n\n    H - - - O - - - R - -\n    - E - L - W - L - D -\n    - - L - - - O - - - -     \n\n\nTingkat pertama : “HOR”\nTingkat kedua : “ELWLD”\nTingkat ketiga : “LO”\n\n\n\n\n\nPertama, mereka menggambar garis-garis pada pagar besi sesuai dengan pola Rail Fence.\nLalu, mereka menempatkan huruf-huruf pesan terenkripsi kembali ke jalur-jalur sesuai dengan urutan.\nJadi, mereka akan menempatkan huruf-huruf dengan cara berikut:\n\n    H - - - O - - - R - -\n    - E - L - W - L - D -\n    - - L - - - O - - - - \n\n\n“H” (tingkat pertama)\n“E” (tingkat kedua)\n“L” (tingkat ketiga)\n“L” (kembali ke tingkat kedua)\n“O” (tingkat pertama)\n“W” (tingkat kedua)\n“O” (tingkat ketiga)\n“R” (kembali ke tingkat kedua)\n“L” (tingkat pertama)\n“D” (tingkat kedua)",
    "crumbs": [
      "Kriptografi Klasik",
      "7. Transposisi Rail Fence"
    ]
  },
  {
    "objectID": "7_transposisi_rail_fence.html#proses-enkripsi",
    "href": "7_transposisi_rail_fence.html#proses-enkripsi",
    "title": "7. Transposisi Rail Fence",
    "section": "Proses Enkripsi",
    "text": "Proses Enkripsi\n\nMembuat Matriks Kosong Sesuai Dengan Jumlah Baris (kunci)\n\n   rails = [[' ' for _ in range(len(plainText))] for _ in \n   range(railFenceKey)]\n\nMenentukan Arah Pola Zig-Zag Dari Huruf-Huruf Dalam Plaintext, jika direction = 1 maka pola turun, jika -1 maka pola naik\n\n   i, j = 0, 0\n   direction = 1  \n\nMenempatkan karakter-karakter dari plainText ke dalam matriks dalam pola zigzag sesuai dengan kunci Rail Fence\n\n   for char in plainText:\n     rails[i][j] = char\n     if i == 0:\n       direction = 1\n     elif i == railFenceKey - 1:\n       direction = -1\n     i += direction\n     j += 1\nFor More Detail :\n\nfor char in plainText : Setiap karakter dalam teks yang ingin dienkripsi akan diproses satu per satu\nrails[i][j] = char : Karakter saat ini ditempatkan di baris [i] dan kolom [j] dari matriks rails\nif i == 0: direction = 1 : Jika berada di baris teratas, ubah arah pergerakan ke bawah\nelif i == railFenceKey - 1 : direction = -1: Jika berada di baris terbawah, ubah arah pergerakan ke atas\ni += direction : Indeks baris [i] ditambah atau dikurangi sesuai dengan arah pergerakan (ke bawah atau ke atas) Mengupdate indeks kolom [j] untuk pindah ke karakter berikutnya:\nj += 1 : Indeks kolom [j] selalu bertambah satu untuk setiap karakter\n\n\nMembentuk Teks Terenkripsi Berdasarkan Pola Zig-Zag\n\n   enkripsi_teks = '\\n'.join([''.join(row) for row in rails])\n   print(\"* RAIL FENCE: \")\n   print(enkripsi_teks)\nFore More Detail :\n\nrow merepresentasikan setiap baris dalam matriks rails.\n''.join(row) : Menggabungkan semua karakter dalam baris row menjadi satu string\nfor row in rails : Ini adalah list comprehension yang mengiterasi setiap baris dalam matriks rails\n'\\n'.join([...]) : Menggabungkan semua string dalam daftar hasil dari list comprehension di langkah sebelumnya menjadi satu string besar\n\n\nMempersiapkan daftar untuk setiap baris (rail) dan mengatur agar kita mulai dari baris pertama dengan pergerakan ke bawah.\n\n   rails = [[] for _ in range(railFenceKey)]\n   index = 0\n   direction = 1\nFor More Detail :\n\nrails = [[] for _ in range(railFenceKey)] : Membuat daftar berisi daftar kosong untuk setiap baris (rail) sesuai dengan jumlah baris yang ditentukan oleh railFenceKey\nindex = 0 : Menentukan bahwa kita mulai dari baris pertama (index 0).\ndirection = 1 : Menentukan bahwa pergerakan awalnya ke bawah (nilai 1).\n\n\nMenempatkan karakter-karakter dari plainText ke dalam daftar rails dalam pola zigzag, mengubah arah pergerakan ketika mencapai baris pertama atau terakhir\n\n   for char in plainText:\n     rails[index].append(char)\n     if index == 0:\n       direction = 1\n\n     elif index == railFenceKey - 1:\n       direction = -1\n\n     index += direction\nFor More Detail :\n\nfor char in plainText : Looping untuk Mengiterasi setiap karakter dalam plainText satu per satu\nrails[index].append(char) : Menambahkan karakter char ke daftar rails pada posisi index saat ini\nif index == 0: direction = 1 : Jika index adalah 0 (baris pertama), ubah arah pergerakan ke bawah (direction = 1)\nelif index == railFenceKey - 1: direction = -1 : Jika index adalah railFenceKey - 1 (baris terakhir), ubah arah pergerakan ke atas (direction = -1)\nindex += direction : Menambah atau mengurangi index sesuai dengan direction\n\n\nmenggabungkan karakter-karakter yang telah disusun dalam matriks rails menjadi satu string yang merupakan teks terenkripsi (ciphertext)\n\n   enkripsi_teks = \"\".join([\"\".join(rail) for rail in rails])\n   print(\"CIPHERTEXT : \" + enkripsi_teks)\nFor More Detail :\n\n[\"\".join(rail) for rail in rails] : List comprehension yang menghasilkan daftar string, di mana setiap string adalah satu baris dari matriks rails\n\"\".join([...]) : Menggabungkan semua string dalam daftar menjadi satu string besar tanpa pemisah\n\"\".join(rail) : Menggabungkan semua karakter dalam baris rail menjadi satu string\nHasilnya adalah satu string panjang yang merupakan teks terenkripsi (enkripsi_teks).\n\n   CIPHERTEXT : UETD WONVRIA INNSATRISSAUNO",
    "crumbs": [
      "Kriptografi Klasik",
      "7. Transposisi Rail Fence"
    ]
  },
  {
    "objectID": "7_transposisi_rail_fence.html#proses-dekripsi",
    "href": "7_transposisi_rail_fence.html#proses-dekripsi",
    "title": "7. Transposisi Rail Fence",
    "section": "Proses Dekripsi",
    "text": "Proses Dekripsi\n\nMempersiapkan daftar untuk setiap baris (rail) dan mengatur agar kita mulai dari baris pertama dengan pergerakan ke bawah\n\n   rails = [[] for _ in range(railFenceKey)]\n   index = 0\n   direction = 1\nFor More Detail :\n\nrails = [[] for _ in range(railFenceKey)]: Membuat daftar berisi daftar kosong untuk setiap baris (rail) sesuai dengan jumlah baris yang ditentukan oleh railFenceKey Membuat placeholder untuk menyiapkan “kotak-kotak” yang akan mengorganisir karakter-karakter terenkripsi sehingga dapat didekripsi kembali dengan benar\nindex = 0: Menentukan bahwa kita mulai dari baris pertama (index 0)\ndirection = 1: Menentukan bahwa pergerakan awalnya ke bawah (nilai 1)\n\n\nMempersiapkan tempat untuk karakter-karakter dari teks terenkripsi agar bisa ditempatkan di posisi yang benar selama proses dekripsi\n\n   for char in enkripsi_teks:\n     rails[index].append(None)\n     if index == 0:\n       direction = 1\n  \n     elif index == railFenceKey - 1:\n       direction = -1\n     index += direction\nFor More Detail :\n\nif index == 0: direction = 1 : Mengiterasi setiap karakter dalam enkripsi_teks satu persatu.\nelif index == railFenceKey - 1: direction = -1: Jika index adalah railFenceKey - 1 (baris terakhir), ubah arah pergerakan ke atas (direction = -1)\nindex += direction : Menambah atau mengurangi index sesuai dengan direction. Jika direction = 1 bergerak ke bawah sedangkan direction = -1 bergerak ke atas\n\n\nMenempatkan karakter-karakter dari teks terenkripsi kembali ke posisi yang benar dalam matriks rails, sesuai dengan placeholder (None) yang telah ditandai sebelumnya\n\n   index_char = 0\n   for rail in rails:\n     for i in range(len(rail)):\n       rail[i] = enkripsi_teks[index_char]\n       index_char += 1\nFor More Detail :\n\nindex_char : Melacak posisi karakter dalam enkripsi_teks.\nfor rail in rails : Looping untuk mengiterasi setiap baris dalam matriks rails.\nfor i in range(len(rail)): : Mengiterasi setiap posisi dalam baris rail yang memiliki placeholder.\nrail[i] = enkripsi_teks[index_char] : Menempatkan karakter dari enkripsi_teks pada posisi yang sesuai dalam rail.\nindex_char += 1 : Meningkatkan index_char untuk berpindah ke karakter berikutnya dalam enkripsi_teks.\n\n\nMembaca kembali karakter-karakter dari matriks rails dalam urutan zigzag yang benar dan menyusunnya menjadi teks asli\n\n   index = 0\n   direction = 1\n   dekripsi_teks = []\nFor More Detail :\n\nindex : Melacak baris saat ini dalam matriks rails\ndirection : Menentukan arah pergerakan (ke bawah atau ke atas)\ndekripsi_teks = [] : Daftar yang akan menyimpan karakter karakter teks asli dalam urutan yang benar.\n\n\nMembaca kembali karakter-karakter dari matriks rails dalam urutan zigzag yang benar dan menyusunnya menjadi teks asli\n\n    for _ in range(len(enkripsi_teks)):\n      dekripsi_teks.append(rails[index].pop(0))\n      if index == 0:\n        direction = 1\n\n      elif index == railFenceKey - 1:\n        direction = -1\n      index += direction\nFor More Detail :\n\nfor _ in range(len(enkripsi_teks)): : Mengiterasi sebanyak panjang enkripsi_teks untuk memastikan semua karakter diproses.\ndekripsi_teks.append(rails[index]) : Mengambil karakter pertama dari baris index dalam rails dan menambahkannya ke dekripsi_teks\n.pop(0) : pop(0) menghapus dan mengembalikan elemen pertama dari baris index\nif index == 0: direction = 1 : Jika index adalah 0 (baris pertama), ubah arah pergerakan ke bawah (direction = 1)\nelif index == railFenceKey - 1: direction = -1 : Jika index adalah railFenceKey - 1 (baris terakhir), ubah arah pergerakan ke atas (direction = -1)\nindex += direction: Mengupdate indeks baris\n\n\nMenggabungkan karakter-karakter yang telah disusun kembali dalam dekripsi_teks menjadi satu string yang merupakan teks asli hasil dekripsi\n\n   railFenceDecryption = \"\".join(dekripsi_teks)\n   print(\" DECRYPTED : \" + railFenceDecryption)\nFor More Detail :\n\n''.join(dekripsi_teks) : Menggabungkan semua elemen dalam dekripsi_teks menjadi satu string tanpa pemisah.\nVariabel railFenceDecryption akan menyimpan string hasil dek\n\nHASIL DECRYPTED : UNIVERSITAS DIAN NUSWANTORO",
    "crumbs": [
      "Kriptografi Klasik",
      "7. Transposisi Rail Fence"
    ]
  },
  {
    "objectID": "5_transposisi_kolom.html#analogi-transposisi-kolom",
    "href": "5_transposisi_kolom.html#analogi-transposisi-kolom",
    "title": "5. Transposisi Kolom",
    "section": "",
    "text": "Susunan Awal:\n\nKolom 1 : A, B, C\nKolom 2 : D, E, F\nKolom 3 : G, H, I\n\nTransposisi Kolom:\n\nKita akan memutuskan untuk menukar posisi kolom-kolom ini. Misalnya, kolom 1 dipindahkan ke tempat kolom 3, kolom 2 tetap di tempat, dan kolom 3 dipindahkan ke tempat kolom 1.\n\nSusunan Setelah Transposisi:\n\nKolom 1 : G, H, I (dulu Kolom 3)\nKolom 2 : D, E, F\nKolom 3 : A, B, C (dulu Kolom 1)",
    "crumbs": [
      "Kriptografi Klasik",
      "5. Transposisi Kolom"
    ]
  },
  {
    "objectID": "5_transposisi_kolom.html#contoh-soal",
    "href": "5_transposisi_kolom.html#contoh-soal",
    "title": "5. Transposisi Kolom",
    "section": "Contoh Soal",
    "text": "Contoh Soal\nUntuk lebih jelasnya, terdapat sebuah pesan yaitu “TENTUKAN PRIORITAS ANDA SEBAB KITA TIDAK DAPAT MENGERJAKAN SEMUANYA X” yang akan dienkripsi menggunakan metode transposisi kolom dengan kata kunci “PENTING” Maka proses enkripsi nya adalah sebagai berikut:\nProses Penyandian\n\nBuat tabel dengan ukuran kolom sesuai dengan panjang dari kata kunci yang telah diproses sebelumnya\n\nKemudian masukkan kunci kedalam kolom tabel\n\nSelanjutnya, masukan pesan yang akan dienkripsi dengan cara menyisipkannya dari kiri ke kanan secara berurutan\n\nLalu kunci didefinisikan sesuai urutan abjad menjadi\n\nSetelah itu, kolom dengan urutan abjad terkecil dipindahkan ke posisi depan, diikuti dengan kolom urutan abjad terkecil lainya\n\nBaca huruf ciphertext dari atas kebawah kemudian dimulai lagi dari atas sesuai dengan kolom yang sudah diurutkan",
    "crumbs": [
      "Kriptografi Klasik",
      "5. Transposisi Kolom"
    ]
  },
  {
    "objectID": "5_transposisi_kolom.html#proses-enkripsi",
    "href": "5_transposisi_kolom.html#proses-enkripsi",
    "title": "5. Transposisi Kolom",
    "section": "Proses Enkripsi",
    "text": "Proses Enkripsi\n\nInisialisasi list untuk menyimpan urutan numerik dari setiap huruf alfabet\n\n    kolom = 0\n    angka_urutan = []\n\nMengonversi setiap huruf dalam kata kunci menjadi urutan numeriknya sesuai dengan posisi dalam alfabet\n\n    for huruf in key:\n        if huruf.isalpha():\n            angka_urutan.append(ascii[huruf.lower()])\n            kolom = kolom+1\n            cleanKey = angka_urutan\n\n    print(f\"Urutan kunci dari kata '{key}' adalah {angka_urutan}\")\nFor More Detail :\n\nfor huruf in key : Loop ini digunakan untuk memeriksa setiap huruf dalam variabel key, yang diharapkan merupakan kata kunci yang diberikan oleh pengguna\nif huruf.isalpha() : Kondisi ini memastikan bahwa hanya karakter alfabet yang akan diproses. Karakter non-alfabet akan dilewati\n`huruf.lower(): Mengubah huruf menjadi huruf kecil untuk konsistensi, sehingga tidak ada perbedaan antara huruf besar dan kecil\nascii[huruf.lower()] : Mengambil nilai urutan numerik dari huruf. Di sini diasumsikan ada sebuah kamus (dictionary) bernama ascii yang memetakan setiap huruf ke urutan numeriknya\nangka_urutan.append(...) : Menambahkan urutan numerik dari huruf ke dalam list angka_urutan\nkolom = kolom + 1 : Menghitung jumlah kolom dengan menambah nilai kolom setiap kali huruf diproses\ncleanKey = angka_urutan : Menyimpan hasil akhir urutan numerik ke dalam variabel cleanKey\n\n\nMembuat sebuah matriks kosong untuk menyimpan teks yang telah diolah dalam bentuk matriks\n\n    matrix = []\n\nMenghitung panjang dari teks yang telah dibersihkan dan disimpan dalam variabel cleanPlainTeks\n\n    panjang = len(cleanPlainTeks)\n\nMencari tahu berapa kali kolom dapat digunakan untuk memuat seluruh teks, dengan membagi panjang teks dengan jumlah kolom\n\n    temp = panjang/kolom\n\nMembulatkan hasil pembagian sebelumnya ke bilangan bulat terdekat\n\n    bulat = round(temp)\n\nMenghitung jumlah baris untuk memuat teks dalam matriks\n\n    if temp - bulat == 0:\n        baris = bulat\n    else:\n        if temp - bulat &lt; 0:\n            baris = bulat\n        else:\n            baris = bulat + 1\n    print(baris)\nFor More Detail :\n\ntemp : hasil pembagian panjang teks dengan jumlah kolom\nbulat: hasil pembagian yang dibulatkan ke bilangan bulat terdekat. Jika temp adalah bilangan bulat (tidak ada sisa), jumlah baris adalah bulat. Jika ada sisa, jumlah baris adalah bulat + 1\n\n\nMengisi matriks dengan karakter dari teks yang telah dibersihkan (cleanPlainTeks)\n\n    for i in range(baris):\n        row = []\n        for j in range(kolom):\n            if i * kolom + j &lt; len(cleanPlainTeks):\n                elemen = cleanPlainTeks[i * kolom + j]\n            else:\n                elemen = \" \"\n            row.append(elemen)\n        matrix.append(row)\nFor More Detail :\n\nfor i in range(baris) : Loop untuk setiap baris dalam matriks\nrow = [] : Inisialisasi list kosong untuk setiap baris\nif i * kolom + j &lt; len(cleanPlainTeks) : Memeriksa apakah indeks saat ini berada dalam rentang panjang teks yang dibersihkan\nelemen = cleanPlainTeks[i * kolom + j] : Jika indeks berada dalam rentang, maka ambil karakter dari cleanPlainTeks berdasarkan indeks yang dihitung\nelse : Jika indeks melebihi panjang teks, isi elemen dengan spasi\nrow.append(elemen) : Menambahkan elemen ke dalam baris\nmatrix.append(row) : Menambahkan baris yang telah diisi ke dalam matriks\n\nMencetak matriks\n    print(\"Matriks yang Anda buat:\")\n    for row in matrix:\n        print(row)\n\nMentransposisikan matriks yang telah dibuat dan kemudian mencetak matriks yang telah ditransposisikan\n\n    transposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\n    for row in transposed_matrix:\n        print(row)\nFor More Detail :\n\nfor i in range(len(matrix[0])) : Iterasi melalui indeks kolom matriks asli\nrow[i] for row in matrix : Untuk setiap indeks kolom i, ambil elemen i dari setiap baris dalam matriks asli dan akan menghasilkan kolom baru dari elemen-elemen tersebut, membentuk baris baru di matriks yang ditransposisikan\n\n\nMembuat list kosong dengan panjang yang sama dengan cleanKey untuk menyimpan urutan indeks\n\n    order = [None] * len(cleanKey)\n\nMengurutkan elemen-elemen dalam cleanKey berdasarkan nilai terkecil hingga terbesar\n\n    i = 0\n    while len(cleanKey) &gt; 0:\n        non_none_values = list(filter(lambda x: x is not None, cleanKey))\n        if non_none_values:\n            nilai_terkecil = min(non_none_values)\n            marker = cleanKey.index(nilai_terkecil)\n\n            order[marker] = i\n            cleanKey[marker] = None \n            i = i + 1\n        else:\n            break\n    print(order)\nFor More Detail :\n\ni = 0 : Inisialisasi counter i\nwhile len(cleanKey) &gt; 0 : Loop hingga cleanKey kosong (semua elemen None)\nnon_none_values = list(filter(lambda x: x is not None, cleanKey)) : Membuat list yang hanya berisi elemen-elemen cleanKey yang bukan None\nif non_none_values : Mengecek apakah list non_none_values tidak kosong nilai_terkecil = min(non_none_values) : Mencari nilai terkecil dari non_none_values\nmarker = cleanKey.index(nilai_terkecil) : Mendapatkan indeks dari nilai terkecil dalam cleanKey Menyimpan Urutan dan menghapus nilai terkecil\norder[marker] = i : Menyimpan urutan i pada indeks marker di list order\ncleanKey[marker] = None : Menghapus nilai terkecil dari cleanKey dengan mengubahnya menjadi None\ni = i + 1 : Increment counter i\n\n\nMengubah urutan kolom matriks transposed_matrix berdasarkan urutan yang telah diatur dalam order, dan kemudian mencetak matriks yang sudah diubah urutan kolomnya\n\n    new_matrix = []\n    while len(order) &gt; 0:\n        non_none_values = list(filter(lambda x: x is not None, order))\n        if non_none_values:\n            nilai_terkecil = min(non_none_values)\n            marker = order.index(nilai_terkecil)\n        \n            new_matrix.append(transposed_matrix[marker])\n            order[marker] = None\n        else:\n            break\n\n    for row in new_matrix:\n        print(row)\nFor More Detail :\n\nnew_matrix = [] : Membuat list kosong new_matrix untuk menampung baris-baris matriks yang baru diurutkan Looping untuk Mengubah Urutan Kolom:\nwhile len(order) &gt; 0 : Melakukan looping selama masih ada elemen yang tersisa dalam order\nnon_none_values = list(filter(lambda x: x is not None, order)) : Membuat list non_none_values yang hanya berisi nilai-nilai yang bukan None dari order\nif non_none_values : Memeriksa apakah non_none_values tidak kosong\nnilai_terkecil = min(non_none_values) : Menemukan nilai terkecil dari non_none_values\nmarker = order.index(nilai_terkecil) : Mencari indeks dari nilai_terkecil dalam order\nnew_matrix.append(transposed_matrix[marker]) : Menambahkan baris dari transposed_matrix yang sesuai dengan marker ke new_matrix\norder[marker] = None : Menghapus nilai yang telah diproses dengan mengubahnya menjadi None\nelse: break : Menghentikan loop jika non_none_values kosong, yang berarti semua nilai dalam order telah diproses\n\n\nMengonversi matriks new_matrix menjadi string tunggal dengan menggabungkan nilai-nilainya secara berurutan dan menghapus spasi ekstra di akhir string\n\n    result_string = \"\"\n\n    for row in new_matrix:\n        for value in row:\n            result_string += str(value)\n\n    result_string = result_string.strip()\n\n    print(result_string)\nFor More Detail :\n\nresult_string = \"\" : Inisialisasi string kosong result_string yang akan digunakan untuk menyimpan hasil akhir\nfor row in new_matrix: : Melakukan iterasi melalui setiap baris dalam new_matrix\nfor value in row: : Melakukan iterasi melalui setiap nilai dalam baris row\nresult_string += str(value) : Mengonversi nilai value menjadi string (jika belum string) dan menambahkannya ke result_string\nresult_string = result_string.strip() : Menghapus spasi ekstra di awal dan akhir string menggunakan metode strip()\n\nHASIL CIPHERTEXT : ENTKFINOKKM TIAIRA",
    "crumbs": [
      "Kriptografi Klasik",
      "5. Transposisi Kolom"
    ]
  },
  {
    "objectID": "5_transposisi_kolom.html#proses-dekripsi",
    "href": "5_transposisi_kolom.html#proses-dekripsi",
    "title": "5. Transposisi Kolom",
    "section": "Proses Dekripsi",
    "text": "Proses Dekripsi\nMasukkan ciphertext\ncipherTeks = input(\"masukkan kata : \")\nMasukkan kunci\nkey = input(\"masukkan kunci : \")\nMembersihkan ciphertext dari spasi\n    cleanCipherTeks = cipherTeks.replace(\" \", \" \")\n    print(cleanCipherTeks)\n\nInisialisasi list untuk menyimpan urutan numerik dari setiap huruf alfabet\n\n    kolom = 0\n    angka_urutan = []\n\nMengonversi setiap huruf dalam kata kunci menjadi urutan numeriknya sesuai dengan posisi dalam alfabet\n\n    for huruf in key:\n        if huruf.isalpha():\n            angka_urutan.append(ascii[huruf.lower()])\n            kolom = kolom+1\n            cleanKey = angka_urutan\n\n    print(f\"Urutan kunci dari kata '{key}' adalah: {angka_urutan}\")\nFor More Detail :\n\nfor huruf in key : Loop ini digunakan untuk memeriksa setiap huruf dalam variabel key, yang diharapkan merupakan kata kunci yang diberikan oleh pengguna\nif huruf.isalpha() : Kondisi ini memastikan bahwa hanya karakter alfabet yang akan diproses. Karakter non-alfabet akan dilewati\n`huruf.lower(): Mengubah huruf menjadi huruf kecil untuk konsistensi, sehingga tidak ada perbedaan antara huruf besar dan kecil\nascii[huruf.lower()] : Mengambil nilai urutan numerik dari huruf. Di sini diasumsikan ada sebuah kamus (dictionary) bernama ascii yang memetakan setiap huruf ke urutan numeriknya\nangka_urutan.append(...) : Menambahkan urutan numerik dari huruf ke dalam list angka_urutan\nkolom = kolom + 1 : Menghitung jumlah kolom dengan menambah nilai kolom setiap kali huruf diproses\ncleanKey = angka_urutan : Menyimpan hasil akhir urutan numerik ke dalam variabel cleanKey\n\n\nMembuat sebuah matriks kosong untuk menyimpan teks yang telah diolah dalam bentuk matriks\n\n    matrix = []\n\nMenghitung panjang dari teks yang telah dibersihkan dan disimpan dalam variabel cleanPlainTeks\n\n    panjang = len(cleanCipherTeks)\n\nMencari tahu berapa kali kolom dapat digunakan untuk memuat seluruh teks, dengan membagi panjang teks dengan jumlah kolom\n\n    temp = panjang/kolom\n\nMenyimpan jumlah baris yang dibutuhkan dalam matriks setelah pembulatan, membentuk matriks dengan jumlah baris yang cukup untuk menampung semua karakter dalam teks cipher\n\n    baris = round(temp)\n    print(baris)\n\nMembentuk matriks dari teks cipher yang bersih (cleanCipherTeks) dengan jumlah kolom yang tetap, dan jumlah baris yang telah dihitung sebelumnya\n\n    for i in range(baris):\n        row = []\n        for j in range(kolom):\n            if i * kolom + j &lt; len(cleanCipherTeks):\n                elemen = cleanCipherTeks[i + baris * j]\n            else:\n                elemen = \"a\"\n            row.append(elemen)\n        matrix.append(row)\nFor More Detail :\n\nfor i in range(baris) : Loop untuk setiap baris dalam matriks\nrow = [] : Inisialisasi list kosong untuk setiap baris\nif i * kolom + j &lt; len(cleanCipherTeks) : Memeriksa apakah indeks saat ini berada dalam rentang panjang teks yang dibersihkan.\nelemen = cleanCipherTeks[i * baris + j] : Jika indeks berada dalam rentang, maka ambil karakter dari cleanCipherTeks berdasarkan indeks yang dihitung\nelse: Jika indeks melebihi panjang teks, isi elemen dengan spasi\nrow.append(elemen) : Menambahkan elemen ke dalam baris\nmatrix.append(row) : Menambahkan baris yang telah diisi ke dalam matriks\n\n\nMencetak matriks\n\n    print(\"Matriks yang Anda buat:\")\n    for row in matrix:\n        print(row)\n\nMentransposisikan matriks yang telah dibuat dan kemudian mencetak matriks yang telah ditransposisikan\n\n    transposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\n    for row in transposed_matrix:\n        print(row)\nFor More Detail :\n\nfor i in range(len(matrix[0])) : Iterasi melalui indeks kolom matriks asli\nrow[i] for row in matrix : Untuk setiap indeks kolom i, ambil elemen i dari setiap baris dalam matriks asli dan akan menghasilkan kolom baru dari elemen-elemen tersebut, membentuk baris baru di matriks yang ditransposisikan\n\n\nMembuat list kosong dengan panjang yang sama dengan cleanKey untuk menyimpan urutan indeks\n\n    order = [None] * len(cleanKey)\n\nMengurutkan elemen-elemen dalam cleanKey berdasarkan nilai terkecil hingga terbesar\n\n    i = 0\n    while len(cleanKey) &gt; 0:\n        non_none_values = list(filter(lambda x: x is not None, cleanKey))\n        if non_none_values:\n            nilai_terkecil = min(non_none_values)\n            marker = cleanKey.index(nilai_terkecil)\n            order[marker] = i\n            cleanKey[marker] = None  \n            i = i + 1\n        else:\n            break\n    print(order)\nFor More Detail :\n\ni = 0 : Inisialisasi counter i\nwhile len(cleanKey) &gt; 0 : Loop hingga cleanKey kosong (semua elemen None)\nnon_none_values = list(filter(lambda x: x is not None, cleanKey)) : Membuat list yang hanya berisi elemen-elemen cleanKey yang bukan None\nif non_none_values : Mengecek apakah list non_none_values tidak kosong\nnilai_terkecil = min(non_none_values) : Mencari nilai terkecil dari non_none_values\nmarker = cleanKey.index(nilai_terkecil) : Mendapatkan indeks dari nilai terkecil dalam cleanKey menyimpan urutan dan menghapus nilai terkecil\norder[marker] = i : Menyimpan urutan i pada indeks marker di list order\ncleanKey[marker] = None : Menghapus nilai terkecil dari cleanKey dengan mengubahnya menjadi None\ni = i + 1 : Increment counter i\n\n\nMenampilkan matriks setelah melakukan transposisi sesuai dengan urutan tertentu (order)\n\n    transposed_matrix = [transposed_matrix[i] for i in order]\n\n    for row in transposed_matrix:\n        print(row)\nFor More Detail :\n\ntransposed_matrix = [transposed_matrix[i] for i in order] : Membuat transposed_matrix baru berdasarkan urutan yang ditentukan dalam order\nfor row in transposed_matrix : Mencetak setiap baris dalam transposed_matrix\n\n\nMelakukan transposisi matriks dengam menukar baris dengan kolom\n\n    matriks = [[row[i] for row in transposed_matrix] for i in range(len(transposed_matrix[0]))]\n    for row in matriks:\n        print(row)\nFor More Detail :\n\nfor i in range(len(transposed_matrix[0])) : Iterasi melalui setiap indeks kolom dalam transposed_matrix\nrow[i] for row in transposed_matrix : Mengambil elemen ke-i dari setiap baris dalam transposed_matrix, sehingga membentuk kolom ke-i dalam matriks baru\nfor row in matriks : Iterasi melalui setiap baris dalam matriks yang telah ditransposisi\n\n\nMenggabungkan semua elemen dalam matriks transposisi menjadi satu string dan menghilangkan spasi di awal dan akhir\n\n    result_string = \"\"\n\n    for row in matriks:\n        for value in row:\n            result_string += str(value)\n\n    result_string = result_string.strip()\n\n    print(result_string)\nFor More Detail :\n\nresult_string = \"\" : Menginisialisasi variabel result_string sebagai string kosong untuk menyimpan hasil akhir\nfor row in matriks : Iterasi melalui setiap baris dalam matriks yang telah ditransposisi\nfor value in row : Iterasi melalui setiap nilai dalam baris tersebut\nresult_string += str(value) : Menambahkan setiap nilai dari baris ke dalam result_string, nilai tersebut diubah menjadi string terlebih dahulu.\nresult_string = result_string.strip() : Menghapus spasi di awal dan akhir dari result_string\nprint(result_string) : Mencetak result_string yang berisi semua elemen matriks yang digabungkan menjadi satu string\n\nHASIL DEKRIPSI : TEKNIKINFORMATIKA\nPerbedaan Proses :\n\nEnkripsi: Teks asli diubah menjadi matriks berdasarkan kolom kunci, kemudian kolom-kolom diurutkan berdasarkan kunci. Pada enkripsi, transposed_matrix adalah matriks transposisi dari matrix awal\nDekripsi: Teks sandi diubah menjadi matriks berdasarkan kolom kunci, kemudian baris-baris diurutkan berdasarkan kunci untuk mengembalikan teks asli. Pada dekripsi, transposed_matrix diurutkan berdasarkan order untuk mengembalikan teks asli",
    "crumbs": [
      "Kriptografi Klasik",
      "5. Transposisi Kolom"
    ]
  },
  {
    "objectID": "8_transposisi_route.html#analogi-transposisi-route",
    "href": "8_transposisi_route.html#analogi-transposisi-route",
    "title": "8. Transposisi Route",
    "section": "",
    "text": "Susunan awal :\n\nPola spiral Sekarang kita akan membaca huruf-huruf dalam pola spiral, dimulai dari sudut kiri atas dan bergerak searah jarum jam.\nBaca sesuai pola spiral Kita mulai dari A dan mengikuti pola spiral : \n Jika kita menulis urutan bacaan tersebut, kita \n mendapatkan : A B C D H L P O N M I E F G K J\nSekarang kita menulis ulang huruf-huruf tersebut sesuai urutan bacaan spiral :",
    "crumbs": [
      "Kriptografi Klasik",
      "8. Transposisi Route"
    ]
  },
  {
    "objectID": "8_transposisi_route.html#proses-enkripsi",
    "href": "8_transposisi_route.html#proses-enkripsi",
    "title": "8. Transposisi Route",
    "section": "Proses Enkripsi",
    "text": "Proses Enkripsi\n\nMenyusun teks yang sudah dibersihkan ke dalam sebuah matriks dengan kolom sebagai jumlah kolom atau lebar matriks\n\n    kolom = routeKey\n    matrix = []\n    panjang = len(cleanPlainTeks)\n    temp = panjang/kolom\n    bulat = round(temp)\n\n    if temp - bulat == 0:\n        jml_baris = bulat\n    else:\n        if temp - bulat &lt; 0:\n            jml_baris = bulat\n        else:\n            jml_baris = bulat + 1\n    print(jml_baris)\nFor More Detail :\n\nkolom = routeKey : Menetapkan jumlah kolom pada matriks dengan nilai routeKey\nmatrix = [] : Menginisialisasi sebuah list kosong yang akan digunakan untuk menyimpan elemen-elemen matriks\npanjang = len(cleanPlainTeks) : Menghitung panjang teks yang sudah dibersihkan\ntemp = panjang/kolom : Menghitung berapa banyak baris yang diperlukan dengan membagi panjang teks dengan jumlah kolom dan menyimpan hasilnya dalam variabel temp\nbulat = round(temp) : Membulatkan hasil pembagian temp ke angka terdekat dan menyimpannya ke dalam variabel bulat\ntemp - bulat == 0 : hasil pembagian tepat bulat, maka jml_baris diambil dari bulat\ntemp - bulat &lt; 0 : hasil pembagian kurang dari bulat (mungkin karena temp lebih kecil dari bulat), dan juga mengambil jml_baris dari bulat\njml_baris = bulat + 1 : Jika kondisi sebelumnya tidak terpenuhi, maka perlu satu baris tambahan\n\n\nMembuat sebuah matriks (matrix) yang berisi teks yang sudah dibersihkan (cleanPlainTeks) menggunakan nilai jml_baris dan kolom yang telah dihitung sebelumnya\n\n    for i in range(jml_baris):\n        row = []\n        for j in range(kolom):\n            if i * kolom + j &lt; len(cleanPlainTeks):\n                elemen = cleanPlainTeks[i * kolom + j]\n            else:\n                elemen = \" \"\n            row.append(elemen)\n        matrix.append(row)\nFor More Detail :\n\nfor i in range(jml_baris) : Loop ini mengiterasi dari 0 hingga jml_baris - 1, yang berarti setiap iterasi mewakili satu baris dalam matriks\nrow = [] : Membuat list kosong row yang akan menyimpan elemen-elemen untuk satu baris matriks\nfor j in range(kolom) : Loop ini mengiterasi dari 0 hingga kolom - 1, yang berarti setiap iterasi mewakili satu kolom dalam matriks\nif i * kolom + j &lt; len(cleanPlainTeks) : Memastikan bahwa tidak melebihi panjang dari teks yang telah dibersihkan pada saat mengakses elemen cleanPlainTeks untuk dimasukkan ke dalam matrix\nelemen = x[i * kolom + j] : Jika ya, Mengambil elemen dari teks x pada posisi i * kolom + j\nelemen = \" \" : Jika tidak, Mengisi elemen dengan spasi kosong jika indeks berada di luar panjang teks x -row.append(elemen) : Menambahkan elemen yang telah ditentukan (baik dari x atau spasi kosong) ke list row\nmatrix.append(row) : Menambahkan list row yang berisi elemen-elemen satu baris ke dalam list matrix\n\n\nMencetak matrix\n\n    print(\"Matriks yang Anda buat:\")\n    for row in matrix:\n        print(row)\n\nMenghasilkan matriks transpose dari matrix yang telah dibuat\n\n    transposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\n    for row in transposed_matrix:\n        print(row)\nFor More Detail :\n\nrow[i] for row in matrix : Menghasilkan list elemen ke-i dari setiap baris dalam matrix\nfor i in range(len(matrix[0]))] : Mengiterasi setiap indeks kolom dari matrix dan membentuk baris baru dari elemen-elemen tersebut\nfor row in transposed_matrix : Loop ini mengiterasi melalui setiap baris dalam transposed_matrix\nprint(row) : Mencetak matriks transpose dari matrix\n\n\nString kosong yang akan digunakan untuk menyimpan teks yang terenkripsi\n\n    encrypted_text = \"\"\n\nMenandai batas awal dan akhir dari baris dan kolom pada matriks transpose\n\n    start_row, end_row = len(transposed_matrix) - 1, 0\n    start_col, end_col = len(transposed_matrix[0]) - 1, 0\n\nMengambil baris dari kanan ke kiri\n\n    while start_row &gt;= end_row and start_col &gt;= end_col:\n        for i in range(start_col, end_col - 1, -1):\n            encrypted_text += transposed_matrix[start_row][i]\n\n        start_row -= 1\nFor More Detail :\n\nwhile start_row &gt;= end_row and start_col &gt;= end_col : loop while yang berjalan selama start_row lebih besar dari atau sama dengan end_row dan start_col lebih besar dari atau sama dengan end_col\nfor i in range(start_col, end_col - 1, -1) : Loop ini mengiterasi dari kolom paling kanan (start_col) ke kolom paling kiri (end_col - 1)\nencrypted_text += transposed_matrix[start_row][i] : Menambahkan elemen dari baris start_row dan kolom i ke encrypted_text\nstart_row -= 1 : Mengurangi start_row untuk bergerak ke baris berikutnya ke atas\n\n\nMengambil kolom dari atas ke bawah\n\n    for i in range(start_row, end_row - 1, -1):\n            encrypted_text += transposed_matrix[i][end_col]\n\n        end_col += 1\nFor More Detail :\n\nfor i in range(start_row, end_row - 1, -1) : Loop ini mengiterasi dari baris start_row ke baris end_row - 1\nencrypted_text += transposed_matrix[i][end_col] : Menambahkan elemen dari baris i dan kolom end_col ke encrypted_text\nend_col += 1 : Menambahkan end_col untuk bergerak ke kolom berikutnya ke kiri.\n\n\nMengecek jika sudah mencapai kolom terakhir\n\n    if start_col &lt; end_col:\n            break\nFor More Detail :\n\nif start_col &lt; end_col: : Mengecek apakah start_col lebih kecil dari end_col\nbreak : Jika ya, keluar dari loop while.\n\n\nMengambil baris dari kiri ke kanan\n\n    for i in range(end_col, start_col + 1):\n            encrypted_text += transposed_matrix[end_row][i]\n\n        end_row += 1\nFor More Detail :\n\nfor i in range(end_col, start_col + 1) : Loop ini mengiterasi dari kolom end_col ke kolom start_col + 1\nencrypted_text += transposed_matrix[end_row][i] : Menambahkan elemen dari baris end_row dan kolom i ke encrypted_text\nend_row += 1 : Menambahkan end_row untuk bergerak ke baris berikutnya ke bawah.\n\n\nMengecek Jika Sudah Mencapai Baris Terakhir\n\n    if start_row &lt; end_row:\n            break\nFor More Detail :\n\nif start_row &lt; end_row : Mengecek apakah start_row lebih kecil dari end_row\nbreak : Jika ya, keluar dari loop while\n\n\nMengambil kolom dari bawah ke atas\n\n    for i in range(end_row, start_row + 1):\n            encrypted_text += transposed_matrix[i][start_col]\n\n        start_col -= 1\nFor More Detail :\n\nfor i in range(end_row, start_row + 1) : Loop ini mengiterasi dari baris end_row ke baris start_row + 1\nencrypted_text += transposed_matrix[i][start_col] : Menambahkan elemen dari baris i dan kolom start_col ke encrypted_text\nstart_col -= 1 : Mengurangi start_col untuk bergerak ke kolom berikutnya ke kanan\n\n\nMencetak teks terenkripsi (ciphertext)\n\nprint(\"Teks terenkripsi dengan pola spiral: \", encrypted_text[:length])\nFor More Detail :\n\nencrypted_text[:length]) : Memotong encrypted_text hingga panjang teks asli (length) untuk memastikan panjangnya sama dengan teks asli\n\nHASIL CIPHERTEXT : XUAETKAADTRUTNETKIAABTDMRNANYAMKGAATBNIPNAOSSKIAEJSEANPDIEAR",
    "crumbs": [
      "Kriptografi Klasik",
      "8. Transposisi Route"
    ]
  },
  {
    "objectID": "8_transposisi_route.html#proses-dekripsi",
    "href": "8_transposisi_route.html#proses-dekripsi",
    "title": "8. Transposisi Route",
    "section": "Proses Dekripsi",
    "text": "Proses Dekripsi\nMasukkan Ciphertext\ncipherText = input(\"cipher : \")\nMasukkan kunci\nrouteKey = int(input(\"Kunci: \"))\n\nMenentukan jumlah baris yang dibutuhkan untuk membentuk sebuah matriks dengan jumlah kolom yang telah ditentukan (routeKey). Matriks ini akan berisi teks x yang telah dibersihkan\n\n    kolom = routeKey\n    matrix = []\n    panjang = len(x)\n    temp = panjang/kolom\n    length = len(x)\n    bulat = round(temp)\n\n    if temp - bulat == 0:\n        jml_baris = bulat\n    else:\n        if temp - bulat &lt; 0:\n            jml_baris = bulat\n        else:\n            jml_baris = bulat + 1\n    print(jml_baris)\nFor More Detail :\n\nkolom = routeKey : Menetapkan jumlah kolom pada matriks dengan nilai routeKey\nmatrix = [] : Menginisialisasi sebuah list kosong yang akan digunakan untuk menyimpan elemen-elemen matriks\npanjang = len(x) : Menyimpan panjang dari teks x ke dalam variabel panjang\ntemp = panjang/kolom : Menghitung berapa banyak baris yang diperlukan dengan membagi panjang teks dengan jumlah kolom dan menyimpan hasilnya dalam variabel temp\nlength = len(x) : Menyimpan panjang teks x ke dalam variabel length\nbulat = round(temp) : Membulatkan hasil pembagian temp ke angka terdekat dan menyimpannya ke dalam variabel bulat\n\n\nMembangun matriks 2D yang berisi teks x yang telah dibersihkan (tanpa spasi), Matriks ini akan memiliki jml_baris baris dan kolom kolom\n\n    for i in range(jml_baris):\n        row = []\n        for j in range(kolom):\n            if i * kolom + j &lt; len(x):\n                elemen = [i * kolom + j]\n            else:\n                elemen = \" \"\n            row.append(elemen)\n        matrix.append(row)\nFor More Detail :\n\nfor i in range(jml_baris) : Loop ini mengiterasi dari 0 hingga jml_baris - 1, yang berarti setiap iterasi mewakili satu baris dalam matriks\nrow = [] : Membuat list kosong row yang akan menyimpan elemen-elemen untuk satu baris matriks\nfor j in range(kolom) : Loop ini mengiterasi dari 0 hingga kolom - 1, yang berarti setiap iterasi mewakili satu kolom dalam matriks\nif i * kolom + j &lt; len(x) : Mengecek apakah indeks (dihitung sebagai i * kolom + j) berada dalam rentang panjang teks x\nelemen = x[i * kolom + j] : Jika ya, Mengambil elemen dari teks x pada posisi i * kolom + j\nelemen = \" \" : Jika tidak, Mengisi elemen dengan spasi kosong jika indeks berada di luar panjang teks x -row.append(elemen) : Menambahkan elemen yang telah ditentukan (baik dari x atau spasi kosong) ke list row\nmatrix.append(row) : Menambahkan list row yang berisi elemen-elemen satu baris ke dalam list matrix\n\n\nMencetak matriks yang telah dibuat\n\n    print(\"Matriks yang Anda buat:\")\n    for row in matrix:\n        print(row)\n\nMembuat dan mencetak matriks transpose\n\n    transposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\n    for row in transposed_matrix:\n        print(row)\nFor More Detail :\n\nrow[i] for row in matrix : Menghasilkan list elemen ke-i dari setiap baris dalam matrix\nfor i in range(len(matrix[0]))] : Mengiterasi setiap indeks kolom dari matrix dan membentuk baris baru dari elemen-elemen tersebut\nfor row in transposed_matrix : Loop ini mengiterasi melalui setiap baris dalam transposed_matrix\n\n\nMengatur batas-batas dan kontrol iterasi saat mengisi transposed_matrix dalam pola spiral dengan karakter-karakter dari teks x\n\n    start_row, end_row = len(transposed_matrix) - 1, 0\n    start_col, end_col = len(transposed_matrix[0]) - 1, 0\n    text_index = 0\nFor More Detail :\n\nstart_row : Mengendalikan pengisian dari baris terakhir ke atas\nend_row : Mengendalikan pengisian dari baris pertama ke bawah\nend_row = 0 : Menetapkan indeks baris awal ke 0, yang berarti kita mulai dari baris pertama\nlen(transposed_matrix) : Memberikan jumlah baris dalam transposed_matrix\nMengurangkan 1 untuk mendapatkan indeks baris terakhir dari matriks transpose\nstart_col : Mengendalikan pengisian dari kolom terakhir ke kiri, sedangkan\nend_col : Mengendalikan pengisian dari kolom pertama ke kanan\nlen(transposed_matrix[0]) : Memberikan jumlah kolom dalam transposed_matrix\nMengurangkan 1 untuk mendapatkan indeks kolom terakhir dari matriks transpose\nend_col = 0 : Menetapkan indeks kolom awal ke 0, yang berarti kita mulai dari kolom pertama\ntext_index : Melacak posisi karakter dalam teks x yang sedang diproses\n\n\nMengisi baris pertama dari kanan ke kiri\n\n    while start_row &gt;= end_row and start_col &gt;= end_col:\n        # Fill the first row from the remaining rows\n        for i in range(start_col, end_col - 1, -1):\n            if text_index &lt; len(x):\n                transposed_matrix[start_row][i] = x[text_index]\n                text_index += 1\n\n        start_row -= 1\nFor More Detail :\n\nstart_col dan end_col : menentukan rentang kolom yang akan diisi\ntext_index : mengambil karakter dari teks x.\nTransposed_matrix[start_row][i] : Setiap karakter yang diambil dari x dimasukkan ke dalam posisi yang sesuai di t.\n\n\nMengisi kolom terakhir dari baris yang tersisa dalam matriks dengan karakter dari x dalam urutan spiral\n\n    for i in range(start_row, end_row - 1, -1):\n            if text_index &lt; len(x):\n                transposed_matrix[i][end_col] = x[text_index]\n                text_index += 1\n\n        end_col += 1\nFor More Detail :\n\nfor i in range(start_row, end_row - 1, -1) : Loop ini digunakan untuk iterasi melalui baris-baris dalam matriks dari start_row ke end_row - 1 dalam urutan menurun\nstart_row : Posisi baris awal untuk iterasi\nend_row - 1 : Posisi baris akhir (tidak termasuk) untuk iterasi\n-1 : Menunjukkan bahwa iterasi dilakukan secara menurun\nif text_index &lt; len(cipherText) : Kondisi ini memastikan bahwa indeks text_index masih dalam batas panjang cipherText\ntransposed_matrix[i][end_col] : Menunjukkan posisi kolom end_col dalam baris i dari matriks yang sedang diisi\ncipherText[text_index] : Karakter dari cipherText pada indeks text_index\ntext_index += 1 : Setelah menempatkan karakter dari cipherText ke dalam transposed_matrix, nilai text_index dinaikkan sebesar 1 untuk mempersiapkan karakter berikutnya pada iterasi selanjutnya\nend_col += 1 : Setelah menyelesaikan iterasi untuk mengisi kolom terakhir dari baris yang tersisa, end_col dinaikkan sebesar 1 untuk mempersempit batas kolom yang akan diisi pada iterasi berikutnya\n\n\nMenentukkan apakah batas kolom telah bertemu atau melewati satu sama lain, yang berarti bahwa semua kolom yang perlu diisi sudah selesai diproses\n\n    if start_col &lt; end_col:\n            break\n\nMengisi baris terakhir dari kolom yang tersisa dalam matriks dengan karakter dari x dalam urutan spiral.\n\n    for i in range(end_col, start_col + 1):\n            if text_index &lt; len(x):\n                transposed_matrix[end_row][i] = x[text_index]\n                text_index += 1\n\n        end_row += 1\nFor More Detail :\n\nfor i in range(end_col, start_col + 1): Loop ini digunakan untuk iterasi melalui kolom dari end_col ke start_col + 1\nend_col: Posisi kolom awal untuk iterasi\nstart_col + 1: Posisi kolom akhir (tidak termasuk) untuk iterasi, Menambah 1 untuk memasukkan start_col dalam iterasi\nif text_index &lt; len(x) : Kondisi ini memastikan bahwa indeks\ntext_index : Masih dalam batas panjang x. Hal ini untuk menghindari akses indeks yang tidak valid dari x\ntransposed_matrix[end_row][i] = x[text_index] Menetapkan karakter dari x pada posisi indeks text_index ke posisi [end_row][i] dalam transposed_matrix\ntransposed_matrix[end_row][i]: Menunjukkan posisi kolom i dalam baris end_row dari matriks yang sedang diisi.\nx[text_index]: Karakter dari x pada indeks text_index\ntext_index += 1 Setelah menempatkan karakter dari x ke dalam transposed_matrix, nilai text_index dinaikkan sebesar 1 untuk mempersiapkan karakter berikutnya pada iterasi selanjutnya\nend_row += 1 Setelah menyelesaikan iterasi untuk mengisi baris terakhir dari kolom yang tersisa, batas baris akhir (end_row) dinaikkan sebesar 1 untuk mempersempit batas baris yang akan diisi pada iterasi berikutnya\n\n\nMenghentikan loop while jika batas baris bertemu atau melewati satu sama lain, menandakan bahwa pengisian matriks dalam pola spiral sudah selesai\n\n    if start_row &lt; end_row:\n            break\n\nMengisi baris terakhir dari kolom yang tersisa dalam matriks dengan karakter dari x dalam urutan spiral\n\n    for i in range(end_row, start_row + 1):\n            if text_index &lt; len(x):\n                transposed_matrix[i][start_col] = x[text_index]\n                text_index += 1\n\n        start_col -= 1\nFor More Detail :\n\nfor i in range(end_row, start_row + 1) : Loop ini digunakan untuk iterasi melalui baris dari end_row ke start_row + 1 dalam urutan meningkat\nend_row : Posisi baris awal untuk iterasi\nstart_row + 1 : Posisi baris akhir (tidak termasuk) untuk iterasi, Menambah 1 untuk memasukkan start_row dalam iterasi\nif text_index &lt; len(x) : Kondisi ini memastikan bahwa indeks text_index masih dalam batas panjang x\ntransposed_matrix[i][start_col] : Menunjukkan posisi kolom start_col dalam baris i dari matriks yang sedang diisi\nx[text_index] : Karakter dari x pada indeks text_index\ntext_index += 1 : Nilai text_index dinaikkan sebesar 1 untuk mempersiapkan karakter berikutnya pada iterasi selanjutnya\nstart_col -= 1 : Batas kolom awal (start_col) dikurangi sebesar 1 untuk mempersempit batas kolom yang akan diisi pada iterasi berikutnya\n\n\nMencetak matriks yang telah diisi dengan ciphertext\n\n    print(\"Matriks setelah diisi dengan cipher secara spiral:\")\n    for row in transposed_matrix:\n        print(row)\n\nString kosong untuk menyimpan hasil teks yang telah didekripsi\n\n    decrypted_text = \"\"\n\nMenyimpan jumlah baris dari transposed_matrix dalam variabel num_rows\n\n    num_rows = len(transposed_matrix)\n\nMenghitung jumlah kolom dalam transposed_matrix\n\n    num_cols = len(transposed_matrix[0])\n\nMenggabungkan karakter-karakter dari transposed_matrix ke dalam decrypted_text dengan membaca matriks secara kolom demi kolom\n\n    for col in range(num_cols):  \n        for row in range(num_rows):  \n            decrypted_text += transposed_matrix[row][col]\nFor More Detail :\n\nfor col in range(num_cols): Loop for ini digunakan untuk iterasi melalui setiap kolom dalam transposed_matrix.\nnum_cols : Jumlah kolom dalam transposed_matrix Ini mengontrol jumlah iterasi, memastikan bahwa setiap kolom dalam matriks diproses\nfor row in range(num_rows) : Loop ini digunakan untuk iterasi melalui setiap baris dalam transposed_matrix untuk kolom yang saat ini sedang diproses oleh loop luar\nnum_rows : Jumlah baris dalam transposed_matrix Ini mengontrol jumlah iterasi, memastikan bahwa setiap baris dalam kolom yang sedang diproses dipertimbangkan\ntransposed_matrix[row][col] : Mengakses elemen pada baris row dan kolom col dalam matriks\ndecrypted_text +=: Operator += : Menambahkan karakter ke string decrypted_text\n\n\nMencetak hasil teks terdeskripsi\n\n    print(\"Teks terdekripsi setelah membaca secara berurutan:\")\n    print(decrypted_text)\nHasil Decrypted :\nTENTUKANPRIORITASANDASEBABKITATIDAKDAPATMENGERJAKANSEMUANYAX",
    "crumbs": [
      "Kriptografi Klasik",
      "8. Transposisi Route"
    ]
  },
  {
    "objectID": "10_DES.html#contoh-soal",
    "href": "10_DES.html#contoh-soal",
    "title": "2. DES",
    "section": "Contoh Soal",
    "text": "Contoh Soal\nPlaintext = COMPUTER Kunci (dalam Hex) = 13 34 57 79 9B BC DF F1 (64 Bit)\n\nUbah plaintext menjadi Biner\n\n   C, ascii = 67,    binary = 01000011\n\n   O, ascii = 79,    binary = 01001111\n\n   M, ascii = 77,    binary = 01001101\n\n   P, ascii = 80,    binary = 01010000\n\n   U, ascii = 85,    binary = 01010101\n\n   T, ascii = 84,    binary = 01010100\n    \n   E, ascii = 69,    binary = 01000101\n\n   R, ascii = 82,    binary = 01010010\n\n   Total ada 64 bit plaintex\n\nPermutasi Awal\nTujuan : mengacak plainteks sehingga urutan bit-bit di dalamnya berubah\n\n\n\n\nUrutan bit plaintext awal\n\n\n\n\n\nUrutan bit permutasi awal\n\n\n\nEncoding setiap 64 bit data pada Plaintext dengan IP (Initial Permutation)\n\n\n\n\nUrutan bit permutasi awal\n\n\n- P = 01000011 01001111 01001101 01010000 01010101 01010100 01000101 01010010\n\nHasil akhir permutasi awal :\n\nIP = 11111111 10111000 01110110 01010111 00000000 00000000 00000110 10000011\n\nMemecah Hasil IP\n\n\n\n\nPecah menjadi L0 dan R0\n\n\n\n\n\nPecah hasil IP menjadi bagian kiri sebanyak 32 bit (L0) dan kanan sebanyak 32 bit (R0)\n\n\n\nJadi hasilnya :\n\nL0 = 11111111 10111000 01110110 01010111\nR0 = 00000000 00000000 00000110 10000011\n\nPembangkitan Kunci\n\n\nKunci = 13 34 57 79 9B BC DF F1\nUbah K ke dalam fungsi Hexadecimal:\n\nK = 00010011 00110100 01010111 01111001  10011011 10111100 11011111 11110001 \n\nPermutasikan menggunakan Tabel PC-1\n\n\n\n\nKolom ke 8 dihilangkan\n\n\n\n\n\nYang tadiya berukuran 8x8, sekarang menjadi 7x8\n\n\n\nPermutasi PC-1\n\n\n\n\nGunakan permutasi PC-1 terhadap Key\n\n\nK = 00010011 00110100 01010111 01111001  10011011 10111100 11011111 11110001\n- K+= 1111000  0110011  0010101  0101111  0101010  1011001  1001111  0001111\n\nPecah menjadi C0 dan D0\n\n\n\n\nPecah permutasi PC-1 menjadi C0 dan D0\n\n\n\nSelanjutnya nilai K+ dibagi menjadi 2 bagian kanan dan kiri,C0 dan D0 yang setiap bagian 28 bit panjangnya \nHasilnya mendapatkan :\n\n  C0 = 1111000 0110011 0010101 0101111 \n  D0 = 0101010 1011001 1001111 0001111 \n\nMembuat Block Cn dan Dn\n\n\n\n\nBlok Cn-1 dan Dn-1 Di geser ke kiri\n\n\n\nSetelah mendapatkan C0 dan D0, sekarang kita membuat 6 blok Cn dan Dn yang setiap blok berasal dari Cn-1 dan Dn-1\nSelanjutnya, kedua bagian digeser ke kiri (left shift) sepanjang satu atau dua bit bergantung pada tiap putaran\nOperasi pergeseran bersifat wrapping atau round-shift\n\n\n\n\nTabel Jumlah Pergeseran Bit Pada Setiap Putaran\n\n\n\nHasil C0 dan D0\n\n\nDari C0 dan D0 awal kita mendapatkan :\n\nC0 = 1111000011001100101010101111 \nD0 = 0101010101100110011110001111 \n\nUntuk putaran 1, maka kita geser C0 dan D0 ke kiri sebanyak 1 kali\n\nC1 = 1110000110011001010101011111\nD1 = 1010101011001100111100011110\n\nUntuk putaran 2, mencari C1 dan D1 geser 1 kali. Selalu perhatikan tabel wrapping di slide sebelumnya dikarenakan untuk putaran 3 – 8 bergeser 2 kali. Dan lakukan seterusnya sampai C16 dan D16\n\nC16 = 111100001100110010101010111\nD16 = 010101010110011001111000111\n\nPermutasi PC-2\n\n\n\n\nSkema Permutasi PC-2\n\n\n\nGunakan permutasi PC-2\n\n\n\n\nPermutasi PC-2\n\n\n\nUntuk C1D1 kita mendapatkan\n\nC1D1 = 11100001 10011001 01010101 11111010 10101100 11001111 00011110\n\nDipermutasi menjadi\n\nK1 = 000110 110000 001011 101111 111111 000111 000001 110010\nKey Hasil PC-2\nK1  = 000110 110000 001011 101111 111111 000111 000001 110010\nK2  = 011110 011010 111011 011001 110110 111100 100111 100101\nK3  = 010101 011111 110010 001010 010000 101100 111110 011001 \nK4  = 011100 101010 110111 010110 110110 110011 010100 011101 \nK5  = 011111 001110 110000 000111 111010 110101 001110 101000 \nK6  = 011000 111010 010100 111110 010100 000111 101100 101111\nK7  = 111011 001000 010010 110111 111101 100001 100010 111100\nK8  = 111101 111000 101000 111010 110000 010011 101111 111011 \nK9  = 111000 001101 101111 101011 111011 011110 011110 000001\nK10 = 101100 011111 001101 000111 101110 100100 011001 001111 \nK11 = 001000 010101 111111 010011 110111 101101 001110 000110 \nK12 = 011101 010111 000111 110101 100101 000110 011111 101001 \nK13 = 100101 111100 010111 010001 111110 101011 101001 000001 \nK14 = 010111 110100 001110 110111 111100 101110 011100 111010 \nK15 = 101111 111001 000110 001101 001111 010011 111100 001010 \nK16 = 110010 110011 110110 001011 000011 100001 011111 110101\nHasil Sementara\n\nDari hasil proses sebelumnya sudah dilakukan proses permutasi awal terhadap plaintext yang mendapatkan nilai\n\nL0 = 11111111 10111000 01110110 01010111\nR0 = 00000000 00000000 00000110 10000011\n\nBerikutnya sudah didapatkan pula kunci sebanyak 16 buah untuk proses enchipering",
    "crumbs": [
      "Kriptografi Modern",
      "2. DES"
    ]
  },
  {
    "objectID": "10_DES.html#skema-membangkitkan-kunci-external",
    "href": "10_DES.html#skema-membangkitkan-kunci-external",
    "title": "2. DES",
    "section": "Skema Membangkitkan Kunci External",
    "text": "Skema Membangkitkan Kunci External\n\n\n\nSkema Pembangkitan Kunci External",
    "crumbs": [
      "Kriptografi Modern",
      "2. DES"
    ]
  },
  {
    "objectID": "15_Diffie_Hellman.html",
    "href": "15_Diffie_Hellman.html",
    "title": "7. Diffie Hellman",
    "section": "",
    "text": "Analogi Transposisi Route\nMari kita gunakan analogi kelas dengan siswa yang duduk di kursi dalam bentuk grid untuk menjelaskan algoritma transposisi route menggunakan pola spiral.\nBayangkan kamu adalah guru yang ingin mengatur ulang tempat duduk siswa sesuai pola spiral. Anda mulai dengan siswa pertama di sudut kiri atas, lalu bergerak ke kanan hingga akhir baris, turun ke baris berikutnya di sebelah kanan, kemudian bergerak ke kiri, dan seterusnya, sampai Anda kembali ke tengah grid. Berikut langkahnya :",
    "crumbs": [
      "Kriptografi Modern",
      "7. Diffie Hellman"
    ]
  },
  {
    "objectID": "15_Diffie_Hellman.html#implementasi-pada-python",
    "href": "15_Diffie_Hellman.html#implementasi-pada-python",
    "title": "7. Diffie Hellman",
    "section": "Implementasi Pada Python",
    "text": "Implementasi Pada Python\nMasukkan Plaintext\nCONTOH : TENTUKAN PRIORITAS ANDA SEBAB KITA TIDAK DAPAT MENGERJAKAN SEMUANYA X\nplainText = input(\"Plaintext : \")\nMasukkan Kunci\nCONTOH KEY : 5\nrouteKey = int(input(\"Kunci: \"))\nMenghapus Spasi\ncleanPlainTeks = plainTeks.replace(\" \", \"\")\nprint(cleanPlainTeks)\n\nProses Enkripsi\n\nMenyusun teks yang sudah dibersihkan ke dalam sebuah matriks dengan kolom sebagai jumlah kolom atau lebar matriks\n\n    kolom = routeKey\n    matrix = []\n    panjang = len(cleanPlainTeks)\n    temp = panjang/kolom\n    bulat = round(temp)\n\n    if temp - bulat == 0:\n        jml_baris = bulat\n    else:\n        if temp - bulat &lt; 0:\n            jml_baris = bulat\n        else:\n            jml_baris = bulat + 1\n    print(jml_baris)\nFor More Detail :\n\nkolom = routeKey : Menetapkan jumlah kolom pada matriks dengan nilai routeKey\nmatrix = [] : Menginisialisasi sebuah list kosong yang akan digunakan untuk menyimpan elemen-elemen matriks\npanjang = len(cleanPlainTeks) : Menghitung panjang teks yang sudah dibersihkan\ntemp = panjang/kolom : Menghitung berapa banyak baris yang diperlukan dengan membagi panjang teks dengan jumlah kolom dan menyimpan hasilnya dalam variabel temp\nbulat = round(temp) : Membulatkan hasil pembagian temp ke angka terdekat dan menyimpannya ke dalam variabel bulat\ntemp - bulat == 0 : hasil pembagian tepat bulat, maka jml_baris diambil dari bulat\ntemp - bulat &lt; 0 : hasil pembagian kurang dari bulat (mungkin karena temp lebih kecil dari bulat), dan juga mengambil jml_baris dari bulat\njml_baris = bulat + 1 : Jika kondisi sebelumnya tidak terpenuhi, maka perlu satu baris tambahan\n\n\nMembuat sebuah matriks (matrix) yang berisi teks yang sudah dibersihkan (cleanPlainTeks) menggunakan nilai jml_baris dan kolom yang telah dihitung sebelumnya\n\n    for i in range(jml_baris):\n        row = []\n        for j in range(kolom):\n            if i * kolom + j &lt; len(cleanPlainTeks):\n                elemen = cleanPlainTeks[i * kolom + j]\n            else:\n                elemen = \" \"\n            row.append(elemen)\n        matrix.append(row)\nFor More Detail :\n\nfor i in range(jml_baris) : Loop ini mengiterasi dari 0 hingga jml_baris - 1, yang berarti setiap iterasi mewakili satu baris dalam matriks\nrow = [] : Membuat list kosong row yang akan menyimpan elemen-elemen untuk satu baris matriks\nfor j in range(kolom) : Loop ini mengiterasi dari 0 hingga kolom - 1, yang berarti setiap iterasi mewakili satu kolom dalam matriks\nif i * kolom + j &lt; len(cleanPlainTeks) : Memastikan bahwa tidak melebihi panjang dari teks yang telah dibersihkan pada saat mengakses elemen cleanPlainTeks untuk dimasukkan ke dalam matrix\nelemen = x[i * kolom + j] : Jika ya, Mengambil elemen dari teks x pada posisi i * kolom + j\nelemen = \" \" : Jika tidak, Mengisi elemen dengan spasi kosong jika indeks berada di luar panjang teks x -row.append(elemen) : Menambahkan elemen yang telah ditentukan (baik dari x atau spasi kosong) ke list row\nmatrix.append(row) : Menambahkan list row yang berisi elemen-elemen satu baris ke dalam list matrix\n\n\nMencetak matrix\n\n    print(\"Matriks yang Anda buat:\")\n    for row in matrix:\n        print(row)\n\nMenghasilkan matriks transpose dari matrix yang telah dibuat\n\n    transposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\n    for row in transposed_matrix:\n        print(row)\nFor More Detail :\n\nrow[i] for row in matrix : Menghasilkan list elemen ke-i dari setiap baris dalam matrix\nfor i in range(len(matrix[0]))] : Mengiterasi setiap indeks kolom dari matrix dan membentuk baris baru dari elemen-elemen tersebut\nfor row in transposed_matrix : Loop ini mengiterasi melalui setiap baris dalam transposed_matrix\nprint(row) : Mencetak matriks transpose dari matrix\n\n\nString kosong yang akan digunakan untuk menyimpan teks yang terenkripsi\n\n    encrypted_text = \"\"\n\nMenandai batas awal dan akhir dari baris dan kolom pada matriks transpose\n\n    start_row, end_row = len(transposed_matrix) - 1, 0\n    start_col, end_col = len(transposed_matrix[0]) - 1, 0\n\nMengambil baris dari kanan ke kiri\n\n    while start_row &gt;= end_row and start_col &gt;= end_col:\n        for i in range(start_col, end_col - 1, -1):\n            encrypted_text += transposed_matrix[start_row][i]\n\n        start_row -= 1\nFor More Detail :\n\nwhile start_row &gt;= end_row and start_col &gt;= end_col : loop while yang berjalan selama start_row lebih besar dari atau sama dengan end_row dan start_col lebih besar dari atau sama dengan end_col\nfor i in range(start_col, end_col - 1, -1) : Loop ini mengiterasi dari kolom paling kanan (start_col) ke kolom paling kiri (end_col - 1)\nencrypted_text += transposed_matrix[start_row][i] : Menambahkan elemen dari baris start_row dan kolom i ke encrypted_text\nstart_row -= 1 : Mengurangi start_row untuk bergerak ke baris berikutnya ke atas\n\n\nMengambil kolom dari atas ke bawah\n\n    for i in range(start_row, end_row - 1, -1):\n            encrypted_text += transposed_matrix[i][end_col]\n\n        end_col += 1\nFor More Detail :\n\nfor i in range(start_row, end_row - 1, -1) : Loop ini mengiterasi dari baris start_row ke baris end_row - 1\nencrypted_text += transposed_matrix[i][end_col] : Menambahkan elemen dari baris i dan kolom end_col ke encrypted_text\nend_col += 1 : Menambahkan end_col untuk bergerak ke kolom berikutnya ke kiri.\n\n\nMengecek jika sudah mencapai kolom terakhir\n\n    if start_col &lt; end_col:\n            break\nFor More Detail :\n\nif start_col &lt; end_col: : Mengecek apakah start_col lebih kecil dari end_col\nbreak : Jika ya, keluar dari loop while.\n\n\nMengambil baris dari kiri ke kanan\n\n    for i in range(end_col, start_col + 1):\n            encrypted_text += transposed_matrix[end_row][i]\n\n        end_row += 1\nFor More Detail :\n\nfor i in range(end_col, start_col + 1) : Loop ini mengiterasi dari kolom end_col ke kolom start_col + 1\nencrypted_text += transposed_matrix[end_row][i] : Menambahkan elemen dari baris end_row dan kolom i ke encrypted_text\nend_row += 1 : Menambahkan end_row untuk bergerak ke baris berikutnya ke bawah.\n\n\nMengecek Jika Sudah Mencapai Baris Terakhir\n\n    if start_row &lt; end_row:\n            break\nFor More Detail :\n\nif start_row &lt; end_row : Mengecek apakah start_row lebih kecil dari end_row\nbreak : Jika ya, keluar dari loop while\n\n\nMengambil kolom dari bawah ke atas\n\n    for i in range(end_row, start_row + 1):\n            encrypted_text += transposed_matrix[i][start_col]\n\n        start_col -= 1\nFor More Detail :\n\nfor i in range(end_row, start_row + 1) : Loop ini mengiterasi dari baris end_row ke baris start_row + 1\nencrypted_text += transposed_matrix[i][start_col] : Menambahkan elemen dari baris i dan kolom start_col ke encrypted_text\nstart_col -= 1 : Mengurangi start_col untuk bergerak ke kolom berikutnya ke kanan\n\n\nMencetak teks terenkripsi (ciphertext)\n\nprint(\"Teks terenkripsi dengan pola spiral: \", encrypted_text[:length])\nFor More Detail :\n\nencrypted_text[:length]) : Memotong encrypted_text hingga panjang teks asli (length) untuk memastikan panjangnya sama dengan teks asli\n\nHASIL CIPHERTEXT : XUAETKAADTRUTNETKIAABTDMRNANYAMKGAATBNIPNAOSSKIAEJSEANPDIEAR\n\n\nProses Dekripsi\nMasukkan Ciphertext\ncipherText = input(\"cipher : \")\nMasukkan kunci\nrouteKey = int(input(\"Kunci: \"))\n\nMenentukan jumlah baris yang dibutuhkan untuk membentuk sebuah matriks dengan jumlah kolom yang telah ditentukan (routeKey). Matriks ini akan berisi teks x yang telah dibersihkan\n\n    kolom = routeKey\n    matrix = []\n    panjang = len(x)\n    temp = panjang/kolom\n    length = len(x)\n    bulat = round(temp)\n\n    if temp - bulat == 0:\n        jml_baris = bulat\n    else:\n        if temp - bulat &lt; 0:\n            jml_baris = bulat\n        else:\n            jml_baris = bulat + 1\n    print(jml_baris)\nFor More Detail :\n\nkolom = routeKey : Menetapkan jumlah kolom pada matriks dengan nilai routeKey\nmatrix = [] : Menginisialisasi sebuah list kosong yang akan digunakan untuk menyimpan elemen-elemen matriks\npanjang = len(x) : Menyimpan panjang dari teks x ke dalam variabel panjang\ntemp = panjang/kolom : Menghitung berapa banyak baris yang diperlukan dengan membagi panjang teks dengan jumlah kolom dan menyimpan hasilnya dalam variabel temp\nlength = len(x) : Menyimpan panjang teks x ke dalam variabel length\nbulat = round(temp) : Membulatkan hasil pembagian temp ke angka terdekat dan menyimpannya ke dalam variabel bulat\n\n\nMembangun matriks 2D yang berisi teks x yang telah dibersihkan (tanpa spasi), Matriks ini akan memiliki jml_baris baris dan kolom kolom\n\n    for i in range(jml_baris):\n        row = []\n        for j in range(kolom):\n            if i * kolom + j &lt; len(x):\n                elemen = [i * kolom + j]\n            else:\n                elemen = \" \"\n            row.append(elemen)\n        matrix.append(row)\nFor More Detail :\n\nfor i in range(jml_baris) : Loop ini mengiterasi dari 0 hingga jml_baris - 1, yang berarti setiap iterasi mewakili satu baris dalam matriks\nrow = [] : Membuat list kosong row yang akan menyimpan elemen-elemen untuk satu baris matriks\nfor j in range(kolom) : Loop ini mengiterasi dari 0 hingga kolom - 1, yang berarti setiap iterasi mewakili satu kolom dalam matriks\nif i * kolom + j &lt; len(x) : Mengecek apakah indeks (dihitung sebagai i * kolom + j) berada dalam rentang panjang teks x\nelemen = x[i * kolom + j] : Jika ya, Mengambil elemen dari teks x pada posisi i * kolom + j\nelemen = \" \" : Jika tidak, Mengisi elemen dengan spasi kosong jika indeks berada di luar panjang teks x -row.append(elemen) : Menambahkan elemen yang telah ditentukan (baik dari x atau spasi kosong) ke list row\nmatrix.append(row) : Menambahkan list row yang berisi elemen-elemen satu baris ke dalam list matrix\n\n\nMencetak matriks yang telah dibuat\n\n    print(\"Matriks yang Anda buat:\")\n    for row in matrix:\n        print(row)\n\nMembuat dan mencetak matriks transpose\n\n    transposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\n    for row in transposed_matrix:\n        print(row)\nFor More Detail :\n\nrow[i] for row in matrix : Menghasilkan list elemen ke-i dari setiap baris dalam matrix\nfor i in range(len(matrix[0]))] : Mengiterasi setiap indeks kolom dari matrix dan membentuk baris baru dari elemen-elemen tersebut\nfor row in transposed_matrix : Loop ini mengiterasi melalui setiap baris dalam transposed_matrix\n\n\nMengatur batas-batas dan kontrol iterasi saat mengisi transposed_matrix dalam pola spiral dengan karakter-karakter dari teks x\n\n    start_row, end_row = len(transposed_matrix) - 1, 0\n    start_col, end_col = len(transposed_matrix[0]) - 1, 0\n    text_index = 0\nFor More Detail :\n\nstart_row : Mengendalikan pengisian dari baris terakhir ke atas\nend_row : Mengendalikan pengisian dari baris pertama ke bawah\nend_row = 0 : Menetapkan indeks baris awal ke 0, yang berarti kita mulai dari baris pertama\nlen(transposed_matrix) : Memberikan jumlah baris dalam transposed_matrix\nMengurangkan 1 untuk mendapatkan indeks baris terakhir dari matriks transpose\nstart_col : Mengendalikan pengisian dari kolom terakhir ke kiri, sedangkan\nend_col : Mengendalikan pengisian dari kolom pertama ke kanan\nlen(transposed_matrix[0]) : Memberikan jumlah kolom dalam transposed_matrix\nMengurangkan 1 untuk mendapatkan indeks kolom terakhir dari matriks transpose\nend_col = 0 : Menetapkan indeks kolom awal ke 0, yang berarti kita mulai dari kolom pertama\ntext_index : Melacak posisi karakter dalam teks x yang sedang diproses\n\n\nMengisi baris pertama dari kanan ke kiri\n\n    while start_row &gt;= end_row and start_col &gt;= end_col:\n        # Fill the first row from the remaining rows\n        for i in range(start_col, end_col - 1, -1):\n            if text_index &lt; len(x):\n                transposed_matrix[start_row][i] = x[text_index]\n                text_index += 1\n\n        start_row -= 1\nFor More Detail :\n\nstart_col dan end_col : menentukan rentang kolom yang akan diisi\ntext_index : mengambil karakter dari teks x.\nTransposed_matrix[start_row][i] : Setiap karakter yang diambil dari x dimasukkan ke dalam posisi yang sesuai di t.\n\n\nMengisi kolom terakhir dari baris yang tersisa dalam matriks dengan karakter dari x dalam urutan spiral\n\n    for i in range(start_row, end_row - 1, -1):\n            if text_index &lt; len(x):\n                transposed_matrix[i][end_col] = x[text_index]\n                text_index += 1\n\n        end_col += 1\nFor More Detail :\n\nfor i in range(start_row, end_row - 1, -1) : Loop ini digunakan untuk iterasi melalui baris-baris dalam matriks dari start_row ke end_row - 1 dalam urutan menurun\nstart_row : Posisi baris awal untuk iterasi\nend_row - 1 : Posisi baris akhir (tidak termasuk) untuk iterasi\n-1 : Menunjukkan bahwa iterasi dilakukan secara menurun\nif text_index &lt; len(cipherText) : Kondisi ini memastikan bahwa indeks text_index masih dalam batas panjang cipherText\ntransposed_matrix[i][end_col] : Menunjukkan posisi kolom end_col dalam baris i dari matriks yang sedang diisi\ncipherText[text_index] : Karakter dari cipherText pada indeks text_index\ntext_index += 1 : Setelah menempatkan karakter dari cipherText ke dalam transposed_matrix, nilai text_index dinaikkan sebesar 1 untuk mempersiapkan karakter berikutnya pada iterasi selanjutnya\nend_col += 1 : Setelah menyelesaikan iterasi untuk mengisi kolom terakhir dari baris yang tersisa, end_col dinaikkan sebesar 1 untuk mempersempit batas kolom yang akan diisi pada iterasi berikutnya\n\n\nMenentukkan apakah batas kolom telah bertemu atau melewati satu sama lain, yang berarti bahwa semua kolom yang perlu diisi sudah selesai diproses\n\n    if start_col &lt; end_col:\n            break\n\nMengisi baris terakhir dari kolom yang tersisa dalam matriks dengan karakter dari x dalam urutan spiral.\n\n    for i in range(end_col, start_col + 1):\n            if text_index &lt; len(x):\n                transposed_matrix[end_row][i] = x[text_index]\n                text_index += 1\n\n        end_row += 1\nFor More Detail :\n\nfor i in range(end_col, start_col + 1): Loop ini digunakan untuk iterasi melalui kolom dari end_col ke start_col + 1\nend_col: Posisi kolom awal untuk iterasi\nstart_col + 1: Posisi kolom akhir (tidak termasuk) untuk iterasi, Menambah 1 untuk memasukkan start_col dalam iterasi\nif text_index &lt; len(x) : Kondisi ini memastikan bahwa indeks\ntext_index : Masih dalam batas panjang x. Hal ini untuk menghindari akses indeks yang tidak valid dari x\ntransposed_matrix[end_row][i] = x[text_index] Menetapkan karakter dari x pada posisi indeks text_index ke posisi [end_row][i] dalam transposed_matrix\ntransposed_matrix[end_row][i]: Menunjukkan posisi kolom i dalam baris end_row dari matriks yang sedang diisi.\nx[text_index]: Karakter dari x pada indeks text_index\ntext_index += 1 Setelah menempatkan karakter dari x ke dalam transposed_matrix, nilai text_index dinaikkan sebesar 1 untuk mempersiapkan karakter berikutnya pada iterasi selanjutnya\nend_row += 1 Setelah menyelesaikan iterasi untuk mengisi baris terakhir dari kolom yang tersisa, batas baris akhir (end_row) dinaikkan sebesar 1 untuk mempersempit batas baris yang akan diisi pada iterasi berikutnya\n\n\nMenghentikan loop while jika batas baris bertemu atau melewati satu sama lain, menandakan bahwa pengisian matriks dalam pola spiral sudah selesai\n\n    if start_row &lt; end_row:\n            break\n\nMengisi baris terakhir dari kolom yang tersisa dalam matriks dengan karakter dari x dalam urutan spiral\n\n    for i in range(end_row, start_row + 1):\n            if text_index &lt; len(x):\n                transposed_matrix[i][start_col] = x[text_index]\n                text_index += 1\n\n        start_col -= 1\nFor More Detail :\n\nfor i in range(end_row, start_row + 1) : Loop ini digunakan untuk iterasi melalui baris dari end_row ke start_row + 1 dalam urutan meningkat\nend_row : Posisi baris awal untuk iterasi\nstart_row + 1 : Posisi baris akhir (tidak termasuk) untuk iterasi, Menambah 1 untuk memasukkan start_row dalam iterasi\nif text_index &lt; len(x) : Kondisi ini memastikan bahwa indeks text_index masih dalam batas panjang x\ntransposed_matrix[i][start_col] : Menunjukkan posisi kolom start_col dalam baris i dari matriks yang sedang diisi\nx[text_index] : Karakter dari x pada indeks text_index\ntext_index += 1 : Nilai text_index dinaikkan sebesar 1 untuk mempersiapkan karakter berikutnya pada iterasi selanjutnya\nstart_col -= 1 : Batas kolom awal (start_col) dikurangi sebesar 1 untuk mempersempit batas kolom yang akan diisi pada iterasi berikutnya\n\n\nMencetak matriks yang telah diisi dengan ciphertext\n\n    print(\"Matriks setelah diisi dengan cipher secara spiral:\")\n    for row in transposed_matrix:\n        print(row)\n\nString kosong untuk menyimpan hasil teks yang telah didekripsi\n\n    decrypted_text = \"\"\n\nMenyimpan jumlah baris dari transposed_matrix dalam variabel num_rows\n\n    num_rows = len(transposed_matrix)\n\nMenghitung jumlah kolom dalam transposed_matrix\n\n    num_cols = len(transposed_matrix[0])\n\nMenggabungkan karakter-karakter dari transposed_matrix ke dalam decrypted_text dengan membaca matriks secara kolom demi kolom\n\n    for col in range(num_cols):  \n        for row in range(num_rows):  \n            decrypted_text += transposed_matrix[row][col]\nFor More Detail :\n\nfor col in range(num_cols): Loop for ini digunakan untuk iterasi melalui setiap kolom dalam transposed_matrix.\nnum_cols : Jumlah kolom dalam transposed_matrix Ini mengontrol jumlah iterasi, memastikan bahwa setiap kolom dalam matriks diproses\nfor row in range(num_rows) : Loop ini digunakan untuk iterasi melalui setiap baris dalam transposed_matrix untuk kolom yang saat ini sedang diproses oleh loop luar\nnum_rows : Jumlah baris dalam transposed_matrix Ini mengontrol jumlah iterasi, memastikan bahwa setiap baris dalam kolom yang sedang diproses dipertimbangkan\ntransposed_matrix[row][col] : Mengakses elemen pada baris row dan kolom col dalam matriks\ndecrypted_text +=: Operator += : Menambahkan karakter ke string decrypted_text\n\n\nMencetak hasil teks terdeskripsi\n\n    print(\"Teks terdekripsi setelah membaca secara berurutan:\")\n    print(decrypted_text)\nHasil Decrypted :\nTENTUKANPRIORITASANDASEBABKITATIDAKDAPATMENGERJAKANSEMUANYAX",
    "crumbs": [
      "Kriptografi Modern",
      "7. Diffie Hellman"
    ]
  },
  {
    "objectID": "10_DES.html#proses-enchiphering",
    "href": "10_DES.html#proses-enchiphering",
    "title": "2. DES",
    "section": "Proses Enchiphering",
    "text": "Proses Enchiphering\nDalam proses enchipering, setiap blok plainteks mengalami 16 kali putaran, Setiap putaran enciphering merupakan jaringan Feistel :\n\n\n\nSkema Enchipering\n\n\nLi = Ri – 1 \nRi = Li – 1  f(Ri – 1, Ki)\nketerangan :\n\nRi – 1, Dimulai dari L0 dan R0 yang sudah kita dapatkan\nK1, Sudah disiapkan 16 kunci dari proses sebelumnya\n\nBerikut Langkah-Langkah Proses Enchiphering\n\nFungsi f\n\n\n\n\nAlur Fungsi f\n\n\nketerangan :\n\n\n\n\nAlur ini merupakan turunan dari fungsi f sebelumnya\n\n\n\n\nTabel Ekspansi\n\n\nBerdasarkan diagram alur sebelumnya, proses selanjutnya adalah ekspansi pada blok Ri – 1 32-bit menjadi blok 48 bit\nFungsi ekspansi direalisasikan dengan matriks permutasi ekspansi :\n\n\n\n\nBagian kuning merupakan bit ekspansi yang diambil dari kolom Ri – 1\n\n\n\nExpansi R0\n\n\nHasil ekpansi, yaitu E(Ri – 1) di-XOR-kan dengan Ki menghasilkan vektor A 48-bit :\n\nR0 = 00000000 00000000 00000110 10000011 \nE(R0)= 100000 000000 000000 000000 000000 001101 010000 000110\n\n\nFungsi XOR untuk hasil A1\n\n\nHasil ekpansi, yaitu E(Ri – 1) di-XOR-kan dengan Ki menghasilkan vektor A 48-bit :\n\nE(R0)= 100000 000000 000000 000000 000000 001101 010000 000110\nK1   = 000110 110000 001011 101111 111111 000111 000001 110010\n-----------------------------------------------------------XOR\nA1   = 100110 110000 001011 101111 111111 001010 010001 110100\n\n\nPersiapan subtitusi S-Box\n\n\nVektor A dikelompokkan menjadi 8 kelompok, masing-masing 6 bit, dan menjadi masukan bagi proses substitusi\nAda 8 matriks substitusi, masing-masing dinyatakan dengan S-Box\nS-Box menerima masukan 6 bit dan memberikan keluaran 4 bit\nSubtitusikan dengan S1, S2, S3 dan seterusnya",
    "crumbs": [
      "Kriptografi Modern",
      "2. DES"
    ]
  }
]